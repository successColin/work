typeof window !== 'undefined' && (function(e, t) { typeof exports === 'object' && typeof module === 'object' ? module.exports = t() : typeof define === 'function' && define.amd ? define([], t) : typeof exports === 'object' ? exports.Hls = t() : e.Hls = t(); }(this, (() => (function(e) { const t = {}; function r(i) { if (t[i]) return t[i].exports; const a = t[i] = { i, l: !1, exports: {} }; return e[i].call(a.exports, a, a.exports, r), a.l = !0, a.exports; } return r.m = e, r.c = t, r.d = function(e, t, i) { r.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: i }); }, r.r = function(e) { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(e, '__esModule', { value: !0 }); }, r.t = function(e, t) { if (1 & t && (e = r(e)), 8 & t) return e; if (4 & t && typeof e === 'object' && e && e.__esModule) return e; const i = Object.create(null); if (r.r(i), Object.defineProperty(i, 'default', { enumerable: !0, value: e }), 2 & t && typeof e !== 'string') for (const a in e)r.d(i, a, ((t) => e[t]).bind(null, a)); return i; }, r.n = function(e) { const t = e && e.__esModule ? function() { return e.default; } : function() { return e; }; return r.d(t, 'a', t), t; }, r.o = function(e, t) { return Object.prototype.hasOwnProperty.call(e, t); }, r.p = '/dist/', r(r.s = 14); }([function(e, t, r) {
r.d(t, 'a', (() => d)), r.d(t, 'b', (() => c)); const i = r(5); function a() {} const n = { trace: a, debug: a, log: a, warn: a, info: a, error: a }; let s = n; function o(e, t) { return t = `[${e}] > ${t}`; } const l = Object(i.a)(); function u(e) { const t = l.console[e]; return t ? function() { for (var r = arguments.length, i = new Array(r), a = 0; a < r; a++)i[a] = arguments[a]; i[0] && (i[0] = o(e, i[0])), t.apply(l.console, i); } : a; } var d = function(e) { if (l.console && !0 === e || typeof e === 'object') { !(function(e) { for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)r[i - 1] = arguments[i]; r.forEach(((t) => { s[t] = e[t] ? e[t].bind(e) : u(t); })); }(e, 'debug', 'log', 'info', 'warn', 'error')); try { s.log(); } catch (e) { s = n; } } else s = n; }; var c = s;
}, function(e, t, r) {
t.a = { MEDIA_ATTACHING: 'hlsMediaAttaching', MEDIA_ATTACHED: 'hlsMediaAttached', MEDIA_DETACHING: 'hlsMediaDetaching', MEDIA_DETACHED: 'hlsMediaDetached', BUFFER_RESET: 'hlsBufferReset', BUFFER_CODECS: 'hlsBufferCodecs', BUFFER_CREATED: 'hlsBufferCreated', BUFFER_APPENDING: 'hlsBufferAppending', BUFFER_APPENDED: 'hlsBufferAppended', BUFFER_EOS: 'hlsBufferEos', BUFFER_FLUSHING: 'hlsBufferFlushing', BUFFER_FLUSHED: 'hlsBufferFlushed', MANIFEST_LOADING: 'hlsManifestLoading', MANIFEST_LOADED: 'hlsManifestLoaded', MANIFEST_PARSED: 'hlsManifestParsed', LEVEL_SWITCHING: 'hlsLevelSwitching', LEVEL_SWITCHED: 'hlsLevelSwitched', LEVEL_LOADING: 'hlsLevelLoading', LEVEL_LOADED: 'hlsLevelLoaded', LEVEL_UPDATED: 'hlsLevelUpdated', LEVEL_PTS_UPDATED: 'hlsLevelPtsUpdated', AUDIO_TRACKS_UPDATED: 'hlsAudioTracksUpdated', AUDIO_TRACK_SWITCHING: 'hlsAudioTrackSwitching', AUDIO_TRACK_SWITCHED: 'hlsAudioTrackSwitched', AUDIO_TRACK_LOADING: 'hlsAudioTrackLoading', AUDIO_TRACK_LOADED: 'hlsAudioTrackLoaded', SUBTITLE_TRACKS_UPDATED: 'hlsSubtitleTracksUpdated', SUBTITLE_TRACK_SWITCH: 'hlsSubtitleTrackSwitch', SUBTITLE_TRACK_LOADING: 'hlsSubtitleTrackLoading', SUBTITLE_TRACK_LOADED: 'hlsSubtitleTrackLoaded', SUBTITLE_FRAG_PROCESSED: 'hlsSubtitleFragProcessed', INIT_PTS_FOUND: 'hlsInitPtsFound', FRAG_LOADING: 'hlsFragLoading', FRAG_LOAD_PROGRESS: 'hlsFragLoadProgress', FRAG_LOAD_EMERGENCY_ABORTED: 'hlsFragLoadEmergencyAborted', FRAG_LOADED: 'hlsFragLoaded', FRAG_DECRYPTED: 'hlsFragDecrypted', FRAG_PARSING_INIT_SEGMENT: 'hlsFragParsingInitSegment', FRAG_PARSING_USERDATA: 'hlsFragParsingUserdata', FRAG_PARSING_METADATA: 'hlsFragParsingMetadata', FRAG_PARSING_DATA: 'hlsFragParsingData', FRAG_PARSED: 'hlsFragParsed', FRAG_BUFFERED: 'hlsFragBuffered', FRAG_CHANGED: 'hlsFragChanged', FPS_DROP: 'hlsFpsDrop', FPS_DROP_LEVEL_CAPPING: 'hlsFpsDropLevelCapping', ERROR: 'hlsError', DESTROYING: 'hlsDestroying', KEY_LOADING: 'hlsKeyLoading', KEY_LOADED: 'hlsKeyLoaded', STREAM_STATE_TRANSITION: 'hlsStreamStateTransition', LIVE_BACK_BUFFER_REACHED: 'hlsLiveBackBufferReached' };
}, function(e, t, r) {
let i; let a; r.d(t, 'b', (() => i)), r.d(t, 'a', (() => a)), (function(e) { e.NETWORK_ERROR = 'networkError', e.MEDIA_ERROR = 'mediaError', e.KEY_SYSTEM_ERROR = 'keySystemError', e.MUX_ERROR = 'muxError', e.OTHER_ERROR = 'otherError'; }(i || (i = {}))), (function(e) { e.KEY_SYSTEM_NO_KEYS = 'keySystemNoKeys', e.KEY_SYSTEM_NO_ACCESS = 'keySystemNoAccess', e.KEY_SYSTEM_NO_SESSION = 'keySystemNoSession', e.KEY_SYSTEM_LICENSE_REQUEST_FAILED = 'keySystemLicenseRequestFailed', e.KEY_SYSTEM_NO_INIT_DATA = 'keySystemNoInitData', e.MANIFEST_LOAD_ERROR = 'manifestLoadError', e.MANIFEST_LOAD_TIMEOUT = 'manifestLoadTimeOut', e.MANIFEST_PARSING_ERROR = 'manifestParsingError', e.MANIFEST_INCOMPATIBLE_CODECS_ERROR = 'manifestIncompatibleCodecsError', e.LEVEL_LOAD_ERROR = 'levelLoadError', e.LEVEL_LOAD_TIMEOUT = 'levelLoadTimeOut', e.LEVEL_SWITCH_ERROR = 'levelSwitchError', e.AUDIO_TRACK_LOAD_ERROR = 'audioTrackLoadError', e.AUDIO_TRACK_LOAD_TIMEOUT = 'audioTrackLoadTimeOut', e.FRAG_LOAD_ERROR = 'fragLoadError', e.FRAG_LOAD_TIMEOUT = 'fragLoadTimeOut', e.FRAG_DECRYPT_ERROR = 'fragDecryptError', e.FRAG_PARSING_ERROR = 'fragParsingError', e.REMUX_ALLOC_ERROR = 'remuxAllocError', e.KEY_LOAD_ERROR = 'keyLoadError', e.KEY_LOAD_TIMEOUT = 'keyLoadTimeOut', e.BUFFER_ADD_CODEC_ERROR = 'bufferAddCodecError', e.BUFFER_APPEND_ERROR = 'bufferAppendError', e.BUFFER_APPENDING_ERROR = 'bufferAppendingError', e.BUFFER_STALLED_ERROR = 'bufferStalledError', e.BUFFER_FULL_ERROR = 'bufferFullError', e.BUFFER_SEEK_OVER_HOLE = 'bufferSeekOverHole', e.BUFFER_NUDGE_ON_STALL = 'bufferNudgeOnStall', e.INTERNAL_EXCEPTION = 'internalException'; }(a || (a = {})));
}, function(e, t, r) {
r.d(t, 'a', (() => i)); var i = Number.isFinite || function(e) { return typeof e === 'number' && isFinite(e); };
}, function(e, t, r) {
r.d(t, 'b', (() => o)); let i; const a = r(5); const n = (function() { function e() {} return e.isHeader = function(e, t) { return t + 10 <= e.length && e[t] === 73 && e[t + 1] === 68 && e[t + 2] === 51 && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128; }, e.isFooter = function(e, t) { return t + 10 <= e.length && e[t] === 51 && e[t + 1] === 68 && e[t + 2] === 73 && e[t + 3] < 255 && e[t + 4] < 255 && e[t + 6] < 128 && e[t + 7] < 128 && e[t + 8] < 128 && e[t + 9] < 128; }, e.getID3Data = function(t, r) { for (var i = r, a = 0; e.isHeader(t, r);) { a += 10, a += e._readSize(t, r + 6), e.isFooter(t, r + 10) && (a += 10), r += a; } if (a > 0) return t.subarray(i, i + a); }, e._readSize = function(e, t) { let r = 0; return r = (127 & e[t]) << 21, r |= (127 & e[t + 1]) << 14, r |= (127 & e[t + 2]) << 7, r |= 127 & e[t + 3]; }, e.getTimeStamp = function(t) { for (let r = e.getID3Frames(t), i = 0; i < r.length; i++) { const a = r[i]; if (e.isTimeStampFrame(a)) return e._readTimeStamp(a); } }, e.isTimeStampFrame = function(e) { return e && e.key === 'PRIV' && e.info === 'com.apple.streaming.transportStreamTimestamp'; }, e._getFrameData = function(t) { const r = String.fromCharCode(t[0], t[1], t[2], t[3]); const i = e._readSize(t, 4); return { type: r, size: i, data: t.subarray(10, 10 + i) }; }, e.getID3Frames = function(t) { for (var r = 0, i = []; e.isHeader(t, r);) { for (let a = e._readSize(t, r + 6), n = (r += 10) + a; r + 8 < n;) { const s = e._getFrameData(t.subarray(r)); const o = e._decodeFrame(s); o && i.push(o), r += s.size + 10; }e.isFooter(t, r) && (r += 10); } return i; }, e._decodeFrame = function(t) { return t.type === 'PRIV' ? e._decodePrivFrame(t) : t.type[0] === 'T' ? e._decodeTextFrame(t) : t.type[0] === 'W' ? e._decodeURLFrame(t) : void 0; }, e._readTimeStamp = function(e) { if (e.data.byteLength === 8) { const t = new Uint8Array(e.data); const r = 1 & t[3]; let i = (t[4] << 23) + (t[5] << 15) + (t[6] << 7) + t[7]; return i /= 45, r && (i += 47721858.84), Math.round(i); } }, e._decodePrivFrame = function(t) { if (!(t.size < 2)) { const r = e._utf8ArrayToStr(t.data, !0); const i = new Uint8Array(t.data.subarray(r.length + 1)); return { key: t.type, info: r, data: i.buffer }; } }, e._decodeTextFrame = function(t) { if (!(t.size < 2)) { if (t.type === 'TXXX') { let r = 1; const i = e._utf8ArrayToStr(t.data.subarray(r), !0); r += i.length + 1; const a = e._utf8ArrayToStr(t.data.subarray(r)); return { key: t.type, info: i, data: a }; } const n = e._utf8ArrayToStr(t.data.subarray(1)); return { key: t.type, data: n }; } }, e._decodeURLFrame = function(t) { if (t.type === 'WXXX') { if (t.size < 2) return; let r = 1; const i = e._utf8ArrayToStr(t.data.subarray(r)); r += i.length + 1; const a = e._utf8ArrayToStr(t.data.subarray(r)); return { key: t.type, info: i, data: a }; } const n = e._utf8ArrayToStr(t.data); return { key: t.type, data: n }; }, e._utf8ArrayToStr = function(e, t) { void 0 === t && (t = !1); const r = s(); if (r) { const i = r.decode(e); if (t) { const a = i.indexOf('\0'); return a !== -1 ? i.substring(0, a) : i; } return i.replace(/\0/g, ''); } for (var n, o, l, u = e.length, d = '', c = 0; c < u;) { if ((n = e[c++]) === 0 && t) return d; if (n !== 0 && n !== 3) switch (n >> 4) { case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7: d += String.fromCharCode(n); break; case 12: case 13: o = e[c++], d += String.fromCharCode((31 & n) << 6 | 63 & o); break; case 14: o = e[c++], l = e[c++], d += String.fromCharCode((15 & n) << 12 | (63 & o) << 6 | (63 & l) << 0); } } return d; }, e; }()); function s() { const e = Object(a.a)(); return i || void 0 === e.TextDecoder || (i = new e.TextDecoder('utf-8')), i; } var o = n._utf8ArrayToStr; t.a = n;
}, function(e, t, r) {
function i() { return typeof window === 'undefined' ? self : window; }r.d(t, 'a', (() => i));
}, function(e, t, r) { let i; let a; let n; let s; let o; i = /^((?:[a-zA-Z0-9+\-.]+:)?)(\/\/[^\/?#]*)?((?:[^\/\?#]*\/)*.*?)??(;.*?)?(\?.*?)?(#.*?)?$/, a = /^([^\/?#]*)(.*)$/, n = /(?:\/|^)\.(?=\/)/g, s = /(?:\/|^)\.\.\/(?!\.\.\/).*?(?=\/)/g, o = { buildAbsoluteURL(e, t, r) { if (r = r || {}, e = e.trim(), !(t = t.trim())) { if (!r.alwaysNormalize) return e; const i = o.parseURL(e); if (!i) throw new Error('Error trying to parse base URL.'); return i.path = o.normalizePath(i.path), o.buildURLFromParts(i); } const n = o.parseURL(t); if (!n) throw new Error('Error trying to parse relative URL.'); if (n.scheme) return r.alwaysNormalize ? (n.path = o.normalizePath(n.path), o.buildURLFromParts(n)) : t; const s = o.parseURL(e); if (!s) throw new Error('Error trying to parse base URL.'); if (!s.netLoc && s.path && s.path[0] !== '/') { const l = a.exec(s.path); s.netLoc = l[1], s.path = l[2]; }s.netLoc && !s.path && (s.path = '/'); const u = { scheme: s.scheme, netLoc: n.netLoc, path: null, params: n.params, query: n.query, fragment: n.fragment }; if (!n.netLoc && (u.netLoc = s.netLoc, n.path[0] !== '/')) if (n.path) { const d = s.path; const c = d.substring(0, d.lastIndexOf('/') + 1) + n.path; u.path = o.normalizePath(c); } else u.path = s.path, n.params || (u.params = s.params, n.query || (u.query = s.query)); return u.path === null && (u.path = r.alwaysNormalize ? o.normalizePath(n.path) : n.path), o.buildURLFromParts(u); }, parseURL(e) { const t = i.exec(e); return t ? { scheme: t[1] || '', netLoc: t[2] || '', path: t[3] || '', params: t[4] || '', query: t[5] || '', fragment: t[6] || '' } : null; }, normalizePath(e) { for (e = e.split('').reverse().join('').replace(n, ''); e.length !== (e = e.replace(s, '')).length;);return e.split('').reverse().join(''); }, buildURLFromParts(e) { return e.scheme + e.netLoc + e.path + e.params + e.query + e.fragment; } }, e.exports = o; }, function(e, t, r) {
const i = (function() { function e(e, t) { this.subtle = e, this.aesIV = t; } return e.prototype.decrypt = function(e, t) { return this.subtle.decrypt({ name: 'AES-CBC', iv: this.aesIV }, t, e); }, e; }()); const a = (function() { function e(e, t) { this.subtle = e, this.key = t; } return e.prototype.expandKey = function() { return this.subtle.importKey('raw', this.key, { name: 'AES-CBC' }, !1, ['encrypt', 'decrypt']); }, e; }()); const n = (function() { function e() { this.rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)], this.sBox = new Uint32Array(256), this.invSBox = new Uint32Array(256), this.key = new Uint32Array(0), this.initTable(); } const t = e.prototype; return t.uint8ArrayToUint32Array_ = function(e) { for (var t = new DataView(e), r = new Uint32Array(4), i = 0; i < 4; i++)r[i] = t.getUint32(4 * i); return r; }, t.initTable = function() { const e = this.sBox; const t = this.invSBox; const r = this.subMix; const i = r[0]; const a = r[1]; const n = r[2]; const s = r[3]; const o = this.invSubMix; const l = o[0]; const u = o[1]; const d = o[2]; const c = o[3]; const h = new Uint32Array(256); let f = 0; let g = 0; let p = 0; for (p = 0; p < 256; p++)h[p] = p < 128 ? p << 1 : p << 1 ^ 283; for (p = 0; p < 256; p++) { let v = g ^ g << 1 ^ g << 2 ^ g << 3 ^ g << 4; v = v >>> 8 ^ 255 & v ^ 99, e[f] = v, t[v] = f; const m = h[f]; const y = h[m]; const b = h[y]; let T = 257 * h[v] ^ 16843008 * v; i[f] = T << 24 | T >>> 8, a[f] = T << 16 | T >>> 16, n[f] = T << 8 | T >>> 24, s[f] = T, T = 16843009 * b ^ 65537 * y ^ 257 * m ^ 16843008 * f, l[v] = T << 24 | T >>> 8, u[v] = T << 16 | T >>> 16, d[v] = T << 8 | T >>> 24, c[v] = T, f ? (f = m ^ h[h[h[b ^ m]]], g ^= h[h[g]]) : f = g = 1; } }, t.expandKey = function(e) { for (var t = this.uint8ArrayToUint32Array_(e), r = !0, i = 0; i < t.length && r;)r = t[i] === this.key[i], i++; if (!r) { this.key = t; const a = this.keySize = t.length; if (a !== 4 && a !== 6 && a !== 8) throw new Error(`Invalid aes key size=${a}`); let n; let s; let o; let l; const u = this.ksRows = 4 * (a + 6 + 1); const d = this.keySchedule = new Uint32Array(u); const c = this.invKeySchedule = new Uint32Array(u); const h = this.sBox; const f = this.rcon; const g = this.invSubMix; const p = g[0]; const v = g[1]; const m = g[2]; const y = g[3]; for (n = 0; n < u; n++)n < a ? o = d[n] = t[n] : (l = o, n % a == 0 ? (l = h[(l = l << 8 | l >>> 24) >>> 24] << 24 | h[l >>> 16 & 255] << 16 | h[l >>> 8 & 255] << 8 | h[255 & l], l ^= f[n / a | 0] << 24) : a > 6 && n % a == 4 && (l = h[l >>> 24] << 24 | h[l >>> 16 & 255] << 16 | h[l >>> 8 & 255] << 8 | h[255 & l]), d[n] = o = (d[n - a] ^ l) >>> 0); for (s = 0; s < u; s++)n = u - s, l = 3 & s ? d[n] : d[n - 4], c[s] = s < 4 || n <= 4 ? l : p[h[l >>> 24]] ^ v[h[l >>> 16 & 255]] ^ m[h[l >>> 8 & 255]] ^ y[h[255 & l]], c[s] = c[s] >>> 0; } }, t.networkToHostOrderSwap = function(e) { return e << 24 | (65280 & e) << 8 | (16711680 & e) >> 8 | e >>> 24; }, t.decrypt = function(e, t, r, i) { for (var a, n, s, o, l, u, d, c, h, f, g, p, v, m, y, b, T, E = this.keySize + 6, S = this.invKeySchedule, _ = this.invSBox, A = this.invSubMix, R = A[0], w = A[1], k = A[2], L = A[3], D = this.uint8ArrayToUint32Array_(r), C = D[0], I = D[1], O = D[2], x = D[3], P = new Int32Array(e), M = new Int32Array(P.length), F = this.networkToHostOrderSwap; t < P.length;) { for (h = F(P[t]), f = F(P[t + 1]), g = F(P[t + 2]), p = F(P[t + 3]), l = h ^ S[0], u = p ^ S[1], d = g ^ S[2], c = f ^ S[3], v = 4, m = 1; m < E; m++)a = R[l >>> 24] ^ w[u >> 16 & 255] ^ k[d >> 8 & 255] ^ L[255 & c] ^ S[v], n = R[u >>> 24] ^ w[d >> 16 & 255] ^ k[c >> 8 & 255] ^ L[255 & l] ^ S[v + 1], s = R[d >>> 24] ^ w[c >> 16 & 255] ^ k[l >> 8 & 255] ^ L[255 & u] ^ S[v + 2], o = R[c >>> 24] ^ w[l >> 16 & 255] ^ k[u >> 8 & 255] ^ L[255 & d] ^ S[v + 3], l = a, u = n, d = s, c = o, v += 4; a = _[l >>> 24] << 24 ^ _[u >> 16 & 255] << 16 ^ _[d >> 8 & 255] << 8 ^ _[255 & c] ^ S[v], n = _[u >>> 24] << 24 ^ _[d >> 16 & 255] << 16 ^ _[c >> 8 & 255] << 8 ^ _[255 & l] ^ S[v + 1], s = _[d >>> 24] << 24 ^ _[c >> 16 & 255] << 16 ^ _[l >> 8 & 255] << 8 ^ _[255 & u] ^ S[v + 2], o = _[c >>> 24] << 24 ^ _[l >> 16 & 255] << 16 ^ _[u >> 8 & 255] << 8 ^ _[255 & d] ^ S[v + 3], v += 3, M[t] = F(a ^ C), M[t + 1] = F(o ^ I), M[t + 2] = F(s ^ O), M[t + 3] = F(n ^ x), C = h, I = f, O = g, x = p, t += 4; } return i ? (y = M.buffer, b = y.byteLength, (T = b && new DataView(y).getUint8(b - 1)) ? y.slice(0, b - T) : y) : M.buffer; }, t.destroy = function() { this.key = void 0, this.keySize = void 0, this.ksRows = void 0, this.sBox = void 0, this.invSBox = void 0, this.subMix = void 0, this.invSubMix = void 0, this.keySchedule = void 0, this.invKeySchedule = void 0, this.rcon = void 0; }, e; }()); const s = r(2); const o = r(0); const l = r(1); const u = r(5); const d = Object(u.a)(); const c = (function() { function e(e, t, r) { const i = (void 0 === r ? {} : r).removePKCS7Padding; const a = void 0 === i || i; if (this.logEnabled = !0, this.observer = e, this.config = t, this.removePKCS7Padding = a, a) try { const n = d.crypto; n && (this.subtle = n.subtle || n.webkitSubtle); } catch (e) {} this.disableWebCrypto = !this.subtle; } const t = e.prototype; return t.isSync = function() { return this.disableWebCrypto && this.config.enableSoftwareAES; }, t.decrypt = function(e, t, r, s) { const l = this; if (this.disableWebCrypto && this.config.enableSoftwareAES) { this.logEnabled && (o.b.log('JS AES decrypt'), this.logEnabled = !1); let u = this.decryptor; u || (this.decryptor = u = new n()), u.expandKey(t), s(u.decrypt(e, 0, r, this.removePKCS7Padding)); } else { this.logEnabled && (o.b.log('WebCrypto AES decrypt'), this.logEnabled = !1); const d = this.subtle; this.key !== t && (this.key = t, this.fastAesKey = new a(d, t)), this.fastAesKey.expandKey().then(((a) => { new i(d, r).decrypt(e, a).catch(((i) => { l.onWebCryptoError(i, e, t, r, s); })).then(((e) => { s(e); })); })).catch(((i) => { l.onWebCryptoError(i, e, t, r, s); })); } }, t.onWebCryptoError = function(e, t, r, i, a) { this.config.enableSoftwareAES ? (o.b.log('WebCrypto Error, disable WebCrypto API'), this.disableWebCrypto = !0, this.logEnabled = !0, this.decrypt(t, r, i, a)) : (o.b.error(`decrypting error : ${e.message}`), this.observer.trigger(l.a.ERROR, { type: s.b.MEDIA_ERROR, details: s.a.FRAG_DECRYPT_ERROR, fatal: !0, reason: e.message })); }, t.destroy = function() { const e = this.decryptor; e && (e.destroy(), this.decryptor = void 0); }, e; }()); t.a = c;
}, function(e, t, r) {
const i = Object.prototype.hasOwnProperty; let a = '~'; function n() {} function s(e, t, r) { this.fn = e, this.context = t, this.once = r || !1; } function o(e, t, r, i, n) { if (typeof r !== 'function') throw new TypeError('The listener must be a function'); const o = new s(r, i || e, n); const l = a ? a + t : t; return e._events[l] ? e._events[l].fn ? e._events[l] = [e._events[l], o] : e._events[l].push(o) : (e._events[l] = o, e._eventsCount++), e; } function l(e, t) { --e._eventsCount == 0 ? e._events = new n() : delete e._events[t]; } function u() { this._events = new n(), this._eventsCount = 0; }Object.create && (n.prototype = Object.create(null), (new n()).__proto__ || (a = !1)), u.prototype.eventNames = function() { let e; let t; const r = []; if (this._eventsCount === 0) return r; for (t in e = this._events)i.call(e, t) && r.push(a ? t.slice(1) : t); return Object.getOwnPropertySymbols ? r.concat(Object.getOwnPropertySymbols(e)) : r; }, u.prototype.listeners = function(e) { const t = a ? a + e : e; const r = this._events[t]; if (!r) return []; if (r.fn) return [r.fn]; for (var i = 0, n = r.length, s = new Array(n); i < n; i++)s[i] = r[i].fn; return s; }, u.prototype.listenerCount = function(e) { const t = a ? a + e : e; const r = this._events[t]; return r ? r.fn ? 1 : r.length : 0; }, u.prototype.emit = function(e, t, r, i, n, s) { const o = a ? a + e : e; if (!this._events[o]) return !1; let l; let u; const d = this._events[o]; const c = arguments.length; if (d.fn) { switch (d.once && this.removeListener(e, d.fn, void 0, !0), c) { case 1: return d.fn.call(d.context), !0; case 2: return d.fn.call(d.context, t), !0; case 3: return d.fn.call(d.context, t, r), !0; case 4: return d.fn.call(d.context, t, r, i), !0; case 5: return d.fn.call(d.context, t, r, i, n), !0; case 6: return d.fn.call(d.context, t, r, i, n, s), !0; } for (u = 1, l = new Array(c - 1); u < c; u++)l[u - 1] = arguments[u]; d.fn.apply(d.context, l); } else { let h; const f = d.length; for (u = 0; u < f; u++) switch (d[u].once && this.removeListener(e, d[u].fn, void 0, !0), c) { case 1: d[u].fn.call(d[u].context); break; case 2: d[u].fn.call(d[u].context, t); break; case 3: d[u].fn.call(d[u].context, t, r); break; case 4: d[u].fn.call(d[u].context, t, r, i); break; default: if (!l) for (h = 1, l = new Array(c - 1); h < c; h++)l[h - 1] = arguments[h]; d[u].fn.apply(d[u].context, l); } } return !0; }, u.prototype.on = function(e, t, r) { return o(this, e, t, r, !1); }, u.prototype.once = function(e, t, r) { return o(this, e, t, r, !0); }, u.prototype.removeListener = function(e, t, r, i) { const n = a ? a + e : e; if (!this._events[n]) return this; if (!t) return l(this, n), this; const s = this._events[n]; if (s.fn)s.fn !== t || i && !s.once || r && s.context !== r || l(this, n); else { for (var o = 0, u = [], d = s.length; o < d; o++)(s[o].fn !== t || i && !s[o].once || r && s[o].context !== r) && u.push(s[o]); u.length ? this._events[n] = u.length === 1 ? u[0] : u : l(this, n); } return this; }, u.prototype.removeAllListeners = function(e) { let t; return e ? (t = a ? a + e : e, this._events[t] && l(this, t)) : (this._events = new n(), this._eventsCount = 0), this; }, u.prototype.off = u.prototype.removeListener, u.prototype.addListener = u.prototype.on, u.prefixed = a, u.EventEmitter = u, e.exports = u;
}, function(e, t, r) {
const i = r(1); const a = r(2); const n = r(7); const s = r(3); const o = r(0); const l = r(5); function u(e, t) { return e[t] === 255 && (246 & e[t + 1]) == 240; } function d(e, t) { return 1 & e[t + 1] ? 7 : 9; } function c(e, t) { return (3 & e[t + 3]) << 11 | e[t + 4] << 3 | (224 & e[t + 5]) >>> 5; } function h(e, t) { return !!(t + 1 < e.length && u(e, t)); } function f(e, t) { if (h(e, t)) { let r = d(e, t); t + 5 < e.length && (r = c(e, t)); const i = t + r; if (i === e.length || i + 1 < e.length && u(e, i)) return !0; } return !1; } function g(e, t, r, n, s) { if (!e.samplerate) { const l = (function(e, t, r, n) { let s; let l; let u; let d; let c; const h = navigator.userAgent.toLowerCase(); const f = n; const g = [96e3, 88200, 64e3, 48e3, 44100, 32e3, 24e3, 22050, 16e3, 12e3, 11025, 8e3, 7350]; if (s = 1 + ((192 & t[r + 2]) >>> 6), !((l = (60 & t[r + 2]) >>> 2) > g.length - 1)) return d = (1 & t[r + 2]) << 2, d |= (192 & t[r + 3]) >>> 6, o.b.log(`manifest codec:${n},ADTS data:type:${s},sampleingIndex:${l}[${g[l]}Hz],channelConfig:${d}`), /firefox/i.test(h) ? l >= 6 ? (s = 5, c = new Array(4), u = l - 3) : (s = 2, c = new Array(2), u = l) : h.indexOf('android') !== -1 ? (s = 2, c = new Array(2), u = l) : (s = 5, c = new Array(4), n && (n.indexOf('mp4a.40.29') !== -1 || n.indexOf('mp4a.40.5') !== -1) || !n && l >= 6 ? u = l - 3 : ((n && n.indexOf('mp4a.40.2') !== -1 && (l >= 6 && d === 1 || /vivaldi/i.test(h)) || !n && d === 1) && (s = 2, c = new Array(2)), u = l)), c[0] = s << 3, c[0] |= (14 & l) >> 1, c[1] |= (1 & l) << 7, c[1] |= d << 3, s === 5 && (c[1] |= (14 & u) >> 1, c[2] = (1 & u) << 7, c[2] |= 8, c[3] = 0), { config: c, samplerate: g[l], channelCount: d, codec: `mp4a.40.${s}`, manifestCodec: f }; e.trigger(i.a.ERROR, { type: a.b.MEDIA_ERROR, details: a.a.FRAG_PARSING_ERROR, fatal: !0, reason: `invalid ADTS sampling index:${l}` }); }(t, r, n, s)); e.config = l.config, e.samplerate = l.samplerate, e.channelCount = l.channelCount, e.codec = l.codec, e.manifestCodec = l.manifestCodec, o.b.log(`parsed codec:${e.codec},rate:${l.samplerate},nb channel:${l.channelCount}`); } } function p(e) { return 9216e4 / e; } function v(e, t, r, i, a) { const n = (function(e, t, r, i, a) { let n; let s; const o = e.length; if (n = d(e, t), s = c(e, t), (s -= n) > 0 && t + n + s <= o) return { headerLength: n, frameLength: s, stamp: r + i * a }; }(t, r, i, a, p(e.samplerate))); if (n) { const s = n.stamp; const o = n.headerLength; const l = n.frameLength; const u = { unit: t.subarray(r + o, r + o + l), pts: s, dts: s }; return e.samples.push(u), { sample: u, length: l + o }; } } const m = r(4); const y = (function() { function e(e, t, r) { this.observer = e, this.config = r, this.remuxer = t; } const t = e.prototype; return t.resetInitSegment = function(e, t, r, i) { this._audioTrack = { container: 'audio/adts', type: 'audio', id: 0, sequenceNumber: 0, isAAC: !0, samples: [], len: 0, manifestCodec: t, duration: i, inputTimeScale: 9e4 }; }, t.resetTimeStamp = function() {}, e.probe = function(e) { if (!e) return !1; for (let t = (m.a.getID3Data(e, 0) || []).length, r = e.length; t < r; t++) if (f(e, t)) return o.b.log('ADTS sync word found !'), !0; return !1; }, t.append = function(e, t, r, i) { for (var a = this._audioTrack, n = m.a.getID3Data(e, 0) || [], l = m.a.getTimeStamp(n), u = Object(s.a)(l) ? 90 * l : 9e4 * t, d = 0, c = u, f = e.length, p = n.length, y = [{ pts: c, dts: c, data: n }]; p < f - 1;) if (h(e, p) && p + 5 < f) { g(a, this.observer, e, p, a.manifestCodec); const b = v(a, e, p, u, d); if (!b) { o.b.log('Unable to parse AAC frame'); break; }p += b.length, c = b.sample.pts, d++; } else m.a.isHeader(e, p) ? (n = m.a.getID3Data(e, p), y.push({ pts: c, dts: c, data: n }), p += n.length) : p++; this.remuxer.remux(a, { samples: [] }, { samples: y, inputTimeScale: 9e4 }, { samples: [] }, t, r, i); }, t.destroy = function() {}, e; }()); const b = r(10); var T = { BitratesMap: [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160], SamplingRateMap: [44100, 48e3, 32e3, 22050, 24e3, 16e3, 11025, 12e3, 8e3], SamplesCoefficients: [[0, 72, 144, 12], [0, 0, 0, 0], [0, 72, 144, 12], [0, 144, 144, 12]], BytesInSlot: [0, 1, 1, 4], appendFrame(e, t, r, i, a) { if (!(r + 24 > t.length)) { const n = this.parseHeader(t, r); if (n && r + n.frameLength <= t.length) { const s = i + a * (9e4 * n.samplesPerFrame / n.sampleRate); const o = { unit: t.subarray(r, r + n.frameLength), pts: s, dts: s }; return e.config = [], e.channelCount = n.channelCount, e.samplerate = n.sampleRate, e.samples.push(o), { sample: o, length: n.frameLength }; } } }, parseHeader(e, t) { const r = e[t + 1] >> 3 & 3; const i = e[t + 1] >> 1 & 3; const a = e[t + 2] >> 4 & 15; const n = e[t + 2] >> 2 & 3; const s = e[t + 2] >> 1 & 1; if (r !== 1 && a !== 0 && a !== 15 && n !== 3) { const o = r === 3 ? 3 - i : i === 3 ? 3 : 4; const l = 1e3 * T.BitratesMap[14 * o + a - 1]; const u = r === 3 ? 0 : r === 2 ? 1 : 2; const d = T.SamplingRateMap[3 * u + n]; const c = e[t + 3] >> 6 == 3 ? 1 : 2; const h = T.SamplesCoefficients[r][i]; const f = T.BytesInSlot[i]; const g = 8 * h * f; return { sampleRate: d, channelCount: c, frameLength: parseInt(h * l / d + s, 10) * f, samplesPerFrame: g }; } }, isHeaderPattern(e, t) { return e[t] === 255 && (224 & e[t + 1]) == 224 && (6 & e[t + 1]) != 0; }, isHeader(e, t) { return !!(t + 1 < e.length && this.isHeaderPattern(e, t)); }, probe(e, t) { if (t + 1 < e.length && this.isHeaderPattern(e, t)) { const r = this.parseHeader(e, t); let i = 4; r && r.frameLength && (i = r.frameLength); const a = t + i; if (a === e.length || a + 1 < e.length && this.isHeaderPattern(e, a)) return !0; } return !1; } }; const E = T; const S = (function() { function e(e) { this.data = e, this.bytesAvailable = e.byteLength, this.word = 0, this.bitsAvailable = 0; } const t = e.prototype; return t.loadWord = function() { const e = this.data; const t = this.bytesAvailable; const r = e.byteLength - t; const i = new Uint8Array(4); const a = Math.min(4, t); if (a === 0) throw new Error('no bytes available'); i.set(e.subarray(r, r + a)), this.word = new DataView(i.buffer).getUint32(0), this.bitsAvailable = 8 * a, this.bytesAvailable -= a; }, t.skipBits = function(e) { let t; this.bitsAvailable > e ? (this.word <<= e, this.bitsAvailable -= e) : (e -= this.bitsAvailable, e -= (t = e >> 3) >> 3, this.bytesAvailable -= t, this.loadWord(), this.word <<= e, this.bitsAvailable -= e); }, t.readBits = function(e) { let t = Math.min(this.bitsAvailable, e); const r = this.word >>> 32 - t; return e > 32 && o.b.error('Cannot read more than 32 bits at a time'), this.bitsAvailable -= t, this.bitsAvailable > 0 ? this.word <<= t : this.bytesAvailable > 0 && this.loadWord(), (t = e - t) > 0 && this.bitsAvailable ? r << t | this.readBits(t) : r; }, t.skipLZ = function() { let e; for (e = 0; e < this.bitsAvailable; ++e) if ((this.word & 2147483648 >>> e) != 0) return this.word <<= e, this.bitsAvailable -= e, e; return this.loadWord(), e + this.skipLZ(); }, t.skipUEG = function() { this.skipBits(1 + this.skipLZ()); }, t.skipEG = function() { this.skipBits(1 + this.skipLZ()); }, t.readUEG = function() { const e = this.skipLZ(); return this.readBits(e + 1) - 1; }, t.readEG = function() { const e = this.readUEG(); return 1 & e ? 1 + e >>> 1 : -1 * (e >>> 1); }, t.readBoolean = function() { return this.readBits(1) === 1; }, t.readUByte = function() { return this.readBits(8); }, t.readUShort = function() { return this.readBits(16); }, t.readUInt = function() { return this.readBits(32); }, t.skipScalingList = function(e) { let t; let r = 8; let i = 8; for (t = 0; t < e; t++)i !== 0 && (i = (r + this.readEG() + 256) % 256), r = i === 0 ? r : i; }, t.readSPS = function() { let e; let t; let r; let i; let a; let n; let s; let o = 0; let l = 0; let u = 0; let d = 0; const c = this.readUByte.bind(this); const h = this.readBits.bind(this); const f = this.readUEG.bind(this); const g = this.readBoolean.bind(this); const p = this.skipBits.bind(this); const v = this.skipEG.bind(this); const m = this.skipUEG.bind(this); const y = this.skipScalingList.bind(this); if (c(), e = c(), h(5), p(3), c(), m(), e === 100 || e === 110 || e === 122 || e === 244 || e === 44 || e === 83 || e === 86 || e === 118 || e === 128) { const b = f(); if (b === 3 && p(1), m(), m(), p(1), g()) for (n = b !== 3 ? 8 : 12, s = 0; s < n; s++)g() && y(s < 6 ? 16 : 64); }m(); const T = f(); if (T === 0)f(); else if (T === 1) for (p(1), v(), v(), t = f(), s = 0; s < t; s++)v(); m(), p(1), r = f(), i = f(), (a = h(1)) === 0 && p(1), p(1), g() && (o = f(), l = f(), u = f(), d = f()); let E = [1, 1]; if (g() && g()) switch (c()) { case 1: E = [1, 1]; break; case 2: E = [12, 11]; break; case 3: E = [10, 11]; break; case 4: E = [16, 11]; break; case 5: E = [40, 33]; break; case 6: E = [24, 11]; break; case 7: E = [20, 11]; break; case 8: E = [32, 11]; break; case 9: E = [80, 33]; break; case 10: E = [18, 11]; break; case 11: E = [15, 11]; break; case 12: E = [64, 33]; break; case 13: E = [160, 99]; break; case 14: E = [4, 3]; break; case 15: E = [3, 2]; break; case 16: E = [2, 1]; break; case 255: E = [c() << 8 | c(), c() << 8 | c()]; } return { width: Math.ceil(16 * (r + 1) - 2 * o - 2 * l), height: (2 - a) * (i + 1) * 16 - (a ? 2 : 4) * (u + d), pixelRatio: E }; }, t.readSliceType = function() { return this.readUByte(), this.readUEG(), this.readUEG(); }, e; }()); const _ = (function() { function e(e, t, r, i) { this.decryptdata = r, this.discardEPB = i, this.decrypter = new n.a(e, t, { removePKCS7Padding: !1 }); } const t = e.prototype; return t.decryptBuffer = function(e, t) { this.decrypter.decrypt(e, this.decryptdata.key.buffer, this.decryptdata.iv.buffer, t); }, t.decryptAacSample = function(e, t, r, i) { const a = e[t].unit; const n = a.subarray(16, a.length - a.length % 16); const s = n.buffer.slice(n.byteOffset, n.byteOffset + n.length); const o = this; this.decryptBuffer(s, ((n) => { n = new Uint8Array(n), a.set(n, 16), i || o.decryptAacSamples(e, t + 1, r); })); }, t.decryptAacSamples = function(e, t, r) { for (;;t++) { if (t >= e.length) return void r(); if (!(e[t].unit.length < 32)) { const i = this.decrypter.isSync(); if (this.decryptAacSample(e, t, r, i), !i) return; } } }, t.getAvcEncryptedData = function(e) { for (var t = 16 * Math.floor((e.length - 48) / 160) + 16, r = new Int8Array(t), i = 0, a = 32; a <= e.length - 16; a += 160, i += 16)r.set(e.subarray(a, a + 16), i); return r; }, t.getAvcDecryptedUnit = function(e, t) { t = new Uint8Array(t); for (let r = 0, i = 32; i <= e.length - 16; i += 160, r += 16)e.set(t.subarray(r, r + 16), i); return e; }, t.decryptAvcSample = function(e, t, r, i, a, n) { const s = this.discardEPB(a.data); const o = this.getAvcEncryptedData(s); const l = this; this.decryptBuffer(o.buffer, ((o) => { a.data = l.getAvcDecryptedUnit(s, o), n || l.decryptAvcSamples(e, t, r + 1, i); })); }, t.decryptAvcSamples = function(e, t, r, i) { for (;;t++, r = 0) { if (t >= e.length) return void i(); for (let a = e[t].units; !(r >= a.length); r++) { const n = a[r]; if (!(n.length <= 48 || n.type !== 1 && n.type !== 5)) { const s = this.decrypter.isSync(); if (this.decryptAvcSample(e, t, r, i, n, s), !s) return; } } } }, e; }()); const A = { video: 1, audio: 2, id3: 3, text: 4 }; const R = (function() { function e(e, t, r, i) { this.observer = e, this.config = r, this.typeSupported = i, this.remuxer = t, this.sampleAes = null; } const t = e.prototype; return t.setDecryptData = function(e) { e != null && e.key != null && e.method === 'SAMPLE-AES' ? this.sampleAes = new _(this.observer, this.config, e, this.discardEPB) : this.sampleAes = null; }, e.probe = function(t) { const r = e._syncOffset(t); return !(r < 0) && (r && o.b.warn(`MPEG2-TS detected but first sync word found @ offset ${r}, junk ahead ?`), !0); }, e._syncOffset = function(e) { for (let t = Math.min(1e3, e.length - 564), r = 0; r < t;) { if (e[r] === 71 && e[r + 188] === 71 && e[r + 376] === 71) return r; r++; } return -1; }, e.createTrack = function(e, t) { return { container: e === 'video' || e === 'audio' ? 'video/mp2t' : void 0, type: e, id: A[e], pid: -1, inputTimeScale: 9e4, sequenceNumber: 0, samples: [], dropped: e === 'video' ? 0 : void 0, isAAC: e === 'audio' || void 0, duration: e === 'audio' ? t : void 0 }; }, t.resetInitSegment = function(t, r, i, a) { this.pmtParsed = !1, this._pmtId = -1, this._avcTrack = e.createTrack('video', a), this._audioTrack = e.createTrack('audio', a), this._id3Track = e.createTrack('id3', a), this._txtTrack = e.createTrack('text', a), this.aacOverFlow = null, this.aacLastPTS = null, this.avcSample = null, this.audioCodec = r, this.videoCodec = i, this._duration = a; }, t.resetTimeStamp = function() {}, t.append = function(t, r, n, s) { let l; let u; let d; let c; let h; let f = t.length; let g = !1; this.contiguous = n; let p = this.pmtParsed; const v = this._avcTrack; const m = this._audioTrack; const y = this._id3Track; let b = v.pid; let T = m.pid; let E = y.pid; let S = this._pmtId; let _ = v.pesData; let A = m.pesData; let R = y.pesData; const w = this._parsePAT; const k = this._parsePMT; const L = this._parsePES; const D = this._parseAVCPES.bind(this); const C = this._parseAACPES.bind(this); const I = this._parseMPEGPES.bind(this); const O = this._parseID3PES.bind(this); const x = e._syncOffset(t); for (f -= (f + x) % 188, l = x; l < f; l += 188) if (t[l] === 71) { if (u = !!(64 & t[l + 1]), d = ((31 & t[l + 1]) << 8) + t[l + 2], (48 & t[l + 3]) >> 4 > 1) { if ((c = l + 5 + t[l + 4]) === l + 188) continue; } else c = l + 4; switch (d) { case b: u && (_ && (h = L(_)) && D(h, !1), _ = { data: [], size: 0 }), _ && (_.data.push(t.subarray(c, l + 188)), _.size += l + 188 - c); break; case T: u && (A && (h = L(A)) && (m.isAAC ? C(h) : I(h)), A = { data: [], size: 0 }), A && (A.data.push(t.subarray(c, l + 188)), A.size += l + 188 - c); break; case E: u && (R && (h = L(R)) && O(h), R = { data: [], size: 0 }), R && (R.data.push(t.subarray(c, l + 188)), R.size += l + 188 - c); break; case 0: u && (c += t[c] + 1), S = this._pmtId = w(t, c); break; case S: u && (c += t[c] + 1); var P = k(t, c, !0 === this.typeSupported.mpeg || !0 === this.typeSupported.mp3, this.sampleAes != null); (b = P.avc) > 0 && (v.pid = b), (T = P.audio) > 0 && (m.pid = T, m.isAAC = P.isAAC), (E = P.id3) > 0 && (y.pid = E), g && !p && (o.b.log('reparse from beginning'), g = !1, l = x - 188), p = this.pmtParsed = !0; break; case 17: case 8191: break; default: g = !0; } } else this.observer.trigger(i.a.ERROR, { type: a.b.MEDIA_ERROR, details: a.a.FRAG_PARSING_ERROR, fatal: !1, reason: 'TS packet did not start with 0x47' }); _ && (h = L(_)) ? (D(h, !0), v.pesData = null) : v.pesData = _, A && (h = L(A)) ? (m.isAAC ? C(h) : I(h), m.pesData = null) : (A && A.size && o.b.log('last AAC PES packet truncated,might overlap between fragments'), m.pesData = A), R && (h = L(R)) ? (O(h), y.pesData = null) : y.pesData = R, this.sampleAes == null ? this.remuxer.remux(m, v, y, this._txtTrack, r, n, s) : this.decryptAndRemux(m, v, y, this._txtTrack, r, n, s); }, t.decryptAndRemux = function(e, t, r, i, a, n, s) { if (e.samples && e.isAAC) { const o = this; this.sampleAes.decryptAacSamples(e.samples, 0, (() => { o.decryptAndRemuxAvc(e, t, r, i, a, n, s); })); } else this.decryptAndRemuxAvc(e, t, r, i, a, n, s); }, t.decryptAndRemuxAvc = function(e, t, r, i, a, n, s) { if (t.samples) { const o = this; this.sampleAes.decryptAvcSamples(t.samples, 0, 0, (() => { o.remuxer.remux(e, t, r, i, a, n, s); })); } else this.remuxer.remux(e, t, r, i, a, n, s); }, t.destroy = function() { this._initPTS = this._initDTS = void 0, this._duration = 0; }, t._parsePAT = function(e, t) { return (31 & e[t + 10]) << 8 | e[t + 11]; }, t._parsePMT = function(e, t, r, i) { let a; let n; const s = { audio: -1, avc: -1, id3: -1, isAAC: !0 }; for (a = t + 3 + ((15 & e[t + 1]) << 8 | e[t + 2]) - 4, t += 12 + ((15 & e[t + 10]) << 8 | e[t + 11]); t < a;) { switch (n = (31 & e[t + 1]) << 8 | e[t + 2], e[t]) { case 207: if (!i) { o.b.log(`unknown stream type:${e[t]}`); break; } case 15: s.audio === -1 && (s.audio = n); break; case 21: s.id3 === -1 && (s.id3 = n); break; case 219: if (!i) { o.b.log(`unknown stream type:${e[t]}`); break; } case 27: s.avc === -1 && (s.avc = n); break; case 3: case 4: r ? s.audio === -1 && (s.audio = n, s.isAAC = !1) : o.b.log('MPEG audio found, not supported in this browser for now'); break; case 36: o.b.warn('HEVC stream type found, not supported for now'); break; default: o.b.log(`unknown stream type:${e[t]}`); }t += 5 + ((15 & e[t + 3]) << 8 | e[t + 4]); } return s; }, t._parsePES = function(e) { let t; let r; let i; let a; let n; let s; let l; let u; let d = 0; const c = e.data; if (!e || e.size === 0) return null; for (;c[0].length < 19 && c.length > 1;) { const h = new Uint8Array(c[0].length + c[1].length); h.set(c[0]), h.set(c[1], c[0].length), c[0] = h, c.splice(1, 1); } if (((t = c[0])[0] << 16) + (t[1] << 8) + t[2] === 1) { if ((i = (t[4] << 8) + t[5]) && i > e.size - 6) return null; if (192 & (r = t[7]) && ((s = 536870912 * (14 & t[9]) + 4194304 * (255 & t[10]) + 16384 * (254 & t[11]) + 128 * (255 & t[12]) + (254 & t[13]) / 2) > 4294967295 && (s -= 8589934592), 64 & r ? ((l = 536870912 * (14 & t[14]) + 4194304 * (255 & t[15]) + 16384 * (254 & t[16]) + 128 * (255 & t[17]) + (254 & t[18]) / 2) > 4294967295 && (l -= 8589934592), s - l > 54e5 && (o.b.warn(`${Math.round((s - l) / 9e4)}s delta between PTS and DTS, align them`), s = l)) : l = s), u = (a = t[8]) + 9, e.size <= u) return null; e.size -= u, n = new Uint8Array(e.size); for (let f = 0, g = c.length; f < g; f++) { let p = (t = c[f]).byteLength; if (u) { if (u > p) { u -= p; continue; }t = t.subarray(u), p -= u, u = 0; }n.set(t, d), d += p; } return i && (i -= a + 3), { data: n, pts: s, dts: l, len: i }; } return null; }, t.pushAccesUnit = function(e, t) { if (e.units.length && e.frame) { const r = t.samples; const i = r.length; if (isNaN(e.pts)) { if (!i) return void t.dropped++; const a = r[i - 1]; e.pts = a.pts, e.dts = a.dts; }!this.config.forceKeyFrameOnDiscontinuity || !0 === e.key || t.sps && (i || this.contiguous) ? (e.id = i, r.push(e)) : t.dropped++; }e.debug.length && o.b.log(`${e.pts}/${e.dts}:${e.debug}`); }, t._parseAVCPES = function(e, t) { let r; let i; let a; const n = this; const s = this._avcTrack; const o = this._parseAVCNALu(e.data); let l = this.avcSample; let u = !1; const d = this.pushAccesUnit.bind(this); const c = function(e, t, r, i) { return { key: e, pts: t, dts: r, units: [], debug: i }; }; e.data = null, l && o.length && !s.audFound && (d(l, s), l = this.avcSample = c(!1, e.pts, e.dts, '')), o.forEach(((t) => { switch (t.type) { case 1: i = !0, l || (l = n.avcSample = c(!0, e.pts, e.dts, '')), l.frame = !0; var o = t.data; if (u && o.length > 4) { const h = new S(o).readSliceType(); h !== 2 && h !== 4 && h !== 7 && h !== 9 || (l.key = !0); } break; case 5: i = !0, l || (l = n.avcSample = c(!0, e.pts, e.dts, '')), l.key = !0, l.frame = !0; break; case 6: i = !0, (r = new S(n.discardEPB(t.data))).readUByte(); for (let f = 0, g = 0, p = !1, v = 0; !p && r.bytesAvailable > 1;) { f = 0; do { f += v = r.readUByte(); } while (v === 255);g = 0; do { g += v = r.readUByte(); } while (v === 255);if (f === 4 && r.bytesAvailable !== 0) { if (p = !0, r.readUByte() === 181) if (r.readUShort() === 49) if (r.readUInt() === 1195456820) if (r.readUByte() === 3) { const y = r.readUByte(); const b = 31 & y; const T = [y, r.readUByte()]; for (a = 0; a < b; a++)T.push(r.readUByte()), T.push(r.readUByte()), T.push(r.readUByte()); n._insertSampleInOrder(n._txtTrack.samples, { type: 3, pts: e.pts, bytes: T }); } } else if (f === 5 && r.bytesAvailable !== 0) { if (p = !0, g > 16) { const E = []; for (a = 0; a < 16; a++)E.push(r.readUByte().toString(16)), a !== 3 && a !== 5 && a !== 7 && a !== 9 || E.push('-'); const _ = g - 16; const A = new Uint8Array(_); for (a = 0; a < _; a++)A[a] = r.readUByte(); n._insertSampleInOrder(n._txtTrack.samples, { pts: e.pts, payloadType: f, uuid: E.join(''), userDataBytes: A, userData: Object(m.b)(A.buffer) }); } } else if (g < r.bytesAvailable) for (a = 0; a < g; a++)r.readUByte(); } break; case 7: if (i = !0, u = !0, !s.sps) { const R = (r = new S(t.data)).readSPS(); s.width = R.width, s.height = R.height, s.pixelRatio = R.pixelRatio, s.sps = [t.data], s.duration = n._duration; const w = t.data.subarray(1, 4); let k = 'avc1.'; for (a = 0; a < 3; a++) { let L = w[a].toString(16); L.length < 2 && (L = `0${L}`), k += L; }s.codec = k; } break; case 8: i = !0, s.pps || (s.pps = [t.data]); break; case 9: i = !1, s.audFound = !0, l && d(l, s), l = n.avcSample = c(!1, e.pts, e.dts, ''); break; case 12: i = !1; break; default: i = !1, l && (l.debug += `unknown NAL ${t.type} `); }l && i && l.units.push(t); })), t && l && (d(l, s), this.avcSample = null); }, t._insertSampleInOrder = function(e, t) { const r = e.length; if (r > 0) { if (t.pts >= e[r - 1].pts)e.push(t); else for (let i = r - 1; i >= 0; i--) if (t.pts < e[i].pts) { e.splice(i, 0, t); break; } } else e.push(t); }, t._getLastNalUnit = function() { let e; let t = this.avcSample; if (!t || t.units.length === 0) { const r = this._avcTrack.samples; t = r[r.length - 1]; } if (t) { const i = t.units; e = i[i.length - 1]; } return e; }, t._parseAVCNALu = function(e) { let t; let r; let i; let a; let n = 0; const s = e.byteLength; const o = this._avcTrack; let l = o.naluState || 0; const u = l; const d = []; let c = -1; for (l === -1 && (c = 0, a = 31 & e[0], l = 0, n = 1); n < s;) if (t = e[n++], l) if (l !== 1) if (t) if (t === 1) { if (c >= 0)i = { data: e.subarray(c, n - l - 1), type: a }, d.push(i); else { const h = this._getLastNalUnit(); if (h && (u && n <= 4 - u && h.state && (h.data = h.data.subarray(0, h.data.byteLength - u)), (r = n - l - 1) > 0)) { const f = new Uint8Array(h.data.byteLength + r); f.set(h.data, 0), f.set(e.subarray(0, r), h.data.byteLength), h.data = f; } }n < s ? (c = n, a = 31 & e[n], l = 0) : l = -1; } else l = 0; else l = 3; else l = t ? 0 : 2; else l = t ? 0 : 1; if (c >= 0 && l >= 0 && (i = { data: e.subarray(c, s), type: a, state: l }, d.push(i)), d.length === 0) { const g = this._getLastNalUnit(); if (g) { const p = new Uint8Array(g.data.byteLength + e.byteLength); p.set(g.data, 0), p.set(e, g.data.byteLength), g.data = p; } } return o.naluState = l, d; }, t.discardEPB = function(e) { for (var t, r, i = e.byteLength, a = [], n = 1; n < i - 2;)e[n] === 0 && e[n + 1] === 0 && e[n + 2] === 3 ? (a.push(n + 2), n += 2) : n++; if (a.length === 0) return e; t = i - a.length, r = new Uint8Array(t); let s = 0; for (n = 0; n < t; s++, n++)s === a[0] && (s++, a.shift()), r[n] = e[s]; return r; }, t._parseAACPES = function(e) { let t; let r; let n; let s; let l; let u; let d; const c = this._audioTrack; let f = e.data; let m = e.pts; let y = this.aacOverFlow; const b = this.aacLastPTS; if (y) { const T = new Uint8Array(y.byteLength + f.byteLength); T.set(y, 0), T.set(f, y.byteLength), f = T; } for (n = 0, l = f.length; n < l - 1 && !h(f, n); n++);if (n && (n < l - 1 ? (u = `AAC PES did not start with ADTS header,offset:${n}`, d = !1) : (u = 'no ADTS header found in AAC PES', d = !0), o.b.warn(`parsing error:${u}`), this.observer.trigger(i.a.ERROR, { type: a.b.MEDIA_ERROR, details: a.a.FRAG_PARSING_ERROR, fatal: d, reason: u }), d)) return; if (g(c, this.observer, f, n, this.audioCodec), r = 0, t = p(c.samplerate), y && b) { const E = b + t; Math.abs(E - m) > 1 && (o.b.log(`AAC: align PTS for overlapping frames by ${Math.round((E - m) / 90)}`), m = E); } for (;n < l;) { if (h(f, n)) { if (n + 5 < l) { const S = v(c, f, n, m, r); if (S) { n += S.length, s = S.sample.pts, r++; continue; } } break; }n++; }y = n < l ? f.subarray(n, l) : null, this.aacOverFlow = y, this.aacLastPTS = s; }, t._parseMPEGPES = function(e) { for (let t = e.data, r = t.length, i = 0, a = 0, n = e.pts; a < r;) if (E.isHeader(t, a)) { const s = E.appendFrame(this._audioTrack, t, a, n, i); if (!s) break; a += s.length, i++; } else a++; }, t._parseID3PES = function(e) { this._id3Track.samples.push(e); }, e; }()); const w = (function() { function e(e, t, r) { this.observer = e, this.config = r, this.remuxer = t; } const t = e.prototype; return t.resetInitSegment = function(e, t, r, i) { this._audioTrack = { container: 'audio/mpeg', type: 'audio', id: -1, sequenceNumber: 0, isAAC: !1, samples: [], len: 0, manifestCodec: t, duration: i, inputTimeScale: 9e4 }; }, t.resetTimeStamp = function() {}, e.probe = function(e) { let t; let r; const i = m.a.getID3Data(e, 0); if (i && void 0 !== m.a.getTimeStamp(i)) for (t = i.length, r = Math.min(e.length - 1, t + 100); t < r; t++) if (E.probe(e, t)) return o.b.log('MPEG Audio sync word found !'), !0; return !1; }, t.append = function(e, t, r, i) { for (var a = m.a.getID3Data(e, 0), n = m.a.getTimeStamp(a), s = n ? 90 * n : 9e4 * t, o = a.length, l = e.length, u = 0, d = 0, c = this._audioTrack, h = [{ pts: s, dts: s, data: a }]; o < l;) if (E.isHeader(e, o)) { const f = E.appendFrame(c, e, o, s, u); if (!f) break; o += f.length, d = f.sample.pts, u++; } else m.a.isHeader(e, o) ? (a = m.a.getID3Data(e, o), h.push({ pts: d, dts: d, data: a }), o += a.length) : o++; this.remuxer.remux(c, { samples: [] }, { samples: h, inputTimeScale: 9e4 }, { samples: [] }, t, r, i); }, t.destroy = function() {}, e; }()); const k = (function() { function e() {} return e.getSilentFrame = function(e, t) { switch (e) { case 'mp4a.40.2': if (t === 1) return new Uint8Array([0, 200, 0, 128, 35, 128]); if (t === 2) return new Uint8Array([33, 0, 73, 144, 2, 25, 0, 35, 128]); if (t === 3) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 142]); if (t === 4) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 128, 44, 128, 8, 2, 56]); if (t === 5) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 56]); if (t === 6) return new Uint8Array([0, 200, 0, 128, 32, 132, 1, 38, 64, 8, 100, 0, 130, 48, 4, 153, 0, 33, 144, 2, 0, 178, 0, 32, 8, 224]); break; default: if (t === 1) return new Uint8Array([1, 64, 34, 128, 163, 78, 230, 128, 186, 8, 0, 0, 0, 28, 6, 241, 193, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]); if (t === 2) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]); if (t === 3) return new Uint8Array([1, 64, 34, 128, 163, 94, 230, 128, 186, 8, 0, 0, 0, 0, 149, 0, 6, 241, 161, 10, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 94]); } return null; }, e; }()); const L = Math.pow(2, 32) - 1; const D = (function() { function e() {} return e.init = function() { let t; for (t in e.types = { avc1: [], avcC: [], btrt: [], dinf: [], dref: [], esds: [], ftyp: [], hdlr: [], mdat: [], mdhd: [], mdia: [], mfhd: [], minf: [], moof: [], moov: [], mp4a: [], '.mp3': [], mvex: [], mvhd: [], pasp: [], sdtp: [], stbl: [], stco: [], stsc: [], stsd: [], stsz: [], stts: [], tfdt: [], tfhd: [], traf: [], trak: [], trun: [], trex: [], tkhd: [], vmhd: [], smhd: [] }, e.types)e.types.hasOwnProperty(t) && (e.types[t] = [t.charCodeAt(0), t.charCodeAt(1), t.charCodeAt(2), t.charCodeAt(3)]); const r = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 118, 105, 100, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 86, 105, 100, 101, 111, 72, 97, 110, 100, 108, 101, 114, 0]); const i = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 115, 111, 117, 110, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 83, 111, 117, 110, 100, 72, 97, 110, 100, 108, 101, 114, 0]); e.HDLR_TYPES = { video: r, audio: i }; const a = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 12, 117, 114, 108, 32, 0, 0, 0, 1]); const n = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]); e.STTS = e.STSC = e.STCO = n, e.STSZ = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), e.VMHD = new Uint8Array([0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]), e.SMHD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]), e.STSD = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1]); const s = new Uint8Array([105, 115, 111, 109]); const o = new Uint8Array([97, 118, 99, 49]); const l = new Uint8Array([0, 0, 0, 1]); e.FTYP = e.box(e.types.ftyp, s, l, s, o), e.DINF = e.box(e.types.dinf, e.box(e.types.dref, a)); }, e.box = function(e) { for (var t, r = Array.prototype.slice.call(arguments, 1), i = 8, a = r.length, n = a; a--;)i += r[a].byteLength; for ((t = new Uint8Array(i))[0] = i >> 24 & 255, t[1] = i >> 16 & 255, t[2] = i >> 8 & 255, t[3] = 255 & i, t.set(e, 4), a = 0, i = 8; a < n; a++)t.set(r[a], i), i += r[a].byteLength; return t; }, e.hdlr = function(t) { return e.box(e.types.hdlr, e.HDLR_TYPES[t]); }, e.mdat = function(t) { return e.box(e.types.mdat, t); }, e.mdhd = function(t, r) { r *= t; const i = Math.floor(r / (L + 1)); const a = Math.floor(r % (L + 1)); return e.box(e.types.mdhd, new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, 85, 196, 0, 0])); }, e.mdia = function(t) { return e.box(e.types.mdia, e.mdhd(t.timescale, t.duration), e.hdlr(t.type), e.minf(t)); }, e.mfhd = function(t) { return e.box(e.types.mfhd, new Uint8Array([0, 0, 0, 0, t >> 24, t >> 16 & 255, t >> 8 & 255, 255 & t])); }, e.minf = function(t) { return t.type === 'audio' ? e.box(e.types.minf, e.box(e.types.smhd, e.SMHD), e.DINF, e.stbl(t)) : e.box(e.types.minf, e.box(e.types.vmhd, e.VMHD), e.DINF, e.stbl(t)); }, e.moof = function(t, r, i) { return e.box(e.types.moof, e.mfhd(t), e.traf(i, r)); }, e.moov = function(t) { for (var r = t.length, i = []; r--;)i[r] = e.trak(t[r]); return e.box.apply(null, [e.types.moov, e.mvhd(t[0].timescale, t[0].duration)].concat(i).concat(e.mvex(t))); }, e.mvex = function(t) { for (var r = t.length, i = []; r--;)i[r] = e.trex(t[r]); return e.box.apply(null, [e.types.mvex].concat(i)); }, e.mvhd = function(t, r) { r *= t; const i = Math.floor(r / (L + 1)); const a = Math.floor(r % (L + 1)); const n = new Uint8Array([1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, t >> 24 & 255, t >> 16 & 255, t >> 8 & 255, 255 & t, i >> 24, i >> 16 & 255, i >> 8 & 255, 255 & i, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255, 255, 255]); return e.box(e.types.mvhd, n); }, e.sdtp = function(t) { let r; let i; const a = t.samples || []; const n = new Uint8Array(4 + a.length); for (i = 0; i < a.length; i++)r = a[i].flags, n[i + 4] = r.dependsOn << 4 | r.isDependedOn << 2 | r.hasRedundancy; return e.box(e.types.sdtp, n); }, e.stbl = function(t) { return e.box(e.types.stbl, e.stsd(t), e.box(e.types.stts, e.STTS), e.box(e.types.stsc, e.STSC), e.box(e.types.stsz, e.STSZ), e.box(e.types.stco, e.STCO)); }, e.avc1 = function(t) { let r; let i; let a; let n = []; let s = []; for (r = 0; r < t.sps.length; r++)a = (i = t.sps[r]).byteLength, n.push(a >>> 8 & 255), n.push(255 & a), n = n.concat(Array.prototype.slice.call(i)); for (r = 0; r < t.pps.length; r++)a = (i = t.pps[r]).byteLength, s.push(a >>> 8 & 255), s.push(255 & a), s = s.concat(Array.prototype.slice.call(i)); const o = e.box(e.types.avcC, new Uint8Array([1, n[3], n[4], n[5], 255, 224 | t.sps.length].concat(n).concat([t.pps.length]).concat(s))); const l = t.width; const u = t.height; const d = t.pixelRatio[0]; const c = t.pixelRatio[1]; return e.box(e.types.avc1, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, l >> 8 & 255, 255 & l, u >> 8 & 255, 255 & u, 0, 72, 0, 0, 0, 72, 0, 0, 0, 0, 0, 0, 0, 1, 18, 100, 97, 105, 108, 121, 109, 111, 116, 105, 111, 110, 47, 104, 108, 115, 46, 106, 115, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 17, 17]), o, e.box(e.types.btrt, new Uint8Array([0, 28, 156, 128, 0, 45, 198, 192, 0, 45, 198, 192])), e.box(e.types.pasp, new Uint8Array([d >> 24, d >> 16 & 255, d >> 8 & 255, 255 & d, c >> 24, c >> 16 & 255, c >> 8 & 255, 255 & c]))); }, e.esds = function(e) { const t = e.config.length; return new Uint8Array([0, 0, 0, 0, 3, 23 + t, 0, 1, 0, 4, 15 + t, 64, 21, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5].concat([t]).concat(e.config).concat([6, 1, 2])); }, e.mp4a = function(t) { const r = t.samplerate; return e.box(e.types.mp4a, new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0]), e.box(e.types.esds, e.esds(t))); }, e.mp3 = function(t) { const r = t.samplerate; return e.box(e.types['.mp3'], new Uint8Array([0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, t.channelCount, 0, 16, 0, 0, 0, 0, r >> 8 & 255, 255 & r, 0, 0])); }, e.stsd = function(t) { return t.type === 'audio' ? t.isAAC || t.codec !== 'mp3' ? e.box(e.types.stsd, e.STSD, e.mp4a(t)) : e.box(e.types.stsd, e.STSD, e.mp3(t)) : e.box(e.types.stsd, e.STSD, e.avc1(t)); }, e.tkhd = function(t) { const r = t.id; const i = t.duration * t.timescale; const a = t.width; const n = t.height; const s = Math.floor(i / (L + 1)); const o = Math.floor(i % (L + 1)); return e.box(e.types.tkhd, new Uint8Array([1, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 3, r >> 24 & 255, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 0, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s, o >> 24, o >> 16 & 255, o >> 8 & 255, 255 & o, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, a >> 8 & 255, 255 & a, 0, 0, n >> 8 & 255, 255 & n, 0, 0])); }, e.traf = function(t, r) { const i = e.sdtp(t); const a = t.id; const n = Math.floor(r / (L + 1)); const s = Math.floor(r % (L + 1)); return e.box(e.types.traf, e.box(e.types.tfhd, new Uint8Array([0, 0, 0, 0, a >> 24, a >> 16 & 255, a >> 8 & 255, 255 & a])), e.box(e.types.tfdt, new Uint8Array([1, 0, 0, 0, n >> 24, n >> 16 & 255, n >> 8 & 255, 255 & n, s >> 24, s >> 16 & 255, s >> 8 & 255, 255 & s])), e.trun(t, i.length + 16 + 20 + 8 + 16 + 8 + 8), i); }, e.trak = function(t) { return t.duration = t.duration || 4294967295, e.box(e.types.trak, e.tkhd(t), e.mdia(t)); }, e.trex = function(t) { const r = t.id; return e.box(e.types.trex, new Uint8Array([0, 0, 0, 0, r >> 24, r >> 16 & 255, r >> 8 & 255, 255 & r, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1])); }, e.trun = function(t, r) { let i; let a; let n; let s; let o; let l; const u = t.samples || []; const d = u.length; const c = 12 + 16 * d; const h = new Uint8Array(c); for (r += 8 + c, h.set([0, 0, 15, 1, d >>> 24 & 255, d >>> 16 & 255, d >>> 8 & 255, 255 & d, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, 255 & r], 0), i = 0; i < d; i++)n = (a = u[i]).duration, s = a.size, o = a.flags, l = a.cts, h.set([n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, 255 & n, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, 255 & s, o.isLeading << 2 | o.dependsOn, o.isDependedOn << 6 | o.hasRedundancy << 4 | o.paddingValue << 1 | o.isNonSync, 61440 & o.degradPrio, 15 & o.degradPrio, l >>> 24 & 255, l >>> 16 & 255, l >>> 8 & 255, 255 & l], 12 + 16 * i); return e.box(e.types.trun, h); }, e.initSegment = function(t) { e.types || e.init(); let r; const i = e.moov(t); return (r = new Uint8Array(e.FTYP.byteLength + i.byteLength)).set(e.FTYP), r.set(i, e.FTYP.byteLength), r; }, e; }()); function C(e, t, r, i) { void 0 === r && (r = 1), void 0 === i && (i = !1); const a = e * t * r; return i ? Math.round(a) : a; } function I(e, t) { return void 0 === t && (t = !1), C(e, 1e3, 1 / 9e4, t); } function O(e, t) { return void 0 === t && (t = 1), C(e, 9e4, 1 / t); } let x; const P = O(10); const M = O(0.2); const F = (function() { function e(e, t, r, i) { this.observer = e, this.config = t, this.typeSupported = r; const a = navigator.userAgent; this.isSafari = i && i.indexOf('Apple') > -1 && a && !a.match('CriOS'), this.ISGenerated = !1; } const t = e.prototype; return t.destroy = function() {}, t.resetTimeStamp = function(e) { this._initPTS = this._initDTS = e; }, t.resetInitSegment = function() { this.ISGenerated = !1; }, t.remux = function(e, t, r, a, n, s, l) { if (this.ISGenerated || this.generateIS(e, t, n), this.ISGenerated) { const u = e.samples.length; const d = t.samples.length; let c = n; let h = n; if (u && d) { const f = (e.samples[0].pts - t.samples[0].pts) / t.inputTimeScale; c += Math.max(0, f), h += Math.max(0, -f); } if (u) { e.timescale || (o.b.warn('regenerate InitSegment as audio detected'), this.generateIS(e, t, n)); let g; const p = this.remuxAudio(e, c, s, l); if (d)p && (g = p.endPTS - p.startPTS), t.timescale || (o.b.warn('regenerate InitSegment as video detected'), this.generateIS(e, t, n)), this.remuxVideo(t, h, s, g, l); } else if (d) { const v = this.remuxVideo(t, h, s, 0, l); v && e.codec && this.remuxEmptyAudio(e, c, s, v); } }r.samples.length && this.remuxID3(r, n), a.samples.length && this.remuxText(a, n), this.observer.trigger(i.a.FRAG_PARSED); }, t.generateIS = function(e, t, r) { let n; let s; const l = this.observer; const u = e.samples; const d = t.samples; const c = this.typeSupported; let h = 'audio/mp4'; const f = {}; const g = { tracks: f }; const p = void 0 === this._initPTS; if (p && (n = s = 1 / 0), e.config && u.length && (e.timescale = e.samplerate, o.b.log(`audio sampling rate : ${e.samplerate}`), e.isAAC || (c.mpeg ? (h = 'audio/mpeg', e.codec = '') : c.mp3 && (e.codec = 'mp3')), f.audio = { container: h, codec: e.codec, initSegment: !e.isAAC && c.mpeg ? new Uint8Array() : D.initSegment([e]), metadata: { channelCount: e.channelCount } }, p && (n = s = u[0].pts - e.inputTimeScale * r)), t.sps && t.pps && d.length) { const v = t.inputTimeScale; t.timescale = v, f.video = { container: 'video/mp4', codec: t.codec, initSegment: D.initSegment([t]), metadata: { width: t.width, height: t.height } }, p && (n = Math.min(n, d[0].pts - v * r), s = Math.min(s, d[0].dts - v * r), this.observer.trigger(i.a.INIT_PTS_FOUND, { initPTS: n })); }Object.keys(f).length ? (l.trigger(i.a.FRAG_PARSING_INIT_SEGMENT, g), this.ISGenerated = !0, p && (this._initPTS = n, this._initDTS = s)) : l.trigger(i.a.ERROR, { type: a.b.MEDIA_ERROR, details: a.a.FRAG_PARSING_ERROR, fatal: !1, reason: 'no audio/video samples found' }); }, t.remuxVideo = function(e, t, r, n, s) { let l; let u; let d; let c; let h; let f; let g; let p = 8; const v = e.timescale; const m = e.samples; const y = []; const b = m.length; const T = this._PTSNormalize; const E = this._initPTS; let S = this.nextAvcDts; const _ = this.isSafari; if (b !== 0) { _ && (r |= m.length && S && (s && Math.abs(t - S / v) < 0.1 || Math.abs(m[0].pts - S - E) < v / 5)), r || (S = t * v), m.forEach(((e) => { e.pts = T(e.pts - E, S), e.dts = T(e.dts - E, S); })), m.sort(((e, t) => { const r = e.dts - t.dts; const i = e.pts - t.pts; return r || i || e.id - t.id; })); const A = m.reduce(((e, t) => Math.max(Math.min(e, t.pts - t.dts), -1 * M)), 0); if (A < 0) { o.b.warn(`PTS < DTS detected in video samples, shifting DTS by ${I(A, !0)} ms to overcome this issue`); for (let R = 0; R < m.length; R++)m[R].dts += A; } let w = m[0]; h = Math.max(w.dts, 0), c = Math.max(w.pts, 0); const k = h - S; r && k && (k > 1 ? o.b.log(`AVC: ${I(k, !0)} ms hole between fragments detected,filling it`) : k < -1 && o.b.log(`AVC: ${I(-k, !0)} ms overlapping between fragments detected`), h = S, m[0].dts = h, c = Math.max(c - k, S), m[0].pts = c, o.b.log(`Video: PTS/DTS adjusted: ${I(c, !0)}/${I(h, !0)}, delta: ${I(k, !0)} ms`)), w = m[m.length - 1], g = Math.max(w.dts, 0), f = Math.max(w.pts, 0, g), _ && (l = Math.round((g - h) / (m.length - 1))); for (var L = 0, C = 0, O = 0; O < b; O++) { for (var x = m[O], P = x.units, F = P.length, U = 0, N = 0; N < F; N++)U += P[N].data.length; C += U, L += F, x.length = U, x.dts = _ ? h + O * l : Math.max(x.dts, h), x.pts = Math.max(x.pts, x.dts); } const B = C + 4 * L + 8; try { u = new Uint8Array(B); } catch (e) { return void this.observer.trigger(i.a.ERROR, { type: a.b.MUX_ERROR, details: a.a.REMUX_ALLOC_ERROR, fatal: !1, bytes: B, reason: `fail allocating video mdat ${B}` }); } const G = new DataView(u.buffer); G.setUint32(0, B), u.set(D.types.mdat, 4); for (let K = 0; K < b; K++) { for (var j = m[K], H = j.units, V = 0, Y = void 0, W = 0, q = H.length; W < q; W++) { const z = H[W]; const X = z.data; const Q = z.data.byteLength; G.setUint32(p, Q), p += 4, u.set(X, p), p += Q, V += 4 + Q; } if (_)Y = Math.max(0, l * Math.round((j.pts - j.dts) / l)); else { if (K < b - 1)l = m[K + 1].dts - j.dts; else { const $ = this.config; const J = j.dts - m[K > 0 ? K - 1 : K].dts; if ($.stretchShortVideoTrack) { const Z = $.maxBufferHole; const ee = Math.floor(Z * v); const te = (n ? c + n * v : this.nextAudioPts) - j.pts; te > ee ? ((l = te - J) < 0 && (l = J), o.b.log(`It is approximately ${I(te, !1)} ms to the next segment; using duration ${I(l, !1)} ms for the last video frame.`)) : l = J; } else l = J; }Y = Math.round(j.pts - j.dts); }y.push({ size: V, duration: l, cts: Y, flags: { isLeading: 0, isDependedOn: 0, hasRedundancy: 0, degradPrio: 0, dependsOn: j.key ? 2 : 1, isNonSync: j.key ? 0 : 1 } }); } this.nextAvcDts = g + l; const re = e.dropped; if (e.nbNalu = 0, e.dropped = 0, y.length && navigator.userAgent.toLowerCase().indexOf('chrome') > -1) { const ie = y[0].flags; ie.dependsOn = 2, ie.isNonSync = 0; }e.samples = y, d = D.moof(e.sequenceNumber++, h, e), e.samples = []; const ae = { data1: d, data2: u, startPTS: c / v, endPTS: (f + l) / v, startDTS: h / v, endDTS: this.nextAvcDts / v, type: 'video', hasAudio: !1, hasVideo: !0, nb: y.length, dropped: re }; return this.observer.trigger(i.a.FRAG_PARSING_DATA, ae), ae; } }, t.remuxAudio = function(e, t, r, n) { let s; let l; let u; let d; let c; let h; const f = e.inputTimeScale; const g = e.timescale; const p = f / g; const v = (e.isAAC ? 1024 : 1152) * p; const m = this._PTSNormalize; const y = this._initPTS; const b = !e.isAAC && this.typeSupported.mpeg; let T = b ? 0 : 8; let E = e.samples; const S = []; let _ = this.nextAudioPts; if (r |= E.length && _ && (n && Math.abs(t - _ / f) < 0.1 || Math.abs(E[0].pts - _ - y) < 20 * v), E.forEach(((e) => { e.pts = e.dts = m(e.pts - y, t * f); })), (E = E.filter(((e) => e.pts >= 0))).length !== 0) { if (r || (_ = n ? t * f : E[0].pts), e.isAAC) for (let A = this.config.maxAudioFramesDrift, R = 0, w = _; R < E.length;) { var L; const C = E[R]; if ((L = C.pts - w) <= -A * v)o.b.warn(`Dropping 1 audio frame @ ${I(w, !0)} ms due to ${I(L, !0)} ms overlap.`), E.splice(R, 1); else if (L >= A * v && L < P && w) { const O = Math.round(L / v); o.b.warn(`Injecting ${O} audio frames @ ${I(w, !0)} ms due to ${I(w, !0)} ms gap.`); for (let x = 0; x < O; x++) { const M = Math.max(w, 0); (l = k.getSilentFrame(e.manifestCodec || e.codec, e.channelCount)) || (o.b.log('Unable to get silent frame for given audio codec; duplicating last frame instead.'), l = C.unit.subarray()), E.splice(R, 0, { unit: l, pts: M, dts: M }), w += v, R++; }C.pts = C.dts = w, w += v, R++; } else Math.abs(L), C.pts = C.dts = w, w += v, R++; } for (var F = E.length, U = 0; F--;)U += E[F].unit.byteLength; for (let N = 0, B = E.length; N < B; N++) { const G = E[N]; const K = G.unit; let j = G.pts; if (void 0 !== h)s.duration = Math.round((j - h) / p); else { const H = j - _; let V = 0; if (r && e.isAAC && H) { if (H > 0 && H < P)V = Math.round((j - _) / v), o.b.log(`${I(H, !0)} ms hole between AAC samples detected,filling it`), V > 0 && ((l = k.getSilentFrame(e.manifestCodec || e.codec, e.channelCount)) || (l = K.subarray()), U += V * l.length); else if (H < -12) { o.b.log(`drop overlapping AAC sample, expected/parsed/delta: ${I(_, !0)} ms / ${I(j, !0)} ms / ${I(-H, !0)} ms`), U -= K.byteLength; continue; }j = _; } if (c = j, !(U > 0)) return; U += T; try { u = new Uint8Array(U); } catch (e) { return void this.observer.trigger(i.a.ERROR, { type: a.b.MUX_ERROR, details: a.a.REMUX_ALLOC_ERROR, fatal: !1, bytes: U, reason: `fail allocating audio mdat ${U}` }); }b || (new DataView(u.buffer).setUint32(0, U), u.set(D.types.mdat, 4)); for (let Y = 0; Y < V; Y++)(l = k.getSilentFrame(e.manifestCodec || e.codec, e.channelCount)) || (o.b.log('Unable to get silent frame for given audio codec; duplicating this frame instead.'), l = K.subarray()), u.set(l, T), T += l.byteLength, s = { size: l.byteLength, cts: 0, duration: 1024, flags: { isLeading: 0, isDependedOn: 0, hasRedundancy: 0, degradPrio: 0, dependsOn: 1 } }, S.push(s); }u.set(K, T); const W = K.byteLength; T += W, s = { size: W, cts: 0, duration: 0, flags: { isLeading: 0, isDependedOn: 0, hasRedundancy: 0, degradPrio: 0, dependsOn: 1 } }, S.push(s), h = j; } let q = 0; if ((F = S.length) >= 2 && (q = S[F - 2].duration, s.duration = q), F) { this.nextAudioPts = _ = h + p * q, e.samples = S, d = b ? new Uint8Array() : D.moof(e.sequenceNumber++, c / p, e), e.samples = []; const z = c / f; const X = _ / f; const Q = { data1: d, data2: u, startPTS: z, endPTS: X, startDTS: z, endDTS: X, type: 'audio', hasAudio: !0, hasVideo: !1, nb: F }; return this.observer.trigger(i.a.FRAG_PARSING_DATA, Q), Q; } return null; } }, t.remuxEmptyAudio = function(e, t, r, i) { const a = e.inputTimeScale; const n = a / (e.samplerate ? e.samplerate : a); const s = this.nextAudioPts; const l = (void 0 !== s ? s : i.startDTS * a) + this._initDTS; const u = i.endDTS * a + this._initDTS; const d = 1024 * n; const c = Math.ceil((u - l) / d); const h = k.getSilentFrame(e.manifestCodec || e.codec, e.channelCount); if (o.b.warn('remux empty Audio'), h) { for (var f = [], g = 0; g < c; g++) { const p = l + g * d; f.push({ unit: h, pts: p, dts: p }); }e.samples = f, this.remuxAudio(e, t, r); } else o.b.trace('Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec!'); }, t.remuxID3 = function(e) { let t; const r = e.samples.length; const a = e.inputTimeScale; const n = this._initPTS; const s = this._initDTS; if (r) { for (let o = 0; o < r; o++)(t = e.samples[o]).pts = (t.pts - n) / a, t.dts = (t.dts - s) / a; this.observer.trigger(i.a.FRAG_PARSING_METADATA, { samples: e.samples }); }e.samples = []; }, t.remuxText = function(e) { e.samples.sort(((e, t) => e.pts - t.pts)); let t; const r = e.samples.length; const a = e.inputTimeScale; const n = this._initPTS; if (r) { for (let s = 0; s < r; s++)(t = e.samples[s]).pts = (t.pts - n) / a; this.observer.trigger(i.a.FRAG_PARSING_USERDATA, { samples: e.samples }); }e.samples = []; }, t._PTSNormalize = function(e, t) { let r; if (void 0 === t) return e; for (r = t < e ? -8589934592 : 8589934592; Math.abs(e - t) > 4294967296;)e += r; return e; }, e; }()); const U = (function() { function e(e) { this.observer = e; } const t = e.prototype; return t.destroy = function() {}, t.resetTimeStamp = function() {}, t.resetInitSegment = function() {}, t.remux = function(e, t, r, a, n, s, o, l) { const u = this.observer; let d = ''; e && (d += 'audio'), t && (d += 'video'), u.trigger(i.a.FRAG_PARSING_DATA, { data1: l, startPTS: n, startDTS: n, type: d, hasAudio: !!e, hasVideo: !!t, nb: 1, dropped: 0 }), u.trigger(i.a.FRAG_PARSED); }, e; }()); const N = Object(l.a)(); try { x = N.performance.now.bind(N.performance); } catch (e) { o.b.debug('Unable to use Performance API on this environment'), x = N.Date.now; } const B = (function() { function e(e, t, r, i) { this.observer = e, this.typeSupported = t, this.config = r, this.vendor = i; } const t = e.prototype; return t.destroy = function() { const e = this.demuxer; e && e.destroy(); }, t.push = function(e, t, r, a, s, o, l, u, d, c, h, f) { const g = this; if (e.byteLength > 0 && t != null && t.key != null && t.method === 'AES-128') { let p = this.decrypter; p == null && (p = this.decrypter = new n.a(this.observer, this.config)); const v = x(); p.decrypt(e, t.key.buffer, t.iv.buffer, ((e) => { const n = x(); g.observer.trigger(i.a.FRAG_DECRYPTED, { stats: { tstart: v, tdecrypt: n } }), g.pushDecrypted(new Uint8Array(e), t, new Uint8Array(r), a, s, o, l, u, d, c, h, f); })); } else this.pushDecrypted(new Uint8Array(e), t, new Uint8Array(r), a, s, o, l, u, d, c, h, f); }, t.pushDecrypted = function(e, t, r, n, s, o, l, u, d, c, h, f) { let g = this.demuxer; if (!g || (l || u) && !this.probe(e)) { for (var p = this.observer, v = this.typeSupported, m = this.config, T = [{ demux: R, remux: F }, { demux: b.a, remux: U }, { demux: y, remux: F }, { demux: w, remux: F }], E = 0, S = T.length; E < S; E++) { const _ = T[E]; const A = _.demux.probe; if (A(e)) { const k = this.remuxer = new _.remux(p, m, v, this.vendor); g = new _.demux(p, k, m, v), this.probe = A; break; } } if (!g) return void p.trigger(i.a.ERROR, { type: a.b.MEDIA_ERROR, details: a.a.FRAG_PARSING_ERROR, fatal: !0, reason: 'no demux matching with content found' }); this.demuxer = g; } const L = this.remuxer; (l || u) && (g.resetInitSegment(r, n, s, c), L.resetInitSegment()), l && (g.resetTimeStamp(f), L.resetTimeStamp(f)), typeof g.setDecryptData === 'function' && g.setDecryptData(t), g.append(e, o, d, h); }, e; }()); t.a = B;
}, function(e, t, r) {
const i = r(0); const a = r(1); const n = Math.pow(2, 32) - 1; const s = (function() { function e(e, t) { this.observer = e, this.remuxer = t; } const t = e.prototype; return t.resetTimeStamp = function(e) { this.initPTS = e; }, t.resetInitSegment = function(t, r, i, n) { if (t && t.byteLength) { const s = this.initData = e.parseInitSegment(t); r == null && (r = 'mp4a.40.5'), i == null && (i = 'avc1.42e01e'); const o = {}; s.audio && s.video ? o.audiovideo = { container: 'video/mp4', codec: `${r},${i}`, initSegment: n ? t : null } : (s.audio && (o.audio = { container: 'audio/mp4', codec: r, initSegment: n ? t : null }), s.video && (o.video = { container: 'video/mp4', codec: i, initSegment: n ? t : null })), this.observer.trigger(a.a.FRAG_PARSING_INIT_SEGMENT, { tracks: o }); } else r && (this.audioCodec = r), i && (this.videoCodec = i); }, e.probe = function(t) { return e.findBox({ data: t, start: 0, end: Math.min(t.length, 16384) }, ['moof']).length > 0; }, e.bin2str = function(e) { return String.fromCharCode.apply(null, e); }, e.readUint16 = function(e, t) { e.data && (t += e.start, e = e.data); const r = e[t] << 8 | e[t + 1]; return r < 0 ? 65536 + r : r; }, e.readUint32 = function(e, t) { e.data && (t += e.start, e = e.data); const r = e[t] << 24 | e[t + 1] << 16 | e[t + 2] << 8 | e[t + 3]; return r < 0 ? 4294967296 + r : r; }, e.writeUint32 = function(e, t, r) { e.data && (t += e.start, e = e.data), e[t] = r >> 24, e[t + 1] = r >> 16 & 255, e[t + 2] = r >> 8 & 255, e[t + 3] = 255 & r; }, e.findBox = function(t, r) { let i; let a; let n; let s; let o; let l; let u = []; if (t.data ? (o = t.start, n = t.end, t = t.data) : (o = 0, n = t.byteLength), !r.length) return null; for (i = o; i < n;)l = (a = e.readUint32(t, i)) > 1 ? i + a : n, e.bin2str(t.subarray(i + 4, i + 8)) === r[0] && (r.length === 1 ? u.push({ data: t, start: i + 8, end: l }) : (s = e.findBox({ data: t, start: i + 8, end: l }, r.slice(1))).length && (u = u.concat(s))), i = l; return u; }, e.parseSegmentIndex = function(t) { let r; const i = e.findBox(t, ['moov'])[0]; const a = i ? i.end : null; let n = 0; let s = e.findBox(t, ['sidx']); if (!s || !s[0]) return null; r = []; const o = (s = s[0]).data[0]; n = o === 0 ? 8 : 16; const l = e.readUint32(s, n); n += 4; n += o === 0 ? 8 : 16, n += 2; let u = s.end + 0; const d = e.readUint16(s, n); n += 2; for (let c = 0; c < d; c++) { let h = n; const f = e.readUint32(s, h); h += 4; const g = 2147483647 & f; if ((2147483648 & f) >>> 31 === 1) return void console.warn('SIDX has hierarchical references (not supported)'); const p = e.readUint32(s, h); h += 4, r.push({ referenceSize: g, subsegmentDuration: p, info: { duration: p / l, start: u, end: u + g - 1 } }), u += g, n = h += 4; } return { earliestPresentationTime: 0, timescale: l, version: o, referencesCount: d, references: r, moovEndOffset: a }; }, e.parseInitSegment = function(t) { const r = []; return e.findBox(t, ['moov', 'trak']).forEach(((t) => { const a = e.findBox(t, ['tkhd'])[0]; if (a) { let n = a.data[a.start]; let s = n === 0 ? 12 : 20; const o = e.readUint32(a, s); const l = e.findBox(t, ['mdia', 'mdhd'])[0]; if (l) { s = (n = l.data[l.start]) === 0 ? 12 : 20; const u = e.readUint32(l, s); const d = e.findBox(t, ['mdia', 'hdlr'])[0]; if (d) { const c = { soun: 'audio', vide: 'video' }[e.bin2str(d.data.subarray(d.start + 8, d.start + 12))]; if (c) { let h = e.findBox(t, ['mdia', 'minf', 'stbl', 'stsd']); if (h.length) { h = h[0]; const f = e.bin2str(h.data.subarray(h.start + 12, h.start + 16)); i.b.log(`MP4Demuxer:${c}:${f} found`); }r[o] = { timescale: u, type: c }, r[c] = { timescale: u, id: o }; } } } } })), r; }, e.getStartDTS = function(t, r) { let i; let a; let n; return i = e.findBox(r, ['moof', 'traf']), a = [].concat.apply([], i.map(((r) => e.findBox(r, ['tfhd']).map(((i) => { let a; let n; return a = e.readUint32(i, 4), n = t[a].timescale || 9e4, e.findBox(r, ['tfdt']).map(((t) => { let r; let i; return r = t.data[t.start], i = e.readUint32(t, 4), r === 1 && (i *= Math.pow(2, 32), i += e.readUint32(t, 8)), i; }))[0] / n; }))))), n = Math.min.apply(null, a), isFinite(n) ? n : 0; }, e.offsetStartDTS = function(t, r, i) { e.findBox(r, ['moof', 'traf']).map(((r) => e.findBox(r, ['tfhd']).map(((a) => { const s = e.readUint32(a, 4); const o = t[s].timescale || 9e4; e.findBox(r, ['tfdt']).map(((t) => { const r = t.data[t.start]; let a = e.readUint32(t, 4); if (r === 0)e.writeUint32(t, 4, a - i * o); else { a *= Math.pow(2, 32), a += e.readUint32(t, 8), a -= i * o, a = Math.max(a, 0); const s = Math.floor(a / (n + 1)); const l = Math.floor(a % (n + 1)); e.writeUint32(t, 4, s), e.writeUint32(t, 8, l); } })); })))); }, t.append = function(t, r, i, n) { let s = this.initData; s || (this.resetInitSegment(t, this.audioCodec, this.videoCodec, !1), s = this.initData); let o; let l = this.initPTS; if (void 0 === l) { const u = e.getStartDTS(s, t); this.initPTS = l = u - r, this.observer.trigger(a.a.INIT_PTS_FOUND, { initPTS: l }); }e.offsetStartDTS(s, t, l), o = e.getStartDTS(s, t), this.remuxer.remux(s.audio, s.video, null, null, o, i, n, t); }, t.destroy = function() {}, e; }()); t.a = s;
}, function(e, t, r) { function i(e) { const t = {}; function r(i) { if (t[i]) return t[i].exports; const a = t[i] = { i, l: !1, exports: {} }; return e[i].call(a.exports, a, a.exports, r), a.l = !0, a.exports; }r.m = e, r.c = t, r.i = function(e) { return e; }, r.d = function(e, t, i) { r.o(e, t) || Object.defineProperty(e, t, { configurable: !1, enumerable: !0, get: i }); }, r.r = function(e) { Object.defineProperty(e, '__esModule', { value: !0 }); }, r.n = function(e) { const t = e && e.__esModule ? function() { return e.default; } : function() { return e; }; return r.d(t, 'a', t), t; }, r.o = function(e, t) { return Object.prototype.hasOwnProperty.call(e, t); }, r.p = '/', r.oe = function(e) { throw console.error(e), e; }; const i = r(r.s = ENTRY_MODULE); return i.default || i; } const a = '\\(\\s*(/\\*.*?\\*/)?\\s*.*?([\\.|\\-|\\+|\\w|/|@]+).*?\\)'; function n(e) { return (`${e}`).replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&'); } function s(e, t, i) { const s = {}; s[i] = []; const o = t.toString(); const l = o.match(/^function\s?\w*\(\w+,\s*\w+,\s*(\w+)\)/); if (!l) return s; for (var u, d = l[1], c = new RegExp(`(\\\\n|\\W)${n(d)}${a}`, 'g'); u = c.exec(o);)u[3] !== 'dll-reference' && s[i].push(u[3]); for (c = new RegExp(`\\(${n(d)}\\("(dll-reference\\s([\\.|\\-|\\+|\\w|/|@]+))"\\)\\)${a}`, 'g'); u = c.exec(o);)e[u[2]] || (s[i].push(u[1]), e[u[2]] = r(u[1]).m), s[u[2]] = s[u[2]] || [], s[u[2]].push(u[4]); for (var h, f = Object.keys(s), g = 0; g < f.length; g++) for (let p = 0; p < s[f[g]].length; p++)h = s[f[g]][p], isNaN(1 * h) || (s[f[g]][p] = 1 * s[f[g]][p]); return s; } function o(e) { return Object.keys(e).reduce(((t, r) => t || e[r].length > 0), !1); }e.exports = function(e, t) { t = t || {}; const a = { main: r.m }; const n = t.all ? { main: Object.keys(a.main) } : (function(e, t) { for (var r = { main: [t] }, i = { main: [] }, a = { main: {} }; o(r);) for (let n = Object.keys(r), l = 0; l < n.length; l++) { const u = n[l]; const d = r[u].pop(); if (a[u] = a[u] || {}, !a[u][d] && e[u][d]) { a[u][d] = !0, i[u] = i[u] || [], i[u].push(d); for (let c = s(e, e[u][d], u), h = Object.keys(c), f = 0; f < h.length; f++)r[h[f]] = r[h[f]] || [], r[h[f]] = r[h[f]].concat(c[h[f]]); } } return i; }(a, e)); let l = ''; Object.keys(n).filter(((e) => e !== 'main')).forEach(((e) => { for (var t = 0; n[e][t];)t++; n[e].push(t), a[e][t] = '(function(module, exports, __webpack_require__) { module.exports = __webpack_require__; })', l = `${l}var ${e} = (${i.toString().replace('ENTRY_MODULE', JSON.stringify(t))})({${n[e].map(((t) => `${JSON.stringify(t)}: ${a[e][t].toString()}`)).join(',')}});\n`; })), l = `${l}new ((${i.toString().replace('ENTRY_MODULE', JSON.stringify(e))})({${n.main.map(((e) => `${JSON.stringify(e)}: ${a.main[e].toString()}`)).join(',')}}))(self);`; const u = new window.Blob([l], { type: 'text/javascript' }); if (t.bare) return u; const d = (window.URL || window.webkitURL || window.mozURL || window.msURL).createObjectURL(u); const c = new window.Worker(d); return c.objectURL = d, c; }; }, function(e, t, r) {
/*! MIT License. Copyright 2015-2018 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
!(function(t) {
function r(e) { return parseInt(e) === e; } function i(e) { if (!r(e.length)) return !1; for (let t = 0; t < e.length; t++) if (!r(e[t]) || e[t] < 0 || e[t] > 255) return !1; return !0; } function a(e, t) { if (e.buffer && e.name === 'Uint8Array') return t && (e = e.slice ? e.slice() : Array.prototype.slice.call(e)), e; if (Array.isArray(e)) { if (!i(e)) throw new Error(`Array contains invalid value: ${e}`); return new Uint8Array(e); } if (r(e.length) && i(e)) return new Uint8Array(e); throw new Error('unsupported array-like object'); } function n(e) { return new Uint8Array(e); } function s(e, t, r, i, a) { i == null && a == null || (e = e.slice ? e.slice(i, a) : Array.prototype.slice.call(e, i, a)), t.set(e, r); } let o; const l = { toBytes(e) { const t = []; let r = 0; for (e = encodeURI(e); r < e.length;) { const i = e.charCodeAt(r++); i === 37 ? (t.push(parseInt(e.substr(r, 2), 16)), r += 2) : t.push(i); } return a(t); }, fromBytes(e) { for (var t = [], r = 0; r < e.length;) { const i = e[r]; i < 128 ? (t.push(String.fromCharCode(i)), r++) : i > 191 && i < 224 ? (t.push(String.fromCharCode((31 & i) << 6 | 63 & e[r + 1])), r += 2) : (t.push(String.fromCharCode((15 & i) << 12 | (63 & e[r + 1]) << 6 | 63 & e[r + 2])), r += 3); } return t.join(''); } }; const u = (o = '0123456789abcdef', { toBytes(e) { for (var t = [], r = 0; r < e.length; r += 2)t.push(parseInt(e.substr(r, 2), 16)); return t; }, fromBytes(e) { for (var t = [], r = 0; r < e.length; r++) { const i = e[r]; t.push(o[(240 & i) >> 4] + o[15 & i]); } return t.join(''); } }); const d = { 16: 10, 24: 12, 32: 14 }; const c = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145]; const h = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22]; const f = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125]; const g = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986]; const p = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766]; const v = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126]; const m = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436]; const y = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890]; const b = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935]; const T = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600]; const E = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480]; const S = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795]; const _ = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855]; const A = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150]; const R = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925]; function w(e) { for (var t = [], r = 0; r < e.length; r += 4)t.push(e[r] << 24 | e[r + 1] << 16 | e[r + 2] << 8 | e[r + 3]); return t; } const k = function e(t) { if (!(this instanceof e)) throw Error('AES must be instanitated with `new`'); Object.defineProperty(this, 'key', { value: a(t, !0) }), this._prepare(); }; k.prototype._prepare = function() { const e = d[this.key.length]; if (e == null) throw new Error('invalid key size (must be 16, 24 or 32 bytes)'); this._Ke = [], this._Kd = []; for (var t = 0; t <= e; t++) this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]); let r; const i = 4 * (e + 1); const a = this.key.length / 4; const n = w(this.key); for (t = 0; t < a; t++)r = t >> 2, this._Ke[r][t % 4] = n[t], this._Kd[e - r][t % 4] = n[t]; for (var s, o = 0, l = a; l < i;) { if (s = n[a - 1], n[0] ^= h[s >> 16 & 255] << 24 ^ h[s >> 8 & 255] << 16 ^ h[255 & s] << 8 ^ h[s >> 24 & 255] ^ c[o] << 24, o += 1, a != 8) for (t = 1; t < a; t++)n[t] ^= n[t - 1]; else { for (t = 1; t < a / 2; t++)n[t] ^= n[t - 1]; s = n[a / 2 - 1], n[a / 2] ^= h[255 & s] ^ h[s >> 8 & 255] << 8 ^ h[s >> 16 & 255] << 16 ^ h[s >> 24 & 255] << 24; for (t = a / 2 + 1; t < a; t++)n[t] ^= n[t - 1]; } for (t = 0; t < a && l < i;)u = l >> 2, f = l % 4, this._Ke[u][f] = n[t], this._Kd[e - u][f] = n[t++], l++; } for (var u = 1; u < e; u++) for (var f = 0; f < 4; f++)s = this._Kd[u][f], this._Kd[u][f] = S[s >> 24 & 255] ^ _[s >> 16 & 255] ^ A[s >> 8 & 255] ^ R[255 & s]; }, k.prototype.encrypt = function(e) { if (e.length != 16) throw new Error('invalid plaintext size (must be 16 bytes)'); for (var t = this._Ke.length - 1, r = [0, 0, 0, 0], i = w(e), a = 0; a < 4; a++)i[a] ^= this._Ke[0][a]; for (let s = 1; s < t; s++) { for (a = 0; a < 4; a++)r[a] = g[i[a] >> 24 & 255] ^ p[i[(a + 1) % 4] >> 16 & 255] ^ v[i[(a + 2) % 4] >> 8 & 255] ^ m[255 & i[(a + 3) % 4]] ^ this._Ke[s][a]; i = r.slice(); } let o; const l = n(16); for (a = 0; a < 4; a++)o = this._Ke[t][a], l[4 * a] = 255 & (h[i[a] >> 24 & 255] ^ o >> 24), l[4 * a + 1] = 255 & (h[i[(a + 1) % 4] >> 16 & 255] ^ o >> 16), l[4 * a + 2] = 255 & (h[i[(a + 2) % 4] >> 8 & 255] ^ o >> 8), l[4 * a + 3] = 255 & (h[255 & i[(a + 3) % 4]] ^ o); return l; }, k.prototype.decrypt = function(e) { if (e.length != 16) throw new Error('invalid ciphertext size (must be 16 bytes)'); for (var t = this._Kd.length - 1, r = [0, 0, 0, 0], i = w(e), a = 0; a < 4; a++)i[a] ^= this._Kd[0][a]; for (let s = 1; s < t; s++) { for (a = 0; a < 4; a++)r[a] = y[i[a] >> 24 & 255] ^ b[i[(a + 3) % 4] >> 16 & 255] ^ T[i[(a + 2) % 4] >> 8 & 255] ^ E[255 & i[(a + 1) % 4]] ^ this._Kd[s][a]; i = r.slice(); } let o; const l = n(16); for (a = 0; a < 4; a++)o = this._Kd[t][a], l[4 * a] = 255 & (f[i[a] >> 24 & 255] ^ o >> 24), l[4 * a + 1] = 255 & (f[i[(a + 3) % 4] >> 16 & 255] ^ o >> 16), l[4 * a + 2] = 255 & (f[i[(a + 2) % 4] >> 8 & 255] ^ o >> 8), l[4 * a + 3] = 255 & (f[255 & i[(a + 1) % 4]] ^ o); return l; }; const L = function e(t, r) { if (!(this instanceof e)) throw Error('AES must be instanitated with `new`'); if (this.description = 'Cipher Block Chaining', this.name = 'cbc', r) { if (r.length != 16) throw new Error('invalid initialation vector size (must be 16 bytes)'); } else r = n(16); this._lastCipherblock = a(r, !0), this._aes = new k(t); }; L.prototype.encrypt = function(e) { if ((e = a(e)).length % 16 != 0) throw new Error('invalid plaintext size (must be multiple of 16 bytes)'); for (var t = n(e.length), r = n(16), i = 0; i < e.length; i += 16) { s(e, r, 0, i, i + 16); for (let o = 0; o < 16; o++)r[o] ^= this._lastCipherblock[o]; this._lastCipherblock = this._aes.encrypt(r), s(this._lastCipherblock, t, i); } return t; }, L.prototype.decrypt = function(e) { if ((e = a(e)).length % 16 != 0) throw new Error('invalid ciphertext size (must be multiple of 16 bytes)'); for (var t = n(e.length), r = n(16), i = 0; i < e.length; i += 16) { s(e, r, 0, i, i + 16), r = this._aes.decrypt(r); for (let o = 0; o < 16; o++)t[i + o] = r[o] ^ this._lastCipherblock[o]; s(e, this._lastCipherblock, 0, i, i + 16); } return t; }; const D = function e(t) { if (!(this instanceof e)) throw Error('Counter must be instanitated with `new`'); t === 0 || t || (t = 1), typeof t === 'number' ? (this._counter = n(16), this.setValue(t)) : this.setBytes(t); }; D.prototype.setValue = function(e) { if (typeof e !== 'number' || parseInt(e) != e) throw new Error('invalid counter value (must be an integer)'); if (e > Number.MAX_SAFE_INTEGER) throw new Error('integer value out of safe range'); for (let t = 15; t >= 0; --t) this._counter[t] = e % 256, e = parseInt(e / 256); }, D.prototype.setBytes = function(e) { if ((e = a(e, !0)).length != 16) throw new Error('invalid counter bytes size (must be 16 bytes)'); this._counter = e; }, D.prototype.increment = function() { for (let e = 15; e >= 0; e--) { if (this._counter[e] !== 255) { this._counter[e]++; break; } this._counter[e] = 0; } }; const C = { AES: k, Counter: D, modeOfOperation: { cbc: L }, utils: { hex: u, utf8: l }, padding: { pkcs7: { pad(e) { const t = 16 - (e = a(e, !0)).length % 16; const r = n(e.length + t); s(e, r); for (let i = e.length; i < r.length; i++)r[i] = t; return r; }, strip(e) { if ((e = a(e, !0)).length < 16) throw new Error('PKCS#7 invalid length'); const t = e[e.length - 1]; if (t > 16) throw new Error('PKCS#7 padding byte out of range'); for (var r = e.length - t, i = 0; i < t; i++) if (e[r + i] !== t) throw new Error('PKCS#7 invalid padding byte'); const o = n(r); return s(e, o, 0, 0, r), o; } } }, _arrayTest: { coerceArray: a, createArray: n, copyArray: s } }; e.exports = C;
}());
}, function(e, t, r) {
r.r(t); const i = r(9); const a = r(1); const n = r(0); const s = r(8); t.default = function(e) { const t = new s.EventEmitter(); t.trigger = function(e) { for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++)i[a - 1] = arguments[a]; t.emit.apply(t, [e, e].concat(i)); }, t.off = function(e) { for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), a = 1; a < r; a++)i[a - 1] = arguments[a]; t.removeListener.apply(t, [e].concat(i)); }; const r = function(t, r) { e.postMessage({ event: t, data: r }); }; e.addEventListener('message', ((a) => { const s = a.data; switch (s.cmd) { case 'init': var o = JSON.parse(s.config); e.demuxer = new i.a(t, s.typeSupported, o, s.vendor), Object(n.a)(o.debug), r('init', null); break; case 'demux': e.demuxer.push(s.data, s.decryptdata, s.initSegment, s.audioCodec, s.videoCodec, s.timeOffset, s.discontinuity, s.trackSwitch, s.contiguous, s.duration, s.accurateTimeOffset, s.defaultInitPTS); } })), t.on(a.a.FRAG_DECRYPTED, r), t.on(a.a.FRAG_PARSING_INIT_SEGMENT, r), t.on(a.a.FRAG_PARSED, r), t.on(a.a.ERROR, r), t.on(a.a.FRAG_PARSING_METADATA, r), t.on(a.a.FRAG_PARSING_USERDATA, r), t.on(a.a.INIT_PTS_FOUND, r), t.on(a.a.FRAG_PARSING_DATA, ((t, r) => { const i = []; const a = { event: t, data: r }; r.data1 && (a.data1 = r.data1.buffer, i.push(r.data1.buffer), delete r.data1), r.data2 && (a.data2 = r.data2.buffer, i.push(r.data2.buffer), delete r.data2), e.postMessage(a, i); })); };
}, function(e, t, r) {
r.r(t); const i = {}; r.r(i), r.d(i, 'newCue', (() => mt)); let a; let n; const s = r(6); const o = r(2); const l = r(3); const u = r(1); const d = r(0); const c = { hlsEventGeneric: !0, hlsHandlerDestroying: !0, hlsHandlerDestroyed: !0 }; const h = (function() { function e(e) { this.hls = void 0, this.handledEvents = void 0, this.useGenericHandler = void 0, this.hls = e, this.onEvent = this.onEvent.bind(this); for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)r[i - 1] = arguments[i]; this.handledEvents = r, this.useGenericHandler = !0, this.registerListeners(); } const t = e.prototype; return t.destroy = function() { this.onHandlerDestroying(), this.unregisterListeners(), this.onHandlerDestroyed(); }, t.onHandlerDestroying = function() {}, t.onHandlerDestroyed = function() {}, t.isEventHandler = function() { return typeof this.handledEvents === 'object' && this.handledEvents.length && typeof this.onEvent === 'function'; }, t.registerListeners = function() { this.isEventHandler() && this.handledEvents.forEach((function(e) { if (c[e]) throw new Error(`Forbidden event-name: ${e}`); this.hls.on(e, this.onEvent); }), this); }, t.unregisterListeners = function() { this.isEventHandler() && this.handledEvents.forEach((function(e) { this.hls.off(e, this.onEvent); }), this); }, t.onEvent = function(e, t) { this.onEventGeneric(e, t); }, t.onEventGeneric = function(e, t) { try { (function(e, t) { const r = `on${e.replace('hls', '')}`; if (typeof this[r] !== 'function') throw new Error(`Event ${e} has no generic handler in this ${this.constructor.name} class (tried ${r})`); return this[r].bind(this, t); }).call(this, e, t).call(); } catch (t) { d.b.error(`An internal error happened while handling event ${e}. Error message: "${t.message}". Here is a stacktrace:`, t), this.hls.trigger(u.a.ERROR, { type: o.b.OTHER_ERROR, details: o.a.INTERNAL_EXCEPTION, fatal: !1, event: e, err: t }); } }, e; }()); !(function(e) { e.MANIFEST = 'manifest', e.LEVEL = 'level', e.AUDIO_TRACK = 'audioTrack', e.SUBTITLE_TRACK = 'subtitleTrack'; }(a || (a = {}))), (function(e) { e.MAIN = 'main', e.AUDIO = 'audio', e.SUBTITLE = 'subtitle'; }(n || (n = {}))); const f = r(10); function g(e, t) { for (let r = 0; r < t.length; r++) { const i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } } let p; const v = (function() { function e(e, t) { this._uri = null, this.baseuri = void 0, this.reluri = void 0, this.method = null, this.key = null, this.iv = null, this.baseuri = e, this.reluri = t; } let t; let r; let i; return t = e, (r = [{ key: 'uri', get() { return !this._uri && this.reluri && (this._uri = Object(s.buildAbsoluteURL)(this.baseuri, this.reluri, { alwaysNormalize: !0 })), this._uri; } }]) && g(t.prototype, r), i && g(t, i), e; }()); function m(e, t) { for (let r = 0; r < t.length; r++) { const i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } }!(function(e) { e.AUDIO = 'audio', e.VIDEO = 'video'; }(p || (p = {}))); const y = (function() { function e() { let e; this._url = null, this._byteRange = null, this._decryptdata = null, this._elementaryStreams = ((e = {})[p.AUDIO] = !1, e[p.VIDEO] = !1, e), this.deltaPTS = 0, this.rawProgramDateTime = null, this.programDateTime = null, this.title = null, this.tagList = [], this.cc = void 0, this.type = void 0, this.relurl = void 0, this.baseurl = void 0, this.duration = void 0, this.start = void 0, this.sn = 0, this.urlId = 0, this.level = 0, this.levelkey = void 0, this.loader = void 0; } let t; let r; let i; const a = e.prototype; return a.setByteRange = function(e, t) { const r = e.split('@', 2); const i = []; r.length === 1 ? i[0] = t ? t.byteRangeEndOffset : 0 : i[0] = parseInt(r[1]), i[1] = parseInt(r[0]) + i[0], this._byteRange = i; }, a.addElementaryStream = function(e) { this._elementaryStreams[e] = !0; }, a.hasElementaryStream = function(e) { return !0 === this._elementaryStreams[e]; }, a.createInitializationVector = function(e) { for (var t = new Uint8Array(16), r = 12; r < 16; r++)t[r] = e >> 8 * (15 - r) & 255; return t; }, a.setDecryptDataFromLevelKey = function(e, t) { let r = e; return e && e.method && e.uri && !e.iv && ((r = new v(e.baseuri, e.reluri)).method = e.method, r.iv = this.createInitializationVector(t)), r; }, t = e, (r = [{ key: 'url', get() { return !this._url && this.relurl && (this._url = Object(s.buildAbsoluteURL)(this.baseurl, this.relurl, { alwaysNormalize: !0 })), this._url; }, set(e) { this._url = e; } }, { key: 'byteRange', get() { return this._byteRange ? this._byteRange : []; } }, { key: 'byteRangeStartOffset', get() { return this.byteRange[0]; } }, { key: 'byteRangeEndOffset', get() { return this.byteRange[1]; } }, { key: 'decryptdata', get() { if (!this.levelkey && !this._decryptdata) return null; if (!this._decryptdata && this.levelkey) { let e = this.sn; typeof e !== 'number' && (this.levelkey && this.levelkey.method === 'AES-128' && !this.levelkey.iv && d.b.warn(`missing IV for initialization segment with method="${this.levelkey.method}" - compliance issue`), e = 0), this._decryptdata = this.setDecryptDataFromLevelKey(this.levelkey, e); } return this._decryptdata; } }, { key: 'endProgramDateTime', get() { if (this.programDateTime === null) return null; if (!Object(l.a)(this.programDateTime)) return null; const e = Object(l.a)(this.duration) ? this.duration : 0; return this.programDateTime + 1e3 * e; } }, { key: 'encrypted', get() { return !(!this.decryptdata || this.decryptdata.uri === null || this.decryptdata.key !== null); } }]) && m(t.prototype, r), i && m(t, i), e; }()); function b(e, t) { for (let r = 0; r < t.length; r++) { const i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } } const T = (function() { function e(e) { this.endCC = 0, this.endSN = 0, this.fragments = [], this.initSegment = null, this.live = !0, this.needSidxRanges = !1, this.startCC = 0, this.startSN = 0, this.startTimeOffset = null, this.targetduration = 0, this.totalduration = 0, this.type = null, this.url = e, this.version = null; } let t; let r; let i; return t = e, (r = [{ key: 'hasProgramDateTime', get() { return !(!this.fragments[0] || !Object(l.a)(this.fragments[0].programDateTime)); } }]) && b(t.prototype, r), i && b(t, i), e; }()); const E = /^(\d+)x(\d+)$/; const S = /\s*(.+?)\s*=((?:\".*?\")|.*?)(?:,|$)/g; const _ = (function() { function e(t) { for (const r in typeof t === 'string' && (t = e.parseAttrList(t)), t)t.hasOwnProperty(r) && (this[r] = t[r]); } const t = e.prototype; return t.decimalInteger = function(e) { const t = parseInt(this[e], 10); return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t; }, t.hexadecimalInteger = function(e) { if (this[e]) { let t = (this[e] || '0x').slice(2); t = (1 & t.length ? '0' : '') + t; for (var r = new Uint8Array(t.length / 2), i = 0; i < t.length / 2; i++)r[i] = parseInt(t.slice(2 * i, 2 * i + 2), 16); return r; } return null; }, t.hexadecimalIntegerAsNumber = function(e) { const t = parseInt(this[e], 16); return t > Number.MAX_SAFE_INTEGER ? 1 / 0 : t; }, t.decimalFloatingPoint = function(e) { return parseFloat(this[e]); }, t.enumeratedString = function(e) { return this[e]; }, t.decimalResolution = function(e) { const t = E.exec(this[e]); if (t !== null) return { width: parseInt(t[1], 10), height: parseInt(t[2], 10) }; }, e.parseAttrList = function(e) { let t; const r = {}; for (S.lastIndex = 0; (t = S.exec(e)) !== null;) { let i = t[2]; i.indexOf('"') === 0 && i.lastIndexOf('"') === i.length - 1 && (i = i.slice(1, -1)), r[t[1]] = i; } return r; }, e; }()); const A = { audio: { a3ds: !0, 'ac-3': !0, 'ac-4': !0, alac: !0, alaw: !0, dra1: !0, 'dts+': !0, 'dts-': !0, dtsc: !0, dtse: !0, dtsh: !0, 'ec-3': !0, enca: !0, g719: !0, g726: !0, m4ae: !0, mha1: !0, mha2: !0, mhm1: !0, mhm2: !0, mlpa: !0, mp4a: !0, 'raw ': !0, Opus: !0, samr: !0, sawb: !0, sawp: !0, sevc: !0, sqcp: !0, ssmv: !0, twos: !0, ulaw: !0 }, video: { avc1: !0, avc2: !0, avc3: !0, avc4: !0, avcp: !0, drac: !0, dvav: !0, dvhe: !0, encv: !0, hev1: !0, hvc1: !0, mjp2: !0, mp4v: !0, mvc1: !0, mvc2: !0, mvc3: !0, mvc4: !0, resv: !0, rv60: !0, s263: !0, svc1: !0, svc2: !0, 'vc-1': !0, vp08: !0, vp09: !0 } }; function R(e, t) { return MediaSource.isTypeSupported(`${t || 'video'}/mp4;codecs="${e}"`); } const w = /#EXT-X-STREAM-INF:([^\n\r]*)[\r\n]+([^\r\n]+)/g; const k = /#EXT-X-MEDIA:(.*)/g; const L = new RegExp([/#EXTINF:\s*(\d*(?:\.\d+)?)(?:,(.*)\s+)?/.source, /|(?!#)([\S+ ?]+)/.source, /|#EXT-X-BYTERANGE:*(.+)/.source, /|#EXT-X-PROGRAM-DATE-TIME:(.+)/.source, /|#.*/.source].join(''), 'g'); const D = /(?:(?:#(EXTM3U))|(?:#EXT-X-(PLAYLIST-TYPE):(.+))|(?:#EXT-X-(MEDIA-SEQUENCE): *(\d+))|(?:#EXT-X-(TARGETDURATION): *(\d+))|(?:#EXT-X-(KEY):(.+))|(?:#EXT-X-(START):(.+))|(?:#EXT-X-(ENDLIST))|(?:#EXT-X-(DISCONTINUITY-SEQ)UENCE:(\d+))|(?:#EXT-X-(DIS)CONTINUITY))|(?:#EXT-X-(VERSION):(\d+))|(?:#EXT-X-(MAP):(.+))|(?:(#)([^:]*):(.*))|(?:(#)(.*))(?:.*)\r?\n?/; const C = /\.(mp4|m4s|m4v|m4a)$/i; const I = (function() { function e() {} return e.findGroup = function(e, t) { for (let r = 0; r < e.length; r++) { const i = e[r]; if (i.id === t) return i; } }, e.convertAVC1ToAVCOTI = function(e) { let t; const r = e.split('.'); return r.length > 2 ? (t = `${r.shift()}.`, t += parseInt(r.shift()).toString(16), t += (`000${parseInt(r.shift()).toString(16)}`).substr(-4)) : t = e, t; }, e.resolve = function(e, t) { return s.buildAbsoluteURL(t, e, { alwaysNormalize: !0 }); }, e.parseMasterPlaylist = function(t, r) { let i; const a = []; function n(e, t) { ['video', 'audio'].forEach(((r) => { const i = e.filter(((e) => (function(e, t) { const r = A[t]; return !!r && !0 === r[e.slice(0, 4)]; }(e, r)))); if (i.length) { const a = i.filter(((e) => e.lastIndexOf('avc1', 0) === 0 || e.lastIndexOf('mp4a', 0) === 0)); t[`${r}Codec`] = a.length > 0 ? a[0] : i[0], e = e.filter(((e) => i.indexOf(e) === -1)); } })), t.unknownCodecs = e; } for (w.lastIndex = 0; (i = w.exec(t)) != null;) { const s = {}; const o = s.attrs = new _(i[1]); s.url = e.resolve(i[2], r); const l = o.decimalResolution('RESOLUTION'); l && (s.width = l.width, s.height = l.height), s.bitrate = o.decimalInteger('AVERAGE-BANDWIDTH') || o.decimalInteger('BANDWIDTH'), s.name = o.NAME, n([].concat((o.CODECS || '').split(/[ ,]+/)), s), s.videoCodec && s.videoCodec.indexOf('avc1') !== -1 && (s.videoCodec = e.convertAVC1ToAVCOTI(s.videoCodec)), a.push(s); } return a; }, e.parseMasterPlaylistMedia = function(t, r, i, a) { let n; void 0 === a && (a = []); const s = []; let o = 0; for (k.lastIndex = 0; (n = k.exec(t)) !== null;) { const l = new _(n[1]); if (l.TYPE === i) { const u = { id: o++, groupId: l['GROUP-ID'], name: l.NAME || l.LANGUAGE, type: i, default: l.DEFAULT === 'YES', autoselect: l.AUTOSELECT === 'YES', forced: l.FORCED === 'YES', lang: l.LANGUAGE }; if (l.URI && (u.url = e.resolve(l.URI, r)), a.length) { const d = e.findGroup(a, u.groupId); u.audioCodec = d ? d.codec : a[0].codec; }s.push(u); } } return s; }, e.parseLevelPlaylist = function(e, t, r, i, a) { let n; let s; let o; let u = 0; let c = 0; const h = new T(t); let f = 0; let g = null; let p = new y(); let m = null; for (L.lastIndex = 0; (n = L.exec(e)) !== null;) { const b = n[1]; if (b) { p.duration = parseFloat(b); const E = (` ${n[2]}`).slice(1); p.title = E || null, p.tagList.push(E ? ['INF', b, E] : ['INF', b]); } else if (n[3]) { if (Object(l.a)(p.duration)) { const S = u++; p.type = i, p.start = c, o && (p.levelkey = o), p.sn = S, p.level = r, p.cc = f, p.urlId = a, p.baseurl = t, p.relurl = (` ${n[3]}`).slice(1), O(p, g), h.fragments.push(p), g = p, c += p.duration, p = new y(); } } else if (n[4]) { const A = (` ${n[4]}`).slice(1); g ? p.setByteRange(A, g) : p.setByteRange(A); } else if (n[5])p.rawProgramDateTime = (` ${n[5]}`).slice(1), p.tagList.push(['PROGRAM-DATE-TIME', p.rawProgramDateTime]), m === null && (m = h.fragments.length); else { if (!(n = n[0].match(D))) { d.b.warn('No matches on slow regex match for level playlist!'); continue; } for (s = 1; s < n.length && void 0 === n[s]; s++);const R = (` ${n[s + 1]}`).slice(1); const w = (` ${n[s + 2]}`).slice(1); switch (n[s]) { case '#': p.tagList.push(w ? [R, w] : [R]); break; case 'PLAYLIST-TYPE': h.type = R.toUpperCase(); break; case 'MEDIA-SEQUENCE': u = h.startSN = parseInt(R); break; case 'TARGETDURATION': h.targetduration = parseFloat(R); break; case 'VERSION': h.version = parseInt(R); break; case 'EXTM3U': break; case 'ENDLIST': h.live = !1; break; case 'DIS': f++, p.tagList.push(['DIS']); break; case 'DISCONTINUITY-SEQ': f = parseInt(R); break; case 'KEY': var k = new _(R); var I = k.enumeratedString('METHOD'); var x = k.URI; var P = k.hexadecimalInteger('IV'); I && (o = new v(t, x), x && ['AES-128', 'SAMPLE-AES', 'SAMPLE-AES-CENC'].indexOf(I) >= 0 && (o.method = I, o.key = null, o.iv = P)); break; case 'START': var M = new _(R).decimalFloatingPoint('TIME-OFFSET'); Object(l.a)(M) && (h.startTimeOffset = M); break; case 'MAP': var F = new _(R); p.relurl = F.URI, F.BYTERANGE && p.setByteRange(F.BYTERANGE), p.baseurl = t, p.level = r, p.type = i, p.sn = 'initSegment', h.initSegment = p, (p = new y()).rawProgramDateTime = h.initSegment.rawProgramDateTime; break; default: d.b.warn(`line parsed but not handled: ${n}`); } } } return (p = g) && !p.relurl && (h.fragments.pop(), c -= p.duration), h.totalduration = c, h.averagetargetduration = c / h.fragments.length, h.endSN = u - 1, h.startCC = h.fragments[0] ? h.fragments[0].cc : 0, h.endCC = f, !h.initSegment && h.fragments.length && h.fragments.every(((e) => C.test(e.relurl))) && (d.b.warn('MP4 fragments found but no init segment (probably no MAP, incomplete M3U8), trying to fetch SIDX'), (p = new y()).relurl = h.fragments[0].relurl, p.baseurl = t, p.level = r, p.type = i, p.sn = 'initSegment', h.initSegment = p, h.needSidxRanges = !0), m && (function(e, t) { for (let r = e[t], i = t - 1; i >= 0; i--) { const a = e[i]; a.programDateTime = r.programDateTime - 1e3 * a.duration, r = a; } }(h.fragments, m)), h; }, e; }()); function O(e, t) { e.rawProgramDateTime ? e.programDateTime = Date.parse(e.rawProgramDateTime) : t && t.programDateTime && (e.programDateTime = t.endProgramDateTime), Object(l.a)(e.programDateTime) || (e.programDateTime = null, e.rawProgramDateTime = null); } const x = window.performance; const P = (function(e) { let t; let r; function i(t) { let r; return (r = e.call(this, t, u.a.MANIFEST_LOADING, u.a.LEVEL_LOADING, u.a.AUDIO_TRACK_LOADING, u.a.SUBTITLE_TRACK_LOADING) || this).loaders = {}, r; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r, i.canHaveQualityLevels = function(e) { return e !== a.AUDIO_TRACK && e !== a.SUBTITLE_TRACK; }, i.mapContextToLevelType = function(e) { switch (e.type) { case a.AUDIO_TRACK: return n.AUDIO; case a.SUBTITLE_TRACK: return n.SUBTITLE; default: return n.MAIN; } }, i.getResponseUrl = function(e, t) { let r = e.url; return void 0 !== r && r.indexOf('data:') !== 0 || (r = t.url), r; }; const s = i.prototype; return s.createInternalLoader = function(e) { const t = this.hls.config; const r = t.pLoader; const i = t.loader; const a = new (r || i)(t); return e.loader = a, this.loaders[e.type] = a, a; }, s.getInternalLoader = function(e) { return this.loaders[e.type]; }, s.resetInternalLoader = function(e) { this.loaders[e] && delete this.loaders[e]; }, s.destroyInternalLoaders = function() { for (const e in this.loaders) { const t = this.loaders[e]; t && t.destroy(), this.resetInternalLoader(e); } }, s.destroy = function() { this.destroyInternalLoaders(), e.prototype.destroy.call(this); }, s.onManifestLoading = function(e) { this.load({ url: e.url, type: a.MANIFEST, level: 0, id: null, responseType: 'text' }); }, s.onLevelLoading = function(e) { this.load({ url: e.url, type: a.LEVEL, level: e.level, id: e.id, responseType: 'text' }); }, s.onAudioTrackLoading = function(e) { this.load({ url: e.url, type: a.AUDIO_TRACK, level: null, id: e.id, responseType: 'text' }); }, s.onSubtitleTrackLoading = function(e) { this.load({ url: e.url, type: a.SUBTITLE_TRACK, level: null, id: e.id, responseType: 'text' }); }, s.load = function(e) { const t = this.hls.config; d.b.debug(`Loading playlist of type ${e.type}, level: ${e.level}, id: ${e.id}`); let r; let i; let n; let s; let o = this.getInternalLoader(e); if (o) { const l = o.context; if (l && l.url === e.url) return d.b.trace('playlist request ongoing'), !1; d.b.warn(`aborting previous loader for type: ${e.type}`), o.abort(); } switch (e.type) { case a.MANIFEST: r = t.manifestLoadingMaxRetry, i = t.manifestLoadingTimeOut, n = t.manifestLoadingRetryDelay, s = t.manifestLoadingMaxRetryTimeout; break; case a.LEVEL: r = 0, s = 0, n = 0, i = t.levelLoadingTimeOut; break; default: r = t.levelLoadingMaxRetry, i = t.levelLoadingTimeOut, n = t.levelLoadingRetryDelay, s = t.levelLoadingMaxRetryTimeout; }o = this.createInternalLoader(e); const u = { timeout: i, maxRetry: r, retryDelay: n, maxRetryDelay: s }; const c = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) }; return d.b.debug(`Calling internal loader delegate for URL: ${e.url}`), o.load(e, u, c), !0; }, s.loadsuccess = function(e, t, r, i) { if (void 0 === i && (i = null), r.isSidxRequest) return this._handleSidxRequest(e, r), void this._handlePlaylistLoaded(e, t, r, i); if (this.resetInternalLoader(r.type), typeof e.data !== 'string') throw new Error('expected responseType of "text" for PlaylistLoader'); const a = e.data; t.tload = x.now(), a.indexOf('#EXTM3U') === 0 ? a.indexOf('#EXTINF:') > 0 || a.indexOf('#EXT-X-TARGETDURATION:') > 0 ? this._handleTrackOrLevelPlaylist(e, t, r, i) : this._handleMasterPlaylist(e, t, r, i) : this._handleManifestParsingError(e, r, 'no EXTM3U delimiter', i); }, s.loaderror = function(e, t, r) { void 0 === r && (r = null), this._handleNetworkError(t, r, !1, e); }, s.loadtimeout = function(e, t, r) { void 0 === r && (r = null), this._handleNetworkError(t, r, !0); }, s._handleMasterPlaylist = function(e, t, r, a) { const n = this.hls; const s = e.data; const o = i.getResponseUrl(e, r); const l = I.parseMasterPlaylist(s, o); if (l.length) { const c = l.map(((e) => ({ id: e.attrs.AUDIO, codec: e.audioCodec }))); const h = I.parseMasterPlaylistMedia(s, o, 'AUDIO', c); const f = I.parseMasterPlaylistMedia(s, o, 'SUBTITLES'); if (h.length) { let g = !1; h.forEach(((e) => { e.url || (g = !0); })), !1 === g && l[0].audioCodec && !l[0].attrs.AUDIO && (d.b.log('audio codec signaled in quality level, but no embedded audio track signaled, create one'), h.unshift({ type: 'main', name: 'main', default: !1, autoselect: !1, forced: !1, id: -1 })); }n.trigger(u.a.MANIFEST_LOADED, { levels: l, audioTracks: h, subtitles: f, url: o, stats: t, networkDetails: a }); } else this._handleManifestParsingError(e, r, 'no level found in manifest', a); }, s._handleTrackOrLevelPlaylist = function(e, t, r, n) { const s = this.hls; const o = r.id; const d = r.level; const c = r.type; const h = i.getResponseUrl(e, r); const f = Object(l.a)(o) ? o : 0; const g = Object(l.a)(d) ? d : f; const p = i.mapContextToLevelType(r); const v = I.parseLevelPlaylist(e.data, h, g, p, f); if (v.tload = t.tload, c === a.MANIFEST) { const m = { url: h, details: v }; s.trigger(u.a.MANIFEST_LOADED, { levels: [m], audioTracks: [], url: h, stats: t, networkDetails: n }); } if (t.tparsed = x.now(), v.needSidxRanges) { const y = v.initSegment.url; this.load({ url: y, isSidxRequest: !0, type: c, level: d, levelDetails: v, id: o, rangeStart: 0, rangeEnd: 2048, responseType: 'arraybuffer' }); } else r.levelDetails = v, this._handlePlaylistLoaded(e, t, r, n); }, s._handleSidxRequest = function(e, t) { if (typeof e.data === 'string') throw new Error('sidx request must be made with responseType of array buffer'); const r = f.a.parseSegmentIndex(new Uint8Array(e.data)); if (r) { const i = r.references; const a = t.levelDetails; i.forEach(((e, t) => { const r = e.info; if (a) { const i = a.fragments[t]; i.byteRange.length === 0 && i.setByteRange(`${String(1 + r.end - r.start)}@${String(r.start)}`); } })), a && a.initSegment.setByteRange(`${String(r.moovEndOffset)}@0`); } }, s._handleManifestParsingError = function(e, t, r, i) { this.hls.trigger(u.a.ERROR, { type: o.b.NETWORK_ERROR, details: o.a.MANIFEST_PARSING_ERROR, fatal: !0, url: e.url, reason: r, networkDetails: i }); }, s._handleNetworkError = function(e, t, r, i) { let n; let s; void 0 === r && (r = !1), void 0 === i && (i = null), d.b.info(`A network error occured while loading a ${e.type}-type playlist`); const l = this.getInternalLoader(e); switch (e.type) { case a.MANIFEST: n = r ? o.a.MANIFEST_LOAD_TIMEOUT : o.a.MANIFEST_LOAD_ERROR, s = !0; break; case a.LEVEL: n = r ? o.a.LEVEL_LOAD_TIMEOUT : o.a.LEVEL_LOAD_ERROR, s = !1; break; case a.AUDIO_TRACK: n = r ? o.a.AUDIO_TRACK_LOAD_TIMEOUT : o.a.AUDIO_TRACK_LOAD_ERROR, s = !1; break; default: s = !1; }l && (l.abort(), this.resetInternalLoader(e.type)); const c = { type: o.b.NETWORK_ERROR, details: n, fatal: s, url: e.url, loader: l, context: e, networkDetails: t }; i && (c.response = i), this.hls.trigger(u.a.ERROR, c); }, s._handlePlaylistLoaded = function(e, t, r, n) { const s = r.type; const o = r.level; const l = r.id; const d = r.levelDetails; if (d && d.targetduration) if (i.canHaveQualityLevels(r.type)) this.hls.trigger(u.a.LEVEL_LOADED, { details: d, level: o || 0, id: l || 0, stats: t, networkDetails: n }); else switch (s) { case a.AUDIO_TRACK: this.hls.trigger(u.a.AUDIO_TRACK_LOADED, { details: d, id: l, stats: t, networkDetails: n }); break; case a.SUBTITLE_TRACK: this.hls.trigger(u.a.SUBTITLE_TRACK_LOADED, { details: d, id: l, stats: t, networkDetails: n }); } else this._handleManifestParsingError(e, r, 'invalid target duration', n); }, i; }(h)); const M = (function(e) { let t; let r; function i(t) { let r; return (r = e.call(this, t, u.a.FRAG_LOADING) || this).loaders = {}, r; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r; const a = i.prototype; return a.destroy = function() { const t = this.loaders; for (const r in t) { const i = t[r]; i && i.destroy(); } this.loaders = {}, e.prototype.destroy.call(this); }, a.onFragLoading = function(e) { const t = e.frag; const r = t.type; const i = this.loaders; const a = this.hls.config; const n = a.fLoader; const s = a.loader; t.loaded = 0; let o; let u; let c; let h = i[r]; h && (d.b.warn(`abort previous fragment loader for type: ${r}`), h.abort()), h = i[r] = t.loader = a.fLoader ? new n(a) : new s(a), o = { url: t.url, frag: t, responseType: 'arraybuffer', progressData: !1 }; const f = t.byteRangeStartOffset; const g = t.byteRangeEndOffset; Object(l.a)(f) && Object(l.a)(g) && (o.rangeStart = f, o.rangeEnd = g), u = { timeout: a.fragLoadingTimeOut, maxRetry: 0, retryDelay: 0, maxRetryDelay: a.fragLoadingMaxRetryTimeout }, c = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this), onProgress: this.loadprogress.bind(this) }, h.load(o, u, c); }, a.loadsuccess = function(e, t, r, i) { void 0 === i && (i = null); const a = e.data; const n = r.frag; n.loader = void 0, this.loaders[n.type] = void 0, this.hls.trigger(u.a.FRAG_LOADED, { payload: a, frag: n, stats: t, networkDetails: i }); }, a.loaderror = function(e, t, r) { void 0 === r && (r = null); const i = t.frag; const a = i.loader; a && a.abort(), this.loaders[i.type] = void 0, this.hls.trigger(u.a.ERROR, { type: o.b.NETWORK_ERROR, details: o.a.FRAG_LOAD_ERROR, fatal: !1, frag: t.frag, response: e, networkDetails: r }); }, a.loadtimeout = function(e, t, r) { void 0 === r && (r = null); const i = t.frag; const a = i.loader; a && a.abort(), this.loaders[i.type] = void 0, this.hls.trigger(u.a.ERROR, { type: o.b.NETWORK_ERROR, details: o.a.FRAG_LOAD_TIMEOUT, fatal: !1, frag: t.frag, networkDetails: r }); }, a.loadprogress = function(e, t, r, i) { void 0 === i && (i = null); const a = t.frag; a.loaded = e.loaded, this.hls.trigger(u.a.FRAG_LOAD_PROGRESS, { frag: a, stats: e, networkDetails: i }); }, i; }(h)); const F = r(12); const U = (function(e) { let t; let r; function i(t) { let r; return (r = e.call(this, t, u.a.KEY_LOADING) || this).loaders = {}, r.decryptkey = null, r.decrypturl = null, r; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r; const a = i.prototype; return a.destroy = function() { for (const t in this.loaders) { const r = this.loaders[t]; r && r.destroy(); } this.loaders = {}, e.prototype.destroy.call(this); }, a.onKeyLoading = function(e) { const t = e.frag; const r = t.type; const i = this.loaders[r]; if (t.decryptdata) { const a = t.decryptdata.uri; if (a !== this.decrypturl || this.decryptkey === null) { const n = this.hls.config; if (i && (d.b.warn(`abort previous key loader for type:${r}`), i.abort()), !a) return void d.b.warn('key uri is falsy'); t.loader = this.loaders[r] = new n.loader(n), this.decrypturl = a, this.decryptkey = null; const s = { url: a, frag: t, responseType: 'arraybuffer' }; const o = { timeout: n.fragLoadingTimeOut, maxRetry: 0, retryDelay: n.fragLoadingRetryDelay, maxRetryDelay: n.fragLoadingMaxRetryTimeout }; const l = { onSuccess: this.loadsuccess.bind(this), onError: this.loaderror.bind(this), onTimeout: this.loadtimeout.bind(this) }; t.loader.load(s, o, l); } else this.decryptkey && (t.decryptdata.key = this.decryptkey, this.hls.trigger(u.a.KEY_LOADED, { frag: t })); } else d.b.warn('Missing decryption data on fragment in onKeyLoading'); }, a.loadsuccess = function(e, t, r) { const i = r.frag; if (i.decryptdata) { let a; const n = new Uint8Array(e.data); if (!this.hls.config.dKeyDebug && this.hls.config.overlayKey && this.hls.config.overlayIv) { for (var s = this.hls.config.overlayKey, o = this.hls.config.overlayIv, l = [], c = [], h = 0; h < 16; h++) { const f = s.substring(2 * h, 2 * h + 2); const g = o.substring(2 * h, 2 * h + 2); l.push(parseInt(f, 16)), c.push(parseInt(g, 16)); }a = new F.modeOfOperation.cbc(l, c).decrypt(n); } else a = n; this.decryptkey = i.decryptdata.key = a, i.loader = void 0, delete this.loaders[i.type], this.hls.trigger(u.a.KEY_LOADED, { frag: i }); } else d.b.error('after key load, decryptdata unset'); }, a.loaderror = function(e, t) { const r = t.frag; const i = r.loader; i && i.abort(), delete this.loaders[r.type], this.hls.trigger(u.a.ERROR, { type: o.b.NETWORK_ERROR, details: o.a.KEY_LOAD_ERROR, fatal: !1, frag: r, response: e }); }, a.loadtimeout = function(e, t) { const r = t.frag; const i = r.loader; i && i.abort(), delete this.loaders[r.type], this.hls.trigger(u.a.ERROR, { type: o.b.NETWORK_ERROR, details: o.a.KEY_LOAD_TIMEOUT, fatal: !1, frag: r }); }, i; }(h)); const N = 'NOT_LOADED'; const B = 'APPENDING'; const G = 'PARTIAL'; const K = 'OK'; const j = (function(e) { let t; let r; function i(t) { let r; return (r = e.call(this, t, u.a.BUFFER_APPENDED, u.a.FRAG_BUFFERED, u.a.FRAG_LOADED) || this).bufferPadding = 0.2, r.fragments = Object.create(null), r.timeRanges = Object.create(null), r.config = t.config, r; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r; const a = i.prototype; return a.destroy = function() { this.fragments = Object.create(null), this.timeRanges = Object.create(null), this.config = null, h.prototype.destroy.call(this), e.prototype.destroy.call(this); }, a.getBufferedFrag = function(e, t) { const r = this.fragments; const i = Object.keys(r).filter(((i) => { const a = r[i]; if (a.body.type !== t) return !1; if (!a.buffered) return !1; const n = a.body; return n.startPTS <= e && e <= n.endPTS; })); if (i.length === 0) return null; const a = i.pop(); return r[a].body; }, a.detectEvictedFragments = function(e, t) { let r; let i; const a = this; Object.keys(this.fragments).forEach(((n) => { const s = a.fragments[n]; if (!0 === s.buffered) { const o = s.range[e]; if (o) { r = o.time; for (let l = 0; l < r.length; l++) if (i = r[l], !1 === a.isTimeBuffered(i.startPTS, i.endPTS, t)) { a.removeFragment(s.body); break; } } } })); }, a.detectPartialFragments = function(e) { const t = this; const r = this.getFragmentKey(e); const i = this.fragments[r]; i && (i.buffered = !0, Object.keys(this.timeRanges).forEach(((r) => { if (e.hasElementaryStream(r)) { const a = t.timeRanges[r]; i.range[r] = t.getBufferedTimes(e.startPTS, e.endPTS, a); } }))); }, a.getBufferedTimes = function(e, t, r) { for (var i, a, n = [], s = !1, o = 0; o < r.length; o++) { if (i = r.start(o) - this.bufferPadding, a = r.end(o) + this.bufferPadding, e >= i && t <= a) { n.push({ startPTS: Math.max(e, r.start(o)), endPTS: Math.min(t, r.end(o)) }); break; } if (e < a && t > i)n.push({ startPTS: Math.max(e, r.start(o)), endPTS: Math.min(t, r.end(o)) }), s = !0; else if (t <= i) break; } return { time: n, partial: s }; }, a.getFragmentKey = function(e) { return `${e.type}_${e.level}_${e.urlId}_${e.sn}`; }, a.getPartialFragment = function(e) { let t; let r; let i; const a = this; let n = null; let s = 0; return Object.keys(this.fragments).forEach(((o) => { const l = a.fragments[o]; a.isPartial(l) && (r = l.body.startPTS - a.bufferPadding, i = l.body.endPTS + a.bufferPadding, e >= r && e <= i && (t = Math.min(e - r, i - e), s <= t && (n = l.body, s = t))); })), n; }, a.getState = function(e) { const t = this.getFragmentKey(e); const r = this.fragments[t]; let i = N; return void 0 !== r && (i = r.buffered ? !0 === this.isPartial(r) ? G : K : B), i; }, a.isPartial = function(e) { return !0 === e.buffered && (void 0 !== e.range.video && !0 === e.range.video.partial || void 0 !== e.range.audio && !0 === e.range.audio.partial); }, a.isTimeBuffered = function(e, t, r) { for (var i, a, n = 0; n < r.length; n++) { if (i = r.start(n) - this.bufferPadding, a = r.end(n) + this.bufferPadding, e >= i && t <= a) return !0; if (t <= i) return !1; } return !1; }, a.onFragLoaded = function(e) { const t = e.frag; Object(l.a)(t.sn) && !t.bitrateTest && (this.fragments[this.getFragmentKey(t)] = { body: t, range: Object.create(null), buffered: !1 }); }, a.onBufferAppended = function(e) { const t = this; this.timeRanges = e.timeRanges, Object.keys(this.timeRanges).forEach(((e) => { const r = t.timeRanges[e]; t.detectEvictedFragments(e, r); })); }, a.onFragBuffered = function(e) { this.detectPartialFragments(e.frag); }, a.hasFragment = function(e) { const t = this.getFragmentKey(e); return void 0 !== this.fragments[t]; }, a.removeFragment = function(e) { const t = this.getFragmentKey(e); delete this.fragments[t]; }, a.removeAllFragments = function() { this.fragments = Object.create(null); }, i; }(h)); const H = { search(e, t) { for (let r = 0, i = e.length - 1, a = null, n = null; r <= i;) { const s = t(n = e[a = (r + i) / 2 | 0]); if (s > 0)r = a + 1; else { if (!(s < 0)) return n; i = a - 1; } } return null; } }; const V = (function() { function e() {} return e.isBuffered = function(e, t) { try { if (e) for (let r = e.buffered, i = 0; i < r.length; i++) if (t >= r.start(i) && t <= r.end(i)) return !0; } catch (e) {} return !1; }, e.bufferInfo = function(e, t, r) { try { if (e) { let i; const a = e.buffered; const n = []; for (i = 0; i < a.length; i++)n.push({ start: a.start(i), end: a.end(i) }); return this.bufferedInfo(n, t, r); } } catch (e) {} return { len: 0, start: t, end: t, nextStart: void 0 }; }, e.bufferedInfo = function(e, t, r) { e.sort(((e, t) => { const r = e.start - t.start; return r || t.end - e.end; })); let i = []; if (r) for (let a = 0; a < e.length; a++) { const n = i.length; if (n) { const s = i[n - 1].end; e[a].start - s < r ? e[a].end > s && (i[n - 1].end = e[a].end) : i.push(e[a]); } else i.push(e[a]); } else i = e; for (var o, l = 0, u = t, d = t, c = 0; c < i.length; c++) { const h = i[c].start; const f = i[c].end; if (t + r >= h && t < f)u = h, l = (d = f) - t; else if (t + r < h) { o = h; break; } } return { len: l, start: u, end: d, nextStart: o }; }, e; }()); const Y = r(8); const W = r(11); const q = r(9); function z() { return window.MediaSource || window.WebKitMediaSource; } const X = r(5); const Q = (function(e) { let t; let r; function i() { return e.apply(this, arguments) || this; } return r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r, i.prototype.trigger = function(e) { for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)r[i - 1] = arguments[i]; this.emit.apply(this, [e, e].concat(r)); }, i; }(Y.EventEmitter)); const $ = Object(X.a)(); const J = z() || { isTypeSupported() { return !1; } }; const Z = (function() {
 function e(e, t) {
 const r = this; this.hls = e, this.id = t; const i = this.observer = new Q(); const a = e.config; const
n = function(t, i) { (i = i || {}).frag = r.frag, i.id = r.id, e.trigger(t, i); }; i.on(u.a.FRAG_DECRYPTED, n), i.on(u.a.FRAG_PARSING_INIT_SEGMENT, n), i.on(u.a.FRAG_PARSING_DATA, n), i.on(u.a.FRAG_PARSED, n), i.on(u.a.ERROR, n), i.on(u.a.FRAG_PARSING_METADATA, n), i.on(u.a.FRAG_PARSING_USERDATA, n), i.on(u.a.INIT_PTS_FOUND, n); const s = { mp4: J.isTypeSupported('video/mp4'), mpeg: J.isTypeSupported('audio/mpeg'), mp3: J.isTypeSupported('audio/mp4; codecs="mp3"') }; const l = navigator.vendor; if (a.enableWorker && typeof Worker !== 'undefined') { let c; d.b.log('demuxing in webworker'); try { c = this.w = W(13), this.onwmsg = this.onWorkerMessage.bind(this), c.addEventListener('message', this.onwmsg), c.onerror = function(t) { e.trigger(u.a.ERROR, { type: o.b.OTHER_ERROR, details: o.a.INTERNAL_EXCEPTION, fatal: !0, event: 'demuxerWorker', err: { message: `${t.message} (${t.filename}:${t.lineno})` } }); }, c.postMessage({ cmd: 'init', typeSupported: s, vendor: l, id: t, config: JSON.stringify(a) }); } catch (e) { d.b.warn('Error in worker:', e), d.b.error('Error while initializing DemuxerWorker, fallback on DemuxerInline'), c && $.URL.revokeObjectURL(c.objectURL), this.demuxer = new q.a(i, s, a, l), this.w = void 0; } } else this.demuxer = new q.a(i, s, a, l);
} const t = e.prototype; return t.destroy = function() { const e = this.w; if (e)e.removeEventListener('message', this.onwmsg), e.terminate(), this.w = null; else { const t = this.demuxer; t && (t.destroy(), this.demuxer = null); } const r = this.observer; r && (r.removeAllListeners(), this.observer = null); }, t.push = function(e, t, r, i, a, n, s, o) { const u = this.w; const c = Object(l.a)(a.startPTS) ? a.startPTS : a.start; const h = a.decryptdata; const f = this.frag; const g = !(f && a.cc === f.cc); const p = !(f && a.level === f.level); const v = f && a.sn === f.sn + 1; const m = !p && v; if (g && d.b.log(`${this.id}:discontinuity detected`), p && d.b.log(`${this.id}:switch detected`), this.frag = a, u)u.postMessage({ cmd: 'demux', data: e, decryptdata: h, initSegment: t, audioCodec: r, videoCodec: i, timeOffset: c, discontinuity: g, trackSwitch: p, contiguous: m, duration: n, accurateTimeOffset: s, defaultInitPTS: o }, e instanceof ArrayBuffer ? [e] : []); else { const y = this.demuxer; y && y.push(e, h, t, r, i, c, g, p, m, n, s, o); } }, t.onWorkerMessage = function(e) { const t = e.data; const r = this.hls; switch (t.event) { case 'init': $.URL.revokeObjectURL(this.w.objectURL); break; case u.a.FRAG_PARSING_DATA: t.data.data1 = new Uint8Array(t.data1), t.data2 && (t.data.data2 = new Uint8Array(t.data2)); default: t.data = t.data || {}, t.data.frag = this.frag, t.data.id = this.id, r.trigger(t.event, t.data); } }, e;
}()); function ee(e, t, r) { switch (t) { case 'audio': e.audioGroupIds || (e.audioGroupIds = []), e.audioGroupIds.push(r); break; case 'text': e.textGroupIds || (e.textGroupIds = []), e.textGroupIds.push(r); } } function te(e, t, r) { const i = e[t]; const a = e[r]; const n = a.startPTS; Object(l.a)(n) ? r > t ? (i.duration = n - i.start, i.duration < 0 && d.b.warn(`negative duration computed for frag ${i.sn},level ${i.level}, there should be some duration drift between playlist and fragment!`)) : (a.duration = i.start - n, a.duration < 0 && d.b.warn(`negative duration computed for frag ${a.sn},level ${a.level}, there should be some duration drift between playlist and fragment!`)) : a.start = r > t ? i.start + i.duration : Math.max(i.start - a.duration, 0); } function re(e, t, r, i, a, n) { let s = r; if (Object(l.a)(t.startPTS)) { const o = Math.abs(t.startPTS - r); Object(l.a)(t.deltaPTS) ? t.deltaPTS = Math.max(o, t.deltaPTS) : t.deltaPTS = o, s = Math.max(r, t.startPTS), r = Math.min(r, t.startPTS), i = Math.max(i, t.endPTS), a = Math.min(a, t.startDTS), n = Math.max(n, t.endDTS); } const u = r - t.start; t.start = t.startPTS = r, t.maxStartPTS = s, t.endPTS = i, t.startDTS = a, t.endDTS = n, t.duration = i - r; let d; let c; let h; const f = t.sn; if (!e || f < e.startSN || f > e.endSN) return 0; for (d = f - e.startSN, (c = e.fragments)[d] = t, h = d; h > 0; h--)te(c, h, h - 1); for (h = d; h < c.length - 1; h++)te(c, h, h + 1); return e.PTSKnown = !0, u; } function ie(e, t) { t.initSegment && e.initSegment && (t.initSegment = e.initSegment); let r; let i = 0; if (ae(e, t, ((e, a) => { i = e.cc - a.cc, Object(l.a)(e.startPTS) && (a.start = a.startPTS = e.startPTS, a.endPTS = e.endPTS, a.duration = e.duration, a.backtracked = e.backtracked, a.dropped = e.dropped, r = a), t.PTSKnown = !0; })), t.PTSKnown) { if (i) { d.b.log('discontinuity sliding from playlist, take drift into account'); for (let a = t.fragments, n = 0; n < a.length; n++)a[n].cc += i; }r ? re(t, r, r.startPTS, r.endPTS, r.startDTS, r.endDTS) : (function(e, t) { const r = t.startSN - e.startSN; const i = e.fragments; const a = t.fragments; if (r < 0 || r > i.length) return; for (let n = 0; n < a.length; n++)a[n].start += i[r].start; }(e, t)), t.PTSKnown = e.PTSKnown; } } function ae(e, t, r) { if (e && t) for (let i = Math.max(e.startSN, t.startSN) - t.startSN, a = Math.min(e.endSN, t.endSN) - t.startSN, n = t.startSN - e.startSN, s = i; s <= a; s++) { const o = e.fragments[n + s]; const l = t.fragments[s]; if (!o || !l) break; r(o, l, s); } } function ne(e, t, r) { let i = 1e3 * (t.averagetargetduration ? t.averagetargetduration : t.targetduration); const a = i / 2; return e && t.endSN === e.endSN && (i = a), r && (i = Math.max(a, i - (window.performance.now() - r))), Math.round(i); } const se = { toString(e) { for (var t = '', r = e.length, i = 0; i < r; i++)t += `[${e.start(i).toFixed(3)},${e.end(i).toFixed(3)}]`; return t; } }; function oe(e, t) { t.fragments.forEach(((t) => { if (t) { const r = t.start + e; t.start = t.startPTS = r, t.endPTS = r + t.duration; } })), t.PTSKnown = !0; } function le(e, t, r) { !(function(e, t, r) { if (function(e, t, r) { let i = !1; return t && t.details && r && (r.endCC > r.startCC || e && e.cc < r.startCC) && (i = !0), i; }(e, r, t)) { const i = (function(e, t) { const r = e.fragments; const i = t.fragments; if (i.length && r.length) { const a = (function(e, t) { for (var r = null, i = 0; i < e.length; i += 1) { const a = e[i]; if (a && a.cc === t) { r = a; break; } } return r; }(r, i[0].cc)); if (a && (!a || a.startPTS)) return a; d.b.log('No frag in previous level to align on'); } else d.b.log('No fragments to align'); }(r.details, t)); i && (d.b.log('Adjusting PTS using last level due to CC increase within current level'), oe(i.start, t)); } }(e, r, t)), !r.PTSKnown && t && (function(e, t) { if (t && t.fragments.length) { if (!e.hasProgramDateTime || !t.hasProgramDateTime) return; const r = t.fragments[0].programDateTime; const i = (e.fragments[0].programDateTime - r) / 1e3 + t.fragments[0].start; Object(l.a)(i) && (d.b.log(`adjusting PTS using programDateTime delta, sliding:${i.toFixed(3)}`), oe(i, e)); } }(r, t.details)); } function ue(e, t, r) { if (t === null || !Array.isArray(e) || !e.length || !Object(l.a)(t)) return null; if (t < (e[0].programDateTime || 0)) return null; if (t >= (e[e.length - 1].endProgramDateTime || 0)) return null; r = r || 0; for (let i = 0; i < e.length; ++i) { const a = e[i]; if (he(t, r, a)) return a; } return null; } function de(e, t, r, i) { void 0 === r && (r = 0), void 0 === i && (i = 0); const a = e ? t[e.sn - t[0].sn + 1] : null; return a && !ce(r, i, a) ? a : H.search(t, ce.bind(null, r, i)); } function ce(e, t, r) { void 0 === e && (e = 0), void 0 === t && (t = 0); const i = Math.min(t, r.duration + (r.deltaPTS ? r.deltaPTS : 0)); return r.start + r.duration - i <= e ? 1 : r.start - i > e && r.start ? -1 : 0; } function he(e, t, r) { const i = 1e3 * Math.min(t, r.duration + (r.deltaPTS ? r.deltaPTS : 0)); return (r.endProgramDateTime || 0) - i > e; } const fe = (function() { function e(e, t, r, i) { this.config = e, this.media = t, this.fragmentTracker = r, this.hls = i, this.nudgeRetry = 0, this.stallReported = !1, this.stalled = null, this.moved = !1, this.seeking = !1; } const t = e.prototype; return t.poll = function(e) { const t = this.config; const r = this.media; const i = this.stalled; const a = r.currentTime; const n = r.seeking; const s = this.seeking && !n; const o = !this.seeking && n; if (this.seeking = n, a === e) { if ((o || s) && (this.stalled = null), !r.paused && !r.ended && r.playbackRate !== 0 && r.buffered.length) { const l = V.bufferInfo(r, a, 0); const u = l.len > 0; const c = l.nextStart || 0; if (u || c) { if (n) { if (l.len > 2 || (!c || c - a > 2)) return; this.moved = !1; } if (!this.moved && this.stalled) { const h = Math.max(c, l.start || 0) - a; if (h > 0 && h <= 2) return void this._trySkipBufferHole(null); } const f = self.performance.now(); if (i !== null) { const g = f - i; !n && g >= 250 && this._reportStall(l.len); const p = V.bufferInfo(r, a, t.maxBufferHole); this._tryFixBufferStall(p, g); } else this.stalled = f; } } } else if (this.moved = !0, i !== null) { if (this.stallReported) { const v = self.performance.now() - i; d.b.warn(`playback not stuck anymore @${a}, after ${Math.round(v)}ms`), this.stallReported = !1; } this.stalled = null, this.nudgeRetry = 0; } }, t._tryFixBufferStall = function(e, t) { const r = this.config; const i = this.fragmentTracker; const a = this.media.currentTime; const n = i.getPartialFragment(a); if (n && this._trySkipBufferHole(n)) return; e.len > r.maxBufferHole && t > 1e3 * r.highBufferWatchdogPeriod && (d.b.warn('Trying to nudge playhead over buffer-hole'), this.stalled = null, this._tryNudgeBuffer()); }, t._reportStall = function(e) { const t = this.hls; const r = this.media; this.stallReported || (this.stallReported = !0, d.b.warn(`Playback stalling at @${r.currentTime} due to low buffer`), t.trigger(u.a.ERROR, { type: o.b.MEDIA_ERROR, details: o.a.BUFFER_STALLED_ERROR, fatal: !1, buffer: e })); }, t._trySkipBufferHole = function(e) { for (let t = this.config, r = this.hls, i = this.media, a = i.currentTime, n = 0, s = 0; s < i.buffered.length; s++) { const l = i.buffered.start(s); if (a + t.maxBufferHole >= n && a < l) { const c = Math.max(l + 0.05, i.currentTime + 0.1); return d.b.warn(`skipping hole, adjusting currentTime from ${a} to ${c}`), this.moved = !0, this.stalled = null, i.currentTime = c, e && r.trigger(u.a.ERROR, { type: o.b.MEDIA_ERROR, details: o.a.BUFFER_SEEK_OVER_HOLE, fatal: !1, reason: `fragment loaded with buffer holes, seeking from ${a} to ${c}`, frag: e }), c; }n = i.buffered.end(s); } return 0; }, t._tryNudgeBuffer = function() { const e = this.config; const t = this.hls; const r = this.media; const i = r.currentTime; const a = (this.nudgeRetry || 0) + 1; if (this.nudgeRetry = a, a < e.nudgeMaxRetry) { const n = i + a * e.nudgeOffset; d.b.warn(`Nudging 'currentTime' from ${i} to ${n}`), r.currentTime = n, t.trigger(u.a.ERROR, { type: o.b.MEDIA_ERROR, details: o.a.BUFFER_NUDGE_ON_STALL, fatal: !1 }); } else d.b.error(`Playhead still not moving while enough data buffered @${i} after ${e.nudgeMaxRetry} nudges`), t.trigger(u.a.ERROR, { type: o.b.MEDIA_ERROR, details: o.a.BUFFER_STALLED_ERROR, fatal: !0 }); }, e; }()); function ge(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; } const pe = (function(e) { let t; let r; function i(t) { for (var r, i = arguments.length, a = new Array(i > 1 ? i - 1 : 0), n = 1; n < i; n++)a[n - 1] = arguments[n]; return (r = e.call.apply(e, [this, t].concat(a)) || this)._boundTick = void 0, r._tickTimer = null, r._tickInterval = null, r._tickCallCount = 0, r._boundTick = r.tick.bind(ge(r)), r; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r; const a = i.prototype; return a.onHandlerDestroying = function() { this.clearNextTick(), this.clearInterval(); }, a.hasInterval = function() { return !!this._tickInterval; }, a.hasNextTick = function() { return !!this._tickTimer; }, a.setInterval = function(e) { return !this._tickInterval && (this._tickInterval = self.setInterval(this._boundTick, e), !0); }, a.clearInterval = function() { return !!this._tickInterval && (self.clearInterval(this._tickInterval), this._tickInterval = null, !0); }, a.clearNextTick = function() { return !!this._tickTimer && (self.clearTimeout(this._tickTimer), this._tickTimer = null, !0); }, a.tick = function() { this._tickCallCount++, this._tickCallCount === 1 && (this.doTick(), this._tickCallCount > 1 && (this.clearNextTick(), this._tickTimer = self.setTimeout(this._boundTick, 0)), this._tickCallCount = 0); }, a.doTick = function() {}, i; }(h)); const ve = 'STOPPED'; const me = 'STARTING'; const ye = 'IDLE'; const be = 'PAUSED'; const Te = 'KEY_LOADING'; const Ee = 'FRAG_LOADING'; const Se = 'FRAG_LOADING_WAITING_RETRY'; const _e = 'WAITING_TRACK'; const Ae = 'PARSING'; const Re = 'PARSED'; const we = 'BUFFER_FLUSHING'; const ke = 'ENDED'; const Le = 'ERROR'; const De = 'WAITING_INIT_PTS'; const Ce = 'WAITING_LEVEL'; const Ie = (function(e) { let t; let r; function i() { return e.apply(this, arguments) || this; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r; const a = i.prototype; return a.doTick = function() {}, a.startLoad = function() {}, a.stopLoad = function() { const e = this.fragCurrent; e && (e.loader && e.loader.abort(), this.fragmentTracker.removeFragment(e)), this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.fragCurrent = null, this.fragPrevious = null, this.clearInterval(), this.clearNextTick(), this.state = ve; }, a._streamEnded = function(e, t) { const r = this.fragCurrent; const i = this.fragmentTracker; if (!t.live && r && !r.backtracked && r.sn === t.endSN && !e.nextStart) { const a = i.getState(r); return a === G || a === K; } return !1; }, a.onMediaSeeking = function() { const e = this.config; const t = this.media; const r = this.mediaBuffer; const i = this.state; const a = t ? t.currentTime : null; const n = V.bufferInfo(r || t, a, this.config.maxBufferHole); if (Object(l.a)(a) && d.b.log(`media seeking to ${a.toFixed(3)}`), i === Ee) { const s = this.fragCurrent; if (n.len === 0 && s) { const o = e.maxFragLookUpTolerance; const u = s.start - o; const c = s.start + s.duration + o; a < u || a > c ? (s.loader && (d.b.log('seeking outside of buffer while fragment load in progress, cancel fragment load'), s.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.state = ye) : d.b.log('seeking outside of buffer but within currently loaded fragment range'); } } else i === ke && (n.len === 0 && (this.fragPrevious = null, this.fragCurrent = null), this.state = ye); t && (this.lastCurrentTime = a), this.loadedmetadata || (this.nextLoadPosition = this.startPosition = a), this.tick(); }, a.onMediaEnded = function() { this.startPosition = this.lastCurrentTime = 0; }, a.onHandlerDestroying = function() { this.stopLoad(), e.prototype.onHandlerDestroying.call(this); }, a.onHandlerDestroyed = function() { this.state = ve, this.fragmentTracker = null; }, a.computeLivePosition = function(e, t) { const r = void 0 !== this.config.liveSyncDuration ? this.config.liveSyncDuration : this.config.liveSyncDurationCount * t.targetduration; return e + Math.max(0, t.totalduration - r); }, i; }(pe)); function Oe(e, t) { for (let r = 0; r < t.length; r++) { const i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } } const xe = (function(e) { let t; let r; function i(t, r) { let i; return (i = e.call(this, t, u.a.MEDIA_ATTACHED, u.a.MEDIA_DETACHING, u.a.MANIFEST_LOADING, u.a.MANIFEST_PARSED, u.a.LEVEL_LOADED, u.a.KEY_LOADED, u.a.FRAG_LOADED, u.a.FRAG_LOAD_EMERGENCY_ABORTED, u.a.FRAG_PARSING_INIT_SEGMENT, u.a.FRAG_PARSING_DATA, u.a.FRAG_PARSED, u.a.ERROR, u.a.AUDIO_TRACK_SWITCHING, u.a.AUDIO_TRACK_SWITCHED, u.a.BUFFER_CREATED, u.a.BUFFER_APPENDED, u.a.BUFFER_FLUSHED) || this).fragmentTracker = r, i.config = t.config, i.audioCodecSwap = !1, i._state = ve, i.stallReported = !1, i.gapController = null, i.altAudio = !1, i; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r; let a; let s; let c; const h = i.prototype; return h.startLoad = function(e) { if (this.levels) { const t = this.lastCurrentTime; const r = this.hls; if (this.stopLoad(), this.setInterval(100), this.level = -1, this.fragLoadError = 0, !this.startFragRequested) { let i = r.startLevel; i === -1 && (i = 0, this.bitrateTest = !0), this.level = r.nextLoadLevel = i, this.loadedmetadata = !1; }t > 0 && e === -1 && (d.b.log(`override startPosition with lastCurrentTime @${t.toFixed(3)}`), e = t), this.state = ye, this.nextLoadPosition = this.startPosition = this.lastCurrentTime = e, this.tick(); } else this.forceStartLoad = !0, this.state = ve; }, h.stopLoad = function() { this.forceStartLoad = !1, e.prototype.stopLoad.call(this); }, h.doTick = function() { switch (this.state) { case we: this.fragLoadError = 0; break; case ye: this._doTickIdle(); break; case Ce: var e = this.levels[this.level]; e && e.details && (this.state = ye); break; case Se: var t = window.performance.now(); var r = this.retryDate; (!r || t >= r || this.media && this.media.seeking) && (d.b.log('mediaController: retryDate reached, switch back to IDLE state'), this.state = ye); } this._checkBuffer(), this._checkFragmentChanged(); }, h._doTickIdle = function() { const e = this.hls; const t = e.config; const r = this.media; if (void 0 !== this.levelLastLoaded && (r || !this.startFragRequested && t.startFragPrefetch)) { let i; i = this.loadedmetadata ? r.currentTime : this.nextLoadPosition; const a = e.nextLoadLevel; const n = this.levels[a]; if (n) { let s; const o = n.bitrate; s = o ? Math.max(8 * t.maxBufferSize / o, t.maxBufferLength) : t.maxBufferLength, s = Math.min(s, t.maxMaxBufferLength); const l = V.bufferInfo(this.mediaBuffer ? this.mediaBuffer : r, i, t.maxBufferHole); const c = l.len; if (!(c >= s)) { d.b.trace(`buffer length of ${c.toFixed(3)} is below max of ${s.toFixed(3)}. checking for more payload ...`), this.level = e.nextLoadLevel = a; const h = n.details; if (!h || h.live && this.levelLastLoaded !== a) this.state = Ce; else { if (this._streamEnded(l, h)) { const f = {}; return this.altAudio && (f.type = 'video'), this.hls.trigger(u.a.BUFFER_EOS, f), void (this.state = ke); } this._fetchPayloadOrEos(i, l, h); } } } } }, h._fetchPayloadOrEos = function(e, t, r) { const i = this.fragPrevious; const a = this.level; const n = r.fragments; const s = n.length; if (s !== 0) { let o; const l = n[0].start; const u = n[s - 1].start + n[s - 1].duration; const c = t.end; if (r.initSegment && !r.initSegment.data)o = r.initSegment; else if (r.live) { const h = this.config.initialLiveManifestSize; if (s < h) return void d.b.warn(`Can not start playback of a level, reason: not enough fragments ${s} < ${h}`); if ((o = this._ensureFragmentAtLivePoint(r, c, l, u, i, n, s)) === null) return; } else c < l && (o = n[0]); o || (o = this._findFragment(l, i, s, n, c, u, r)), o && (o.encrypted ? (d.b.log(`Loading key for ${o.sn} of [${r.startSN} ,${r.endSN}],level ${a}`), this._loadKey(o)) : (d.b.log(`Loading ${o.sn} of [${r.startSN} ,${r.endSN}],level ${a}, currentTime:${e.toFixed(3)},bufferEnd:${c.toFixed(3)}`), this._loadFragment(o))); } }, h._ensureFragmentAtLivePoint = function(e, t, r, i, a, n, s) { let o; const l = this.hls.config; const u = this.media; const c = void 0 !== l.liveMaxLatencyDuration ? l.liveMaxLatencyDuration : l.liveMaxLatencyDurationCount * e.targetduration; if (t < Math.max(r - l.maxFragLookUpTolerance, i - c)) { const h = this.liveSyncPosition = this.computeLivePosition(r, e); t = h, u && !u.paused && u.readyState && u.duration > h && h > u.currentTime && (d.b.log(`buffer end: ${t.toFixed(3)} is located too far from the end of live sliding playlist, reset currentTime to : ${h.toFixed(3)}`), u.currentTime = h), this.nextLoadPosition = h; } if (e.PTSKnown && t > i && u && u.readyState) return null; if (this.startFragRequested && !e.PTSKnown) { if (a) if (e.hasProgramDateTime)d.b.log(`live playlist, switching playlist, load frag with same PDT: ${a.programDateTime}`), o = ue(n, a.endProgramDateTime, l.maxFragLookUpTolerance); else { const f = a.sn + 1; if (f >= e.startSN && f <= e.endSN) { const g = n[f - e.startSN]; a.cc === g.cc && (o = g, d.b.log(`live playlist, switching playlist, load frag with next SN: ${o.sn}`)); }o || (o = H.search(n, ((e) => a.cc - e.cc))) && d.b.log(`live playlist, switching playlist, load frag with same CC: ${o.sn}`); }o || (o = n[Math.min(s - 1, Math.round(s / 2))], d.b.log(`live playlist, switching playlist, unknown, load middle frag : ${o.sn}`)); } return o; }, h._findFragment = function(e, t, r, i, a, n, s) { let o; const l = this.hls.config; a < n ? o = de(t, i, a, a > n - l.maxFragLookUpTolerance ? 0 : l.maxFragLookUpTolerance) : o = i[r - 1]; if (o) { const u = o.sn - s.startSN; const c = t && o.level === t.level; const h = i[u - 1]; const f = i[u + 1]; if (t && o.sn === t.sn) if (c && !o.backtracked) if (o.sn < s.endSN) { const g = t.deltaPTS; g && g > l.maxBufferHole && t.dropped && u ? (o = h, d.b.warn('Previous fragment was dropped with large PTS gap between audio and video. Maybe fragment is not starting with a keyframe? Loading previous one to try to overcome this')) : (o = f, d.b.log(`Re-loading fragment with SN: ${o.sn}`)); } else o = null; else o.backtracked && (f && f.backtracked ? (d.b.warn(`Already backtracked from fragment ${f.sn}, will not backtrack to fragment ${o.sn}. Loading fragment ${f.sn}`), o = f) : (d.b.warn('Loaded fragment with dropped frames, backtracking 1 segment to find a keyframe'), o.dropped = 0, h ? (o = h).backtracked = !0 : u && (o = null))); } return o; }, h._loadKey = function(e) { this.state = Te, this.hls.trigger(u.a.KEY_LOADING, { frag: e }); }, h._loadFragment = function(e) { const t = this.fragmentTracker.getState(e); this.fragCurrent = e, e.sn !== 'initSegment' && (this.startFragRequested = !0), Object(l.a)(e.sn) && !e.bitrateTest && (this.nextLoadPosition = e.start + e.duration), e.backtracked || t === N || t === G ? (e.autoLevel = this.hls.autoLevelEnabled, e.bitrateTest = this.bitrateTest, this.hls.trigger(u.a.FRAG_LOADING, { frag: e }), this.demuxer || (this.demuxer = new Z(this.hls, 'main')), this.state = Ee) : t === B && this._reduceMaxBufferLength(e.duration) && this.fragmentTracker.removeFragment(e); }, h.getBufferedFrag = function(e) { return this.fragmentTracker.getBufferedFrag(e, n.MAIN); }, h.followingBufferedFrag = function(e) { return e ? this.getBufferedFrag(e.endPTS + 0.5) : null; }, h._checkFragmentChanged = function() { let e; let t; const r = this.media; if (r && r.readyState && !1 === r.seeking && ((t = r.currentTime) > this.lastCurrentTime && (this.lastCurrentTime = t), V.isBuffered(r, t) ? e = this.getBufferedFrag(t) : V.isBuffered(r, t + 0.1) && (e = this.getBufferedFrag(t + 0.1)), e)) { const i = e; if (i !== this.fragPlaying) { this.hls.trigger(u.a.FRAG_CHANGED, { frag: i }); const a = i.level; this.fragPlaying && this.fragPlaying.level === a || this.hls.trigger(u.a.LEVEL_SWITCHED, { level: a }), this.fragPlaying = i; } } }, h.immediateLevelSwitch = function() { if (d.b.log('immediateLevelSwitch'), !this.immediateSwitch) { this.immediateSwitch = !0; let e; const t = this.media; t ? (e = t.paused, t.pause()) : e = !0, this.previouslyPaused = e; } const r = this.fragCurrent; r && r.loader && r.loader.abort(), this.fragCurrent = null, this.flushMainBuffer(0, Number.POSITIVE_INFINITY); }, h.immediateLevelSwitchEnd = function() { const e = this.media; e && e.buffered.length && (this.immediateSwitch = !1, V.isBuffered(e, e.currentTime) && (e.currentTime -= 1e-4), this.previouslyPaused || e.play()); }, h.nextLevelSwitch = function() { const e = this.media; if (e && e.readyState) { let t; let r; let i; if ((r = this.getBufferedFrag(e.currentTime)) && r.startPTS > 1 && this.flushMainBuffer(0, r.startPTS - 1), e.paused)t = 0; else { const a = this.hls.nextLoadLevel; const n = this.levels[a]; const s = this.fragLastKbps; t = s && this.fragCurrent ? this.fragCurrent.duration * n.bitrate / (1e3 * s) + 1 : 0; } if ((i = this.getBufferedFrag(e.currentTime + t)) && (i = this.followingBufferedFrag(i))) { const o = this.fragCurrent; o && o.loader && o.loader.abort(), this.fragCurrent = null, this.flushMainBuffer(i.maxStartPTS, Number.POSITIVE_INFINITY); } } }, h.flushMainBuffer = function(e, t) { this.state = we; const r = { startOffset: e, endOffset: t }; this.altAudio && (r.type = 'video'), this.hls.trigger(u.a.BUFFER_FLUSHING, r); }, h.onMediaAttached = function(e) { const t = this.media = this.mediaBuffer = e.media; this.onvseeking = this.onMediaSeeking.bind(this), this.onvseeked = this.onMediaSeeked.bind(this), this.onvended = this.onMediaEnded.bind(this), t.addEventListener('seeking', this.onvseeking), t.addEventListener('seeked', this.onvseeked), t.addEventListener('ended', this.onvended); const r = this.config; this.levels && r.autoStartLoad && this.hls.startLoad(r.startPosition), this.gapController = new fe(r, t, this.fragmentTracker, this.hls); }, h.onMediaDetaching = function() { const e = this.media; e && e.ended && (d.b.log('MSE detaching and video ended, reset startPosition'), this.startPosition = this.lastCurrentTime = 0); const t = this.levels; t && t.forEach(((e) => { e.details && e.details.fragments.forEach(((e) => { e.backtracked = void 0; })); })), e && (e.removeEventListener('seeking', this.onvseeking), e.removeEventListener('seeked', this.onvseeked), e.removeEventListener('ended', this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.fragmentTracker.removeAllFragments(), this.media = this.mediaBuffer = null, this.loadedmetadata = !1, this.stopLoad(); }, h.onMediaSeeked = function() { const e = this.media; const t = e ? e.currentTime : void 0; Object(l.a)(t) && d.b.log(`media seeked to ${t.toFixed(3)}`), this.tick(); }, h.onManifestLoading = function() { d.b.log('trigger BUFFER_RESET'), this.hls.trigger(u.a.BUFFER_RESET), this.fragmentTracker.removeAllFragments(), this.stalled = !1, this.startPosition = this.lastCurrentTime = 0; }, h.onManifestParsed = function(e) { let t; let r = !1; let i = !1; e.levels.forEach(((e) => { (t = e.audioCodec) && (t.indexOf('mp4a.40.2') !== -1 && (r = !0), t.indexOf('mp4a.40.5') !== -1 && (i = !0)); })), this.audioCodecSwitch = r && i, this.audioCodecSwitch && d.b.log('both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC'), this.altAudio = e.altAudio, this.levels = e.levels, this.startFragRequested = !1; const a = this.config; (a.autoStartLoad || this.forceStartLoad) && this.hls.startLoad(a.startPosition); }, h.onLevelLoaded = function(e) { const t = e.details; const r = e.level; const i = this.levels[this.levelLastLoaded]; const a = this.levels[r]; const n = t.totalduration; let s = 0; if (d.b.log(`level ${r} loaded [${t.startSN},${t.endSN}],duration:${n}`), t.live) { const o = a.details; o && t.fragments.length > 0 ? (ie(o, t), s = t.fragments[0].start, this.liveSyncPosition = this.computeLivePosition(s, o), t.PTSKnown && Object(l.a)(s) ? d.b.log(`live playlist sliding:${s.toFixed(3)}`) : (d.b.log('live playlist - outdated PTS, unknown sliding'), le(this.fragPrevious, i, t))) : (d.b.log('live playlist - first load, unknown sliding'), t.PTSKnown = !1, le(this.fragPrevious, i, t)); } else t.PTSKnown = !1; if (a.details = t, this.levelLastLoaded = r, this.hls.trigger(u.a.LEVEL_UPDATED, { details: t, level: r }), !1 === this.startFragRequested) { if (this.startPosition === -1 || this.lastCurrentTime === -1) { let c = t.startTimeOffset; Object(l.a)(c) ? (c < 0 && (d.b.log(`negative start time offset ${c}, count from end of last fragment`), c = s + n + c), d.b.log(`start time offset found in playlist, adjust startPosition to ${c}`), this.startPosition = c) : t.live ? (this.startPosition = this.computeLivePosition(s, t), d.b.log(`configure startPosition to ${this.startPosition}`)) : this.startPosition = 0, this.lastCurrentTime = this.startPosition; } this.nextLoadPosition = this.startPosition; } this.state === Ce && (this.state = ye), this.tick(); }, h.onKeyLoaded = function() { this.state === Te && (this.state = ye, this.tick()); }, h.onFragLoaded = function(e) { const t = this.fragCurrent; const r = this.hls; const i = this.levels; const a = this.media; const n = e.frag; if (this.state === Ee && t && n.type === 'main' && n.level === t.level && n.sn === t.sn) { const s = e.stats; const o = i[t.level]; const l = o.details; if (this.bitrateTest = !1, this.stats = s, d.b.log(`Loaded ${t.sn} of [${l.startSN} ,${l.endSN}],level ${t.level}`), n.bitrateTest && r.nextLoadLevel) this.state = ye, this.startFragRequested = !1, s.tparsed = s.tbuffered = window.performance.now(), r.trigger(u.a.FRAG_BUFFERED, { stats: s, frag: t, id: 'main' }), this.tick(); else if (n.sn === 'initSegment') this.state = ye, s.tparsed = s.tbuffered = window.performance.now(), l.initSegment.data = e.payload, r.trigger(u.a.FRAG_BUFFERED, { stats: s, frag: t, id: 'main' }), this.tick(); else { d.b.log(`Parsing ${t.sn} of [${l.startSN} ,${l.endSN}],level ${t.level}, cc ${t.cc}`), this.state = Ae, this.pendingBuffering = !0, this.appended = !1, n.bitrateTest && (n.bitrateTest = !1, this.fragmentTracker.onFragLoaded({ frag: n })); const c = !(a && a.seeking) && (l.PTSKnown || !l.live); const h = l.initSegment ? l.initSegment.data : []; const f = this._getAudioCodec(o); (this.demuxer = this.demuxer || new Z(this.hls, 'main')).push(e.payload, h, f, o.videoCodec, t, l.totalduration, c); } } this.fragLoadError = 0; }, h.onFragParsingInitSegment = function(e) { const t = this.fragCurrent; const r = e.frag; if (t && e.id === 'main' && r.sn === t.sn && r.level === t.level && this.state === Ae) { let i; let a; const n = e.tracks; if (n.audio && this.altAudio && delete n.audio, a = n.audio) { let s = this.levels[this.level].audioCodec; const o = navigator.userAgent.toLowerCase(); s && this.audioCodecSwap && (d.b.log('swapping playlist audio codec'), s = s.indexOf('mp4a.40.5') !== -1 ? 'mp4a.40.2' : 'mp4a.40.5'), this.audioCodecSwitch && a.metadata.channelCount !== 1 && o.indexOf('firefox') === -1 && (s = 'mp4a.40.5'), o.indexOf('android') !== -1 && a.container !== 'audio/mpeg' && (s = 'mp4a.40.2', d.b.log(`Android: force audio codec to ${s}`)), a.levelCodec = s, a.id = e.id; } for (i in (a = n.video) && (a.levelCodec = this.levels[this.level].videoCodec, a.id = e.id), this.hls.trigger(u.a.BUFFER_CODECS, n), n) { a = n[i], d.b.log(`main track:${i},container:${a.container},codecs[level/parsed]=[${a.levelCodec}/${a.codec}]`); const l = a.initSegment; l && (this.appended = !0, this.pendingBuffering = !0, this.hls.trigger(u.a.BUFFER_APPENDING, { type: i, data: l, parent: 'main', content: 'initSegment' })); } this.tick(); } }, h.onFragParsingData = function(e) { const t = this; const r = this.fragCurrent; const i = e.frag; if (r && e.id === 'main' && i.sn === r.sn && i.level === r.level && (e.type !== 'audio' || !this.altAudio) && this.state === Ae) { const a = this.levels[this.level]; const n = r; if (Object(l.a)(e.endPTS) || (e.endPTS = e.startPTS + r.duration, e.endDTS = e.startDTS + r.duration), !0 === e.hasAudio && n.addElementaryStream(p.AUDIO), !0 === e.hasVideo && n.addElementaryStream(p.VIDEO), d.b.log(`Parsed ${e.type},PTS:[${e.startPTS.toFixed(3)},${e.endPTS.toFixed(3)}],DTS:[${e.startDTS.toFixed(3)}/${e.endDTS.toFixed(3)}],nb:${e.nb},dropped:${e.dropped || 0}`), e.type === 'video') if (n.dropped = e.dropped, n.dropped) if (n.backtracked)d.b.warn('Already backtracked on this fragment, appending with the gap', n.sn); else { const s = a.details; if (!s || n.sn !== s.startSN) return d.b.warn('missing video frame(s), backtracking fragment', n.sn), this.fragmentTracker.removeFragment(n), n.backtracked = !0, this.nextLoadPosition = e.startPTS, this.state = ye, this.fragPrevious = n, void this.tick(); d.b.warn('missing video frame(s) on first frag, appending with gap', n.sn); } else n.backtracked = !1; const o = re(a.details, n, e.startPTS, e.endPTS, e.startDTS, e.endDTS); const c = this.hls; c.trigger(u.a.LEVEL_PTS_UPDATED, { details: a.details, level: this.level, drift: o, type: e.type, start: e.startPTS, end: e.endPTS }), [e.data1, e.data2].forEach(((r) => { r && r.length && t.state === Ae && (t.appended = !0, t.pendingBuffering = !0, c.trigger(u.a.BUFFER_APPENDING, { type: e.type, data: r, parent: 'main', content: 'data' })); })), this.tick(); } }, h.onFragParsed = function(e) { const t = this.fragCurrent; const r = e.frag; t && e.id === 'main' && r.sn === t.sn && r.level === t.level && this.state === Ae && (this.stats.tparsed = window.performance.now(), this.state = Re, this._checkAppendedParsed()); }, h.onAudioTrackSwitching = function(e) { const t = !!e.url; const r = e.id; if (!t) { if (this.mediaBuffer !== this.media) { d.b.log('switching on main audio, use media.buffered to schedule main fragment loading'), this.mediaBuffer = this.media; const i = this.fragCurrent; i.loader && (d.b.log('switching to main audio track, cancel main fragment load'), i.loader.abort()), this.fragCurrent = null, this.fragPrevious = null, this.demuxer && (this.demuxer.destroy(), this.demuxer = null), this.state = ye; } const a = this.hls; a.trigger(u.a.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' }), a.trigger(u.a.AUDIO_TRACK_SWITCHED, { id: r }), this.altAudio = !1; } }, h.onAudioTrackSwitched = function(e) { const t = e.id; const r = !!this.hls.audioTracks[t].url; if (r) { const i = this.videoBuffer; i && this.mediaBuffer !== i && (d.b.log('switching on alternate audio, use video.buffered to schedule main fragment loading'), this.mediaBuffer = i); } this.altAudio = r, this.tick(); }, h.onBufferCreated = function(e) { let t; let r; const i = e.tracks; let a = !1; for (const n in i) { const s = i[n]; s.id === 'main' ? (r = n, t = s, n === 'video' && (this.videoBuffer = i[n].buffer)) : a = !0; }a && t ? (d.b.log(`alternate track found, use ${r}.buffered to schedule main fragment loading`), this.mediaBuffer = t.buffer) : this.mediaBuffer = this.media; }, h.onBufferAppended = function(e) { if (e.parent === 'main') { const t = this.state; t !== Ae && t !== Re || (this.pendingBuffering = e.pending > 0, this._checkAppendedParsed()); } }, h._checkAppendedParsed = function() { if (!(this.state !== Re || this.appended && this.pendingBuffering)) { const e = this.fragCurrent; if (e) { const t = this.mediaBuffer ? this.mediaBuffer : this.media; d.b.log(`main buffered : ${se.toString(t.buffered)}`), this.fragPrevious = e; const r = this.stats; r.tbuffered = window.performance.now(), this.fragLastKbps = Math.round(8 * r.total / (r.tbuffered - r.tfirst)), this.hls.trigger(u.a.FRAG_BUFFERED, { stats: r, frag: e, id: 'main' }), this.state = ye; } this.tick(); } }, h.onError = function(e) { const t = e.frag || this.fragCurrent; if (!t || t.type === 'main') { const r = !!this.media && V.isBuffered(this.media, this.media.currentTime) && V.isBuffered(this.media, this.media.currentTime + 0.5); switch (e.details) { case o.a.FRAG_LOAD_ERROR: case o.a.FRAG_LOAD_TIMEOUT: case o.a.KEY_LOAD_ERROR: case o.a.KEY_LOAD_TIMEOUT: if (!e.fatal) if (this.fragLoadError + 1 <= this.config.fragLoadingMaxRetry) { const i = Math.min(Math.pow(2, this.fragLoadError) * this.config.fragLoadingRetryDelay, this.config.fragLoadingMaxRetryTimeout); d.b.warn(`mediaController: frag loading failed, retry in ${i} ms`), this.retryDate = window.performance.now() + i, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.fragLoadError++, this.state = Se; } else d.b.error(`mediaController: ${e.details} reaches max retry, redispatch as fatal ...`), e.fatal = !0, this.state = Le; break; case o.a.LEVEL_LOAD_ERROR: case o.a.LEVEL_LOAD_TIMEOUT: this.state !== Le && (e.fatal ? (this.state = Le, d.b.warn(`streamController: ${e.details},switch to ${this.state} state ...`)) : e.levelRetry || this.state !== Ce || (this.state = ye)); break; case o.a.BUFFER_FULL_ERROR: e.parent !== 'main' || this.state !== Ae && this.state !== Re || (r ? (this._reduceMaxBufferLength(this.config.maxBufferLength), this.state = ye) : (d.b.warn('buffer full error also media.currentTime is not buffered, flush everything'), this.fragCurrent = null, this.flushMainBuffer(0, Number.POSITIVE_INFINITY))); } } }, h._reduceMaxBufferLength = function(e) { const t = this.config; return t.maxMaxBufferLength >= e && (t.maxMaxBufferLength /= 2, d.b.warn(`main:reduce max buffer length to ${t.maxMaxBufferLength}s`), !0); }, h._checkBuffer = function() { const e = this.media; if (e && e.readyState !== 0) { const t = (this.mediaBuffer ? this.mediaBuffer : e).buffered; !this.loadedmetadata && t.length ? (this.loadedmetadata = !0, this._seekToStartPos()) : this.immediateSwitch ? this.immediateLevelSwitchEnd() : this.gapController.poll(this.lastCurrentTime, t); } }, h.onFragLoadEmergencyAborted = function() { this.state = ye, this.loadedmetadata || (this.startFragRequested = !1, this.nextLoadPosition = this.startPosition), this.tick(); }, h.onBufferFlushed = function() { const e = this.mediaBuffer ? this.mediaBuffer : this.media; e && this.fragmentTracker.detectEvictedFragments(p.VIDEO, e.buffered), this.state = ye, this.fragPrevious = null; }, h.swapAudioCodec = function() { this.audioCodecSwap = !this.audioCodecSwap; }, h._seekToStartPos = function() { const e = this.media; const t = e.currentTime; const r = e.seeking ? t : this.startPosition; t !== r && r >= 0 && (d.b.log(`target start position not buffered, seek to buffered.start(0) ${r} from current time ${t} `), e.currentTime = r); }, h._getAudioCodec = function(e) { let t = this.config.defaultAudioCodec || e.audioCodec; return this.audioCodecSwap && (d.b.log('swapping playlist audio codec'), t && (t = t.indexOf('mp4a.40.5') !== -1 ? 'mp4a.40.2' : 'mp4a.40.5')), t; }, a = i, (s = [{ key: 'state', set(e) { if (this.state !== e) { const t = this.state; this._state = e, d.b.log(`main stream-controller: ${t}->${e}`), this.hls.trigger(u.a.STREAM_STATE_TRANSITION, { previousState: t, nextState: e }); } }, get() { return this._state; } }, { key: 'currentLevel', get() { const e = this.media; if (e) { const t = this.getBufferedFrag(e.currentTime); if (t) return t.level; } return -1; } }, { key: 'nextBufferedFrag', get() { const e = this.media; return e ? this.followingBufferedFrag(this.getBufferedFrag(e.currentTime)) : null; } }, { key: 'nextLevel', get() { const e = this.nextBufferedFrag; return e ? e.level : -1; } }, { key: 'liveSyncPosition', get() { return this._liveSyncPosition; }, set(e) { this._liveSyncPosition = e; } }]) && Oe(a.prototype, s), c && Oe(a, c), i; }(Ie)); function Pe(e, t) { for (let r = 0; r < t.length; r++) { const i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } }window.performance; let Me; const Fe = (function(e) { let t; let r; function i(t) { let r; return (r = e.call(this, t, u.a.MANIFEST_LOADED, u.a.LEVEL_LOADED, u.a.AUDIO_TRACK_SWITCHED, u.a.FRAG_LOADED, u.a.ERROR) || this).canload = !1, r.currentLevelIndex = null, r.manualLevelIndex = -1, r.timer = null, Me = /chrome|firefox/.test(navigator.userAgent.toLowerCase()), r; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r; let a; let n; let s; const l = i.prototype; return l.onHandlerDestroying = function() { this.clearTimer(), this.manualLevelIndex = -1; }, l.clearTimer = function() { this.timer !== null && (clearTimeout(this.timer), this.timer = null); }, l.startLoad = function() { const e = this._levels; this.canload = !0, this.levelRetryCount = 0, e && e.forEach(((e) => { e.loadError = 0; const t = e.details; t && t.live && (e.details = void 0); })), this.timer !== null && this.loadLevel(); }, l.stopLoad = function() { this.canload = !1; }, l.onManifestLoaded = function(e) { let t; let r = []; let i = []; const a = {}; let n = null; let s = !1; let l = !1; if (e.levels.forEach(((e) => { const t = e.attrs; e.loadError = 0, e.fragmentError = !1, s = s || !!e.videoCodec, l = l || !!e.audioCodec, Me && e.audioCodec && e.audioCodec.indexOf('mp4a.40.34') !== -1 && (e.audioCodec = void 0), (n = a[e.bitrate]) ? n.url.push(e.url) : (e.url = [e.url], e.urlId = 0, a[e.bitrate] = e, r.push(e)), t && (t.AUDIO && (l = !0, ee(n || e, 'audio', t.AUDIO)), t.SUBTITLES && ee(n || e, 'text', t.SUBTITLES)); })), s && l && (r = r.filter(((e) => !!e.videoCodec))), r = r.filter(((e) => { const t = e.audioCodec; const r = e.videoCodec; return (!t || R(t, 'audio')) && (!r || R(r, 'video')); })), e.audioTracks && (i = e.audioTracks.filter(((e) => !e.audioCodec || R(e.audioCodec, 'audio')))).forEach(((e, t) => { e.id = t; })), r.length > 0) { t = r[0].bitrate, r.sort(((e, t) => e.bitrate - t.bitrate)), this._levels = r; for (let c = 0; c < r.length; c++) if (r[c].bitrate === t) { this._firstLevel = c, d.b.log(`manifest loaded,${r.length} level(s) found, first bitrate:${t}`); break; } this.hls.trigger(u.a.MANIFEST_PARSED, { levels: r, audioTracks: i, firstLevel: this._firstLevel, stats: e.stats, audio: l, video: s, altAudio: i.some(((e) => !!e.url)) }); } else this.hls.trigger(u.a.ERROR, { type: o.b.MEDIA_ERROR, details: o.a.MANIFEST_INCOMPATIBLE_CODECS_ERROR, fatal: !0, url: this.hls.url, reason: 'no level with compatible codecs found in manifest' }); }, l.setLevelInternal = function(e) { const t = this._levels; const r = this.hls; if (e >= 0 && e < t.length) { if (this.clearTimer(), this.currentLevelIndex !== e) { d.b.log(`switching to level ${e}`), this.currentLevelIndex = e; const i = t[e]; i.level = e, r.trigger(u.a.LEVEL_SWITCHING, i); } const a = t[e]; const n = a.details; if (!n || n.live) { const s = a.urlId; r.trigger(u.a.LEVEL_LOADING, { url: a.url[s], level: e, id: s }); } } else r.trigger(u.a.ERROR, { type: o.b.OTHER_ERROR, details: o.a.LEVEL_SWITCH_ERROR, level: e, fatal: !1, reason: 'invalid level idx' }); }, l.onError = function(e) { if (e.fatal)e.type === o.b.NETWORK_ERROR && this.clearTimer(); else { let t; let r = !1; let i = !1; switch (e.details) { case o.a.FRAG_LOAD_ERROR: case o.a.FRAG_LOAD_TIMEOUT: case o.a.KEY_LOAD_ERROR: case o.a.KEY_LOAD_TIMEOUT: t = e.frag.level, i = !0; break; case o.a.LEVEL_LOAD_ERROR: case o.a.LEVEL_LOAD_TIMEOUT: t = e.context.level, r = !0; break; case o.a.REMUX_ALLOC_ERROR: t = e.level, r = !0; } void 0 !== t && this.recoverLevel(e, t, r, i); } }, l.recoverLevel = function(e, t, r, i) { let a; let n; let s; const o = this; const l = this.hls.config; const u = e.details; const c = this._levels[t]; if (c.loadError++, c.fragmentError = i, r) { if (!(this.levelRetryCount + 1 <= l.levelLoadingMaxRetry)) return d.b.error(`level controller, cannot recover from ${u} error`), this.currentLevelIndex = null, this.clearTimer(), void (e.fatal = !0); n = Math.min(Math.pow(2, this.levelRetryCount) * l.levelLoadingRetryDelay, l.levelLoadingMaxRetryTimeout), this.timer = setTimeout((() => o.loadLevel()), n), e.levelRetry = !0, this.levelRetryCount++, d.b.warn(`level controller, ${u}, retry in ${n} ms, current retry count is ${this.levelRetryCount}`); }(r || i) && ((a = c.url.length) > 1 && c.loadError < a ? (c.urlId = (c.urlId + 1) % a, c.details = void 0, d.b.warn(`level controller, ${u} for level ${t}: switching to redundant URL-id ${c.urlId}`)) : this.manualLevelIndex === -1 ? (s = t === 0 ? this._levels.length - 1 : t - 1, d.b.warn(`level controller, ${u}: switch to ${s}`), this.hls.nextAutoLevel = this.currentLevelIndex = s) : i && (d.b.warn(`level controller, ${u}: reload a fragment`), this.currentLevelIndex = null)); }, l.onFragLoaded = function(e) { const t = e.frag; if (void 0 !== t && t.type === 'main') { const r = this._levels[t.level]; void 0 !== r && (r.fragmentError = !1, r.loadError = 0, this.levelRetryCount = 0); } }, l.onLevelLoaded = function(e) { const t = this; const r = e.level; const i = e.details; if (r === this.currentLevelIndex) { const a = this._levels[r]; if (a.fragmentError || (a.loadError = 0, this.levelRetryCount = 0), i.live) { const n = ne(a.details, i, e.stats.trequest); d.b.log(`live playlist, reload in ${Math.round(n)} ms`), this.timer = setTimeout((() => t.loadLevel()), n); } else this.clearTimer(); } }, l.onAudioTrackSwitched = function(e) { const t = this.hls.audioTracks[e.id].groupId; const r = this.hls.levels[this.currentLevelIndex]; if (r && r.audioGroupIds) { for (var i = -1, a = 0; a < r.audioGroupIds.length; a++) if (r.audioGroupIds[a] === t) { i = a; break; }i !== r.urlId && (r.urlId = i, this.startLoad()); } }, l.loadLevel = function() { if (d.b.debug('call to loadLevel'), this.currentLevelIndex !== null && this.canload) { const e = this._levels[this.currentLevelIndex]; if (typeof e === 'object' && e.url.length > 0) { const t = this.currentLevelIndex; const r = e.urlId; const i = e.url[r]; d.b.log(`Attempt loading level index ${t} with URL-id ${r}`), this.hls.trigger(u.a.LEVEL_LOADING, { url: i, level: t, id: r }); } } }, a = i, (n = [{ key: 'levels', get() { return this._levels; } }, { key: 'level', get() { return this.currentLevelIndex; }, set(e) { const t = this._levels; t && (e = Math.min(e, t.length - 1), this.currentLevelIndex === e && t[e].details || this.setLevelInternal(e)); } }, { key: 'manualLevel', get() { return this.manualLevelIndex; }, set(e) { this.manualLevelIndex = e, void 0 === this._startLevel && (this._startLevel = e), e !== -1 && (this.level = e); } }, { key: 'firstLevel', get() { return this._firstLevel; }, set(e) { this._firstLevel = e; } }, { key: 'startLevel', get() { if (void 0 === this._startLevel) { const e = this.hls.config.startLevel; return void 0 !== e ? e : this._firstLevel; } return this._startLevel; }, set(e) { this._startLevel = e; } }, { key: 'nextLoadLevel', get() { return this.manualLevelIndex !== -1 ? this.manualLevelIndex : this.hls.nextAutoLevel; }, set(e) { this.level = e, this.manualLevelIndex === -1 && (this.hls.nextAutoLevel = e); } }]) && Pe(a.prototype, n), s && Pe(a, s), i; }(h)); const Ue = r(4); function Ne(e, t) { let r; try { r = new Event('addtrack'); } catch (e) { (r = document.createEvent('Event')).initEvent('addtrack', !1, !1); }r.track = e, t.dispatchEvent(r); } function Be(e) { if (e && e.cues) for (;e.cues.length > 0;)e.removeCue(e.cues[0]); } const Ge = (function(e) { let t; let r; function i(t) { let r; return (r = e.call(this, t, u.a.MEDIA_ATTACHED, u.a.MEDIA_DETACHING, u.a.FRAG_PARSING_METADATA, u.a.LIVE_BACK_BUFFER_REACHED) || this).id3Track = void 0, r.media = void 0, r; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r; const a = i.prototype; return a.destroy = function() { h.prototype.destroy.call(this); }, a.onMediaAttached = function(e) { this.media = e.media, this.media; }, a.onMediaDetaching = function() { Be(this.id3Track), this.id3Track = void 0, this.media = void 0; }, a.getID3Track = function(e) { for (let t = 0; t < e.length; t++) { const r = e[t]; if (r.kind === 'metadata' && r.label === 'id3') return Ne(r, this.media), r; } return this.media.addTextTrack('metadata', 'id3'); }, a.onFragParsingMetadata = function(e) { const t = e.frag; const r = e.samples; this.id3Track || (this.id3Track = this.getID3Track(this.media.textTracks), this.id3Track.mode = 'hidden'); for (let i = window.WebKitDataCue || window.VTTCue || window.TextTrackCue, a = 0; a < r.length; a++) { const n = Ue.a.getID3Frames(r[a].data); if (n) { const s = r[a].pts; let o = a < r.length - 1 ? r[a + 1].pts : t.endPTS; s === o ? o += 1e-4 : s > o && (d.b.warn('detected an id3 sample with endTime < startTime, adjusting endTime to (startTime + 0.25)'), o = s + 0.25); for (let l = 0; l < n.length; l++) { const u = n[l]; if (!Ue.a.isTimeStampFrame(u)) { const c = new i(s, o, ''); c.value = u, this.id3Track.addCue(c); } } } } }, a.onLiveBackBufferReached = function(e) { const t = e.bufferEnd; const r = this.id3Track; if (r && r.cues && r.cues.length) { const i = (function(e, t) { if (t < e[0].endTime) return e[0]; if (t > e[e.length - 1].endTime) return e[e.length - 1]; for (var r = 0, i = e.length - 1; r <= i;) { const a = Math.floor((i + r) / 2); if (t < e[a].endTime)i = a - 1; else { if (!(t > e[a].endTime)) return e[a]; r = a + 1; } } return e[r].endTime - t < t - e[i].endTime ? e[r] : e[i]; }(r.cues, t)); if (i) for (;r.cues[0] !== i;)r.removeCue(r.cues[0]); } }, i; }(h)); const Ke = (function() { function e(e) { this.alpha_ = void 0, this.estimate_ = void 0, this.totalWeight_ = void 0, this.alpha_ = e ? Math.exp(Math.log(0.5) / e) : 0, this.estimate_ = 0, this.totalWeight_ = 0; } const t = e.prototype; return t.sample = function(e, t) { const r = Math.pow(this.alpha_, e); this.estimate_ = t * (1 - r) + r * this.estimate_, this.totalWeight_ += e; }, t.getTotalWeight = function() { return this.totalWeight_; }, t.getEstimate = function() { if (this.alpha_) { const e = 1 - Math.pow(this.alpha_, this.totalWeight_); return this.estimate_ / e; } return this.estimate_; }, e; }()); const je = (function() { function e(e, t, r, i) { this.hls = void 0, this.defaultEstimate_ = void 0, this.minWeight_ = void 0, this.minDelayMs_ = void 0, this.slow_ = void 0, this.fast_ = void 0, this.hls = e, this.defaultEstimate_ = i, this.minWeight_ = 0.001, this.minDelayMs_ = 50, this.slow_ = new Ke(t), this.fast_ = new Ke(r); } const t = e.prototype; return t.sample = function(e, t) { const r = (e = Math.max(e, this.minDelayMs_)) / 1e3; const i = 8 * t / r; this.fast_.sample(r, i), this.slow_.sample(r, i); }, t.canEstimate = function() { const e = this.fast_; return e && e.getTotalWeight() >= this.minWeight_; }, t.getEstimate = function() { return this.canEstimate() ? Math.min(this.fast_.getEstimate(), this.slow_.getEstimate()) : this.defaultEstimate_; }, t.destroy = function() {}, e; }()); function He(e, t) { for (let r = 0; r < t.length; r++) { const i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } } const Ve = window.performance; const Ye = (function(e) { let t; let r; function i(t) { let r; return (r = e.call(this, t, u.a.FRAG_LOADING, u.a.FRAG_LOADED, u.a.FRAG_BUFFERED, u.a.ERROR) || this).lastLoadedFragLevel = 0, r._nextAutoLevel = -1, r.hls = t, r.timer = null, r._bwEstimator = null, r.onCheck = r._abandonRulesCheck.bind(function(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }(r)), r; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r; let a; let n; let s; const c = i.prototype; return c.destroy = function() { this.clearTimer(), h.prototype.destroy.call(this); }, c.onFragLoading = function(e) { const t = e.frag; if (t.type === 'main' && (this.timer || (this.fragCurrent = t, this.timer = setInterval(this.onCheck, 100)), !this._bwEstimator)) { let r; let i; const a = this.hls; const n = a.config; const s = t.level; a.levels[s].details.live ? (r = n.abrEwmaFastLive, i = n.abrEwmaSlowLive) : (r = n.abrEwmaFastVoD, i = n.abrEwmaSlowVoD), this._bwEstimator = new je(a, i, r, n.abrEwmaDefaultEstimate); } }, c._abandonRulesCheck = function() { const e = this.hls; const t = e.media; const r = this.fragCurrent; if (r) { const i = r.loader; const a = e.minAutoLevel; if (!i || i.stats && i.stats.aborted) return d.b.warn('frag loader destroy or aborted, disarm abandonRules'), this.clearTimer(), void (this._nextAutoLevel = -1); const n = i.stats; if (t && n && (!t.paused && t.playbackRate !== 0 || !t.readyState) && r.autoLevel && r.level) { const s = Ve.now() - n.trequest; const o = Math.abs(t.playbackRate); if (s > 500 * r.duration / o) { const l = e.levels; const c = Math.max(1, n.bw ? n.bw / 8 : 1e3 * n.loaded / s); const h = l[r.level]; const f = h.realBitrate ? Math.max(h.realBitrate, h.bitrate) : h.bitrate; const g = n.total ? n.total : Math.max(n.loaded, Math.round(r.duration * f / 8)); const p = t.currentTime; const v = (g - n.loaded) / c; const m = (V.bufferInfo(t, p, e.config.maxBufferHole).end - p) / o; if (m < 2 * r.duration / o && v > m) { let y; for (y = r.level - 1; y > a; y--) { const b = l[y].realBitrate ? Math.max(l[y].realBitrate, l[y].bitrate) : l[y].bitrate; if (r.duration * b / (6.4 * c) < m) break; } void 0 < v && (d.b.warn(`loading too slow, abort fragment loading and switch to level ${y}:fragLoadedDelay[${y}]<fragLoadedDelay[${r.level - 1}];bufferStarvationDelay:${(void 0).toFixed(1)}<${v.toFixed(1)}:${m.toFixed(1)}`), e.nextLoadLevel = y, this._bwEstimator.sample(s, n.loaded), i.abort(), this.clearTimer(), e.trigger(u.a.FRAG_LOAD_EMERGENCY_ABORTED, { frag: r, stats: n })); } } } } }, c.onFragLoaded = function(e) { const t = e.frag; if (t.type === 'main' && Object(l.a)(t.sn)) { if (this.clearTimer(), this.lastLoadedFragLevel = t.level, this._nextAutoLevel = -1, this.hls.config.abrMaxWithRealBitrate) { const r = this.hls.levels[t.level]; const i = (r.loaded ? r.loaded.bytes : 0) + e.stats.loaded; const a = (r.loaded ? r.loaded.duration : 0) + e.frag.duration; r.loaded = { bytes: i, duration: a }, r.realBitrate = Math.round(8 * i / a); } if (e.frag.bitrateTest) { const n = e.stats; n.tparsed = n.tbuffered = n.tload, this.onFragBuffered(e); } } }, c.onFragBuffered = function(e) { const t = e.stats; const r = e.frag; if (!0 !== t.aborted && r.type === 'main' && Object(l.a)(r.sn) && (!r.bitrateTest || t.tload === t.tbuffered)) { const i = t.tparsed - t.trequest; d.b.log(`latency/loading/parsing/append/kbps:${Math.round(t.tfirst - t.trequest)}/${Math.round(t.tload - t.tfirst)}/${Math.round(t.tparsed - t.tload)}/${Math.round(t.tbuffered - t.tparsed)}/${Math.round(8 * t.loaded / (t.tbuffered - t.trequest))}`), this._bwEstimator.sample(i, t.loaded), t.bwEstimate = this._bwEstimator.getEstimate(), r.bitrateTest ? this.bitrateTestDelay = i / 1e3 : this.bitrateTestDelay = 0; } }, c.onError = function(e) { switch (e.details) { case o.a.FRAG_LOAD_ERROR: case o.a.FRAG_LOAD_TIMEOUT: this.clearTimer(); } }, c.clearTimer = function() { clearInterval(this.timer), this.timer = null; }, c._findBestLevel = function(e, t, r, i, a, n, s, o, l) { for (let u = a; u >= i; u--) { const c = l[u]; if (c) { const h = c.details; const f = h ? h.totalduration / h.fragments.length : t; const g = !!h && h.live; let p = void 0; p = u <= e ? s * r : o * r; const v = l[u].realBitrate ? Math.max(l[u].realBitrate, l[u].bitrate) : l[u].bitrate; const m = v * f / p; if (d.b.trace(`level/adjustedbw/bitrate/avgDuration/maxFetchDuration/fetchDuration: ${u}/${Math.round(p)}/${v}/${f}/${n}/${m}`), p > v && (!m || g && !this.bitrateTestDelay || m < n)) return u; } } return -1; }, a = i, (n = [{ key: 'nextAutoLevel', get() { const e = this._nextAutoLevel; const t = this._bwEstimator; if (!(e === -1 || t && t.canEstimate())) return e; let r = this._nextABRAutoLevel; return e !== -1 && (r = Math.min(e, r)), r; }, set(e) { this._nextAutoLevel = e; } }, { key: '_nextABRAutoLevel', get() { const e = this.hls; const t = e.maxAutoLevel; const r = e.levels; const i = e.config; const a = e.minAutoLevel; const n = e.media; const s = this.lastLoadedFragLevel; const o = this.fragCurrent ? this.fragCurrent.duration : 0; const l = n ? n.currentTime : 0; const u = n && n.playbackRate !== 0 ? Math.abs(n.playbackRate) : 1; const c = this._bwEstimator ? this._bwEstimator.getEstimate() : i.abrEwmaDefaultEstimate; const h = (V.bufferInfo(n, l, i.maxBufferHole).end - l) / u; let f = this._findBestLevel(s, o, c, a, t, h, i.abrBandWidthFactor, i.abrBandWidthUpFactor, r); if (f >= 0) return f; d.b.trace('rebuffering expected to happen, lets try to find a quality level minimizing the rebuffering'); let g = o ? Math.min(o, i.maxStarvationDelay) : i.maxStarvationDelay; let p = i.abrBandWidthFactor; let v = i.abrBandWidthUpFactor; if (h === 0) { const m = this.bitrateTestDelay; m && (g = (o ? Math.min(o, i.maxLoadingDelay) : i.maxLoadingDelay) - m, d.b.trace(`bitrate test took ${Math.round(1e3 * m)}ms, set first fragment max fetchDuration to ${Math.round(1e3 * g)} ms`), p = v = 1); } return f = this._findBestLevel(s, o, c, a, t, h + g, p, v, r), Math.max(f, 0); } }]) && He(a.prototype, n), s && He(a, s), i; }(h)); const We = z(); const qe = (function(e) { let t; let r; function i(t) { let r; return (r = e.call(this, t, u.a.MEDIA_ATTACHING, u.a.MEDIA_DETACHING, u.a.MANIFEST_PARSED, u.a.BUFFER_RESET, u.a.BUFFER_APPENDING, u.a.BUFFER_CODECS, u.a.BUFFER_EOS, u.a.BUFFER_FLUSHING, u.a.LEVEL_PTS_UPDATED, u.a.LEVEL_UPDATED) || this)._msDuration = null, r._levelDuration = null, r._levelTargetDuration = 10, r._live = null, r._objectUrl = null, r._needsFlush = !1, r._needsEos = !1, r.config = void 0, r.audioTimestampOffset = void 0, r.bufferCodecEventsExpected = 0, r._bufferCodecEventsTotal = 0, r.media = null, r.mediaSource = null, r.segments = [], r.parent = void 0, r.appending = !1, r.appended = 0, r.appendError = 0, r.flushBufferCounter = 0, r.tracks = {}, r.pendingTracks = {}, r.sourceBuffer = {}, r.flushRange = [], r._onMediaSourceOpen = function() { d.b.log('media source opened'), r.hls.trigger(u.a.MEDIA_ATTACHED, { media: r.media }); const e = r.mediaSource; e && e.removeEventListener('sourceopen', r._onMediaSourceOpen), r.checkPendingTracks(); }, r._onMediaSourceClose = function() { d.b.log('media source closed'); }, r._onMediaSourceEnded = function() { d.b.log('media source ended'); }, r._onSBUpdateEnd = function() { if (r.audioTimestampOffset && r.sourceBuffer.audio) { const e = r.sourceBuffer.audio; d.b.warn(`change mpeg audio timestamp offset from ${e.timestampOffset} to ${r.audioTimestampOffset}`), e.timestampOffset = r.audioTimestampOffset, delete r.audioTimestampOffset; }r._needsFlush && r.doFlush(), r._needsEos && r.checkEos(), r.appending = !1; const t = r.parent; const i = r.segments.reduce(((e, r) => (r.parent === t ? e + 1 : e)), 0); const a = {}; const n = r.sourceBuffer; for (const s in n) { const o = n[s]; if (!o) throw Error(`handling source buffer update end error: source buffer for ${s} uninitilized and unable to update buffered TimeRanges.`); a[s] = o.buffered; }r.hls.trigger(u.a.BUFFER_APPENDED, { parent: t, pending: i, timeRanges: a }), r._needsFlush || r.doAppending(), r.updateMediaElementDuration(), i === 0 && r.flushLiveBackBuffer(); }, r._onSBUpdateError = function(e) { d.b.error('sourceBuffer error:', e), r.hls.trigger(u.a.ERROR, { type: o.b.MEDIA_ERROR, details: o.a.BUFFER_APPENDING_ERROR, fatal: !1 }); }, r.config = t.config, r; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r; const a = i.prototype; return a.destroy = function() { h.prototype.destroy.call(this); }, a.onLevelPtsUpdated = function(e) { const t = e.type; const r = this.tracks.audio; if (t === 'audio' && r && r.container === 'audio/mpeg') { const i = this.sourceBuffer.audio; if (!i) throw Error('Level PTS Updated and source buffer for audio uninitalized'); if (Math.abs(i.timestampOffset - e.start) > 0.1) { const a = i.updating; try { i.abort(); } catch (e) { d.b.warn(`can not abort audio buffer: ${e}`); }a ? this.audioTimestampOffset = e.start : (d.b.warn(`change mpeg audio timestamp offset from ${i.timestampOffset} to ${e.start}`), i.timestampOffset = e.start); } } }, a.onManifestParsed = function(e) { this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = e.altAudio ? 2 : 1, d.b.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`); }, a.onMediaAttaching = function(e) { const t = this.media = e.media; if (t && We) { const r = this.mediaSource = new We(); r.addEventListener('sourceopen', this._onMediaSourceOpen), r.addEventListener('sourceended', this._onMediaSourceEnded), r.addEventListener('sourceclose', this._onMediaSourceClose), t.src = window.URL.createObjectURL(r), this._objectUrl = t.src; } }, a.onMediaDetaching = function() { d.b.log('media source detaching'); const e = this.mediaSource; if (e) { if (e.readyState === 'open') try { e.endOfStream(); } catch (e) { d.b.warn(`onMediaDetaching:${e.message} while calling endOfStream`); }e.removeEventListener('sourceopen', this._onMediaSourceOpen), e.removeEventListener('sourceended', this._onMediaSourceEnded), e.removeEventListener('sourceclose', this._onMediaSourceClose), this.media && (this._objectUrl && window.URL.revokeObjectURL(this._objectUrl), this.media.src === this._objectUrl ? (this.media.removeAttribute('src'), this.media.load()) : d.b.warn('media.src was changed by a third party - skip cleanup')), this.mediaSource = null, this.media = null, this._objectUrl = null, this.bufferCodecEventsExpected = this._bufferCodecEventsTotal, this.pendingTracks = {}, this.tracks = {}, this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0; } this.hls.trigger(u.a.MEDIA_DETACHED); }, a.checkPendingTracks = function() { const e = this.bufferCodecEventsExpected; const t = this.pendingTracks; const r = Object.keys(t).length; (r && !e || r === 2) && (this.createSourceBuffers(t), this.pendingTracks = {}, this.doAppending()); }, a.onBufferReset = function() { const e = this.sourceBuffer; for (const t in e) { const r = e[t]; try { r && (this.mediaSource && this.mediaSource.removeSourceBuffer(r), r.removeEventListener('updateend', this._onSBUpdateEnd), r.removeEventListener('error', this._onSBUpdateError)); } catch (e) {} } this.sourceBuffer = {}, this.flushRange = [], this.segments = [], this.appended = 0; }, a.onBufferCodecs = function(e) { const t = this; Object.keys(this.sourceBuffer).length || (Object.keys(e).forEach(((r) => { t.pendingTracks[r] = e[r]; })), this.bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0), this.mediaSource && this.mediaSource.readyState === 'open' && this.checkPendingTracks()); }, a.createSourceBuffers = function(e) { const t = this.sourceBuffer; const r = this.mediaSource; if (!r) throw Error('createSourceBuffers called when mediaSource was null'); for (const i in e) if (!t[i]) { const a = e[i]; if (!a) throw Error(`source buffer exists for track ${i}, however track does not`); const n = a.levelCodec || a.codec; const s = `${a.container};codecs=${n}`; d.b.log(`creating sourceBuffer(${s})`); try { const l = t[i] = r.addSourceBuffer(s); l.addEventListener('updateend', this._onSBUpdateEnd), l.addEventListener('error', this._onSBUpdateError), this.tracks[i] = { buffer: l, codec: n, id: a.id, container: a.container, levelCodec: a.levelCodec }; } catch (e) { d.b.error(`error while trying to add sourceBuffer:${e.message}`), this.hls.trigger(u.a.ERROR, { type: o.b.MEDIA_ERROR, details: o.a.BUFFER_ADD_CODEC_ERROR, fatal: !1, err: e, mimeType: s }); } } this.hls.trigger(u.a.BUFFER_CREATED, { tracks: this.tracks }); }, a.onBufferAppending = function(e) { this._needsFlush || (this.segments ? this.segments.push(e) : this.segments = [e], this.doAppending()); }, a.onBufferEos = function(e) { for (const t in this.sourceBuffer) if (!e.type || e.type === t) { const r = this.sourceBuffer[t]; r && !r.ended && (r.ended = !0, d.b.log(`${t} sourceBuffer now EOS`)); } this.checkEos(); }, a.checkEos = function() { const e = this.sourceBuffer; const t = this.mediaSource; if (t && t.readyState === 'open') { for (const r in e) { const i = e[r]; if (i) { if (!i.ended) return; if (i.updating) return void (this._needsEos = !0); } }d.b.log('all media data are available, signal endOfStream() to MediaSource and stop loading fragment'); try { t.endOfStream(); } catch (e) { d.b.warn('exception while calling mediaSource.endOfStream()'); } this._needsEos = !1; } else this._needsEos = !1; }, a.onBufferFlushing = function(e) { e.type ? this.flushRange.push({ start: e.startOffset, end: e.endOffset, type: e.type }) : (this.flushRange.push({ start: e.startOffset, end: e.endOffset, type: 'video' }), this.flushRange.push({ start: e.startOffset, end: e.endOffset, type: 'audio' })), this.flushBufferCounter = 0, this.doFlush(); }, a.flushLiveBackBuffer = function() { if (this._live) { const e = this.config.liveBackBufferLength; if (isFinite(e) && !(e < 0)) if (this.media) for (let t = this.media.currentTime, r = this.sourceBuffer, i = Object.keys(r), a = t - Math.max(e, this._levelTargetDuration), n = i.length - 1; n >= 0; n--) { const s = i[n]; const o = r[s]; if (o) { const l = o.buffered; l.length > 0 && a > l.start(0) && this.removeBufferRange(s, o, 0, a) && this.hls.trigger(u.a.LIVE_BACK_BUFFER_REACHED, { bufferEnd: a }); } } else d.b.error('flushLiveBackBuffer called without attaching media'); } }, a.onLevelUpdated = function(e) { const t = e.details; t.fragments.length > 0 && (this._levelDuration = t.totalduration + t.fragments[0].start, this._levelTargetDuration = t.averagetargetduration || t.targetduration || 10, this._live = t.live, this.updateMediaElementDuration()); }, a.updateMediaElementDuration = function() { let e; const t = this.config; if (this._levelDuration !== null && this.media && this.mediaSource && this.sourceBuffer && this.media.readyState !== 0 && this.mediaSource.readyState === 'open') { for (const r in this.sourceBuffer) { const i = this.sourceBuffer[r]; if (i && !0 === i.updating) return; }e = this.media.duration, this._msDuration === null && (this._msDuration = this.mediaSource.duration), !0 === this._live && !0 === t.liveDurationInfinity ? (d.b.log('Media Source duration is set to Infinity'), this._msDuration = this.mediaSource.duration = 1 / 0) : (this._levelDuration > this._msDuration && this._levelDuration > e || !Object(l.a)(e)) && (d.b.log(`Updating Media Source duration to ${this._levelDuration.toFixed(3)}`), this._msDuration = this.mediaSource.duration = this._levelDuration); } }, a.doFlush = function() { for (;this.flushRange.length;) { const e = this.flushRange[0]; if (!this.flushBuffer(e.start, e.end, e.type)) return void (this._needsFlush = !0); this.flushRange.shift(), this.flushBufferCounter = 0; } if (this.flushRange.length === 0) { this._needsFlush = !1; let t = 0; const r = this.sourceBuffer; try { for (const i in r) { const a = r[i]; a && (t += a.buffered.length); } } catch (e) { d.b.error('error while accessing sourceBuffer.buffered'); } this.appended = t, this.hls.trigger(u.a.BUFFER_FLUSHED); } }, a.doAppending = function() { const e = this.config; const t = this.hls; const r = this.segments; const i = this.sourceBuffer; if (Object.keys(i).length) { if (!this.media || this.media.error) return this.segments = [], void d.b.error('trying to append although a media error occured, flush segment and abort'); if (!this.appending) { const a = r.shift(); if (a) try { const n = i[a.type]; if (!n) return void this._onSBUpdateEnd(); if (n.updating) return void r.unshift(a); n.ended = !1, this.parent = a.parent, n.appendBuffer(a.data), this.appendError = 0, this.appended++, this.appending = !0; } catch (i) { d.b.error(`error while trying to append buffer:${i.message}`), r.unshift(a); const s = { type: o.b.MEDIA_ERROR, parent: a.parent, details: '', fatal: !1 }; i.code === 22 ? (this.segments = [], s.details = o.a.BUFFER_FULL_ERROR) : (this.appendError++, s.details = o.a.BUFFER_APPEND_ERROR, this.appendError > e.appendErrorMaxRetry && (d.b.log(`fail ${e.appendErrorMaxRetry} times to append segment in sourceBuffer`), this.segments = [], s.fatal = !0)), t.trigger(u.a.ERROR, s); } } } }, a.flushBuffer = function(e, t, r) { const i = this.sourceBuffer; if (!Object.keys(i).length) return !0; let a = 'null'; if (this.media && (a = this.media.currentTime.toFixed(3)), d.b.log(`flushBuffer,pos/start/end: ${a}/${e}/${t}`), this.flushBufferCounter >= this.appended) return d.b.warn('abort flushing too many retries'), !0; const n = i[r]; if (n) { if (n.ended = !1, n.updating) return d.b.warn('cannot flush, sb updating in progress'), !1; if (this.removeBufferRange(r, n, e, t)) return this.flushBufferCounter++, !1; } return d.b.log('buffer flushed'), !0; }, a.removeBufferRange = function(e, t, r, i) { try { for (let a = 0; a < t.buffered.length; a++) { const n = t.buffered.start(a); const s = t.buffered.end(a); const o = Math.max(n, r); const l = Math.min(s, i); if (Math.min(l, s) - o > 0.5) { let u = 'null'; return this.media && (u = this.media.currentTime.toString()), d.b.log(`sb remove ${e} [${o},${l}], of [${n},${s}], pos:${u}`), t.remove(o, l), !0; } } } catch (e) { d.b.warn('removeBufferRange failed', e); } return !1; }, i; }(h)); function ze(e, t) { for (let r = 0; r < t.length; r++) { const i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } } const Xe = (function(e) { let t; let r; function i(t) { let r; return (r = e.call(this, t, u.a.FPS_DROP_LEVEL_CAPPING, u.a.MEDIA_ATTACHING, u.a.MANIFEST_PARSED, u.a.BUFFER_CODECS, u.a.MEDIA_DETACHING) || this).autoLevelCapping = Number.POSITIVE_INFINITY, r.firstLevel = null, r.levels = [], r.media = null, r.restrictedLevels = [], r.timer = null, r; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r; let a; let n; let s; const o = i.prototype; return o.destroy = function() { this.hls.config.capLevelToPlayerSize && (this.media = null, this.stopCapping()); }, o.onFpsDropLevelCapping = function(e) { i.isLevelAllowed(e.droppedLevel, this.restrictedLevels) && this.restrictedLevels.push(e.droppedLevel); }, o.onMediaAttaching = function(e) { this.media = e.media instanceof window.HTMLVideoElement ? e.media : null; }, o.onManifestParsed = function(e) { const t = this.hls; this.restrictedLevels = [], this.levels = e.levels, this.firstLevel = e.firstLevel, t.config.capLevelToPlayerSize && e.video && this.startCapping(); }, o.onBufferCodecs = function(e) { this.hls.config.capLevelToPlayerSize && e.video && this.startCapping(); }, o.onLevelsUpdated = function(e) { this.levels = e.levels; }, o.onMediaDetaching = function() { this.stopCapping(); }, o.detectPlayerSize = function() { if (this.media) { const e = this.levels ? this.levels.length : 0; if (e) { const t = this.hls; t.autoLevelCapping = this.getMaxLevel(e - 1), t.autoLevelCapping > this.autoLevelCapping && t.streamController.nextLevelSwitch(), this.autoLevelCapping = t.autoLevelCapping; } } }, o.getMaxLevel = function(e) { const t = this; if (!this.levels) return -1; const r = this.levels.filter(((r, a) => i.isLevelAllowed(a, t.restrictedLevels) && a <= e)); return i.getMaxLevelByMediaSize(r, this.mediaWidth, this.mediaHeight); }, o.startCapping = function() { this.timer || (this.autoLevelCapping = Number.POSITIVE_INFINITY, this.hls.firstLevel = this.getMaxLevel(this.firstLevel), clearInterval(this.timer), this.timer = setInterval(this.detectPlayerSize.bind(this), 1e3), this.detectPlayerSize()); }, o.stopCapping = function() { this.restrictedLevels = [], this.firstLevel = null, this.autoLevelCapping = Number.POSITIVE_INFINITY, this.timer && (this.timer = clearInterval(this.timer), this.timer = null); }, i.isLevelAllowed = function(e, t) { return void 0 === t && (t = []), t.indexOf(e) === -1; }, i.getMaxLevelByMediaSize = function(e, t, r) { if (!e || e && !e.length) return -1; for (var i, a, n = e.length - 1, s = 0; s < e.length; s += 1) { const o = e[s]; if ((o.width >= t || o.height >= r) && (i = o, !(a = e[s + 1]) || i.width !== a.width || i.height !== a.height)) { n = s; break; } } return n; }, a = i, s = [{ key: 'contentScaleFactor', get() { let e = 1; try { e = window.devicePixelRatio; } catch (e) {} return e; } }], (n = [{ key: 'mediaWidth', get() { let e; const t = this.media; return t && (e = t.width || t.clientWidth || t.offsetWidth, e *= i.contentScaleFactor), e; } }, { key: 'mediaHeight', get() { let e; const t = this.media; return t && (e = t.height || t.clientHeight || t.offsetHeight, e *= i.contentScaleFactor), e; } }]) && ze(a.prototype, n), s && ze(a, s), i; }(h)); const Qe = window.performance; const $e = (function(e) { let t; let r; function i(t) { return e.call(this, t, u.a.MEDIA_ATTACHING) || this; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r; const a = i.prototype; return a.destroy = function() { this.timer && clearInterval(this.timer), this.isVideoPlaybackQualityAvailable = !1; }, a.onMediaAttaching = function(e) { const t = this.hls.config; t.capLevelOnFPSDrop && (typeof (this.video = e.media instanceof window.HTMLVideoElement ? e.media : null).getVideoPlaybackQuality === 'function' && (this.isVideoPlaybackQualityAvailable = !0), clearInterval(this.timer), this.timer = setInterval(this.checkFPSInterval.bind(this), t.fpsDroppedMonitoringPeriod)); }, a.checkFPS = function(e, t, r) { const i = Qe.now(); if (t) { if (this.lastTime) { const a = i - this.lastTime; const n = r - this.lastDroppedFrames; const s = t - this.lastDecodedFrames; const o = 1e3 * n / a; const l = this.hls; if (l.trigger(u.a.FPS_DROP, { currentDropped: n, currentDecoded: s, totalDroppedFrames: r }), o > 0 && n > l.config.fpsDroppedMonitoringThreshold * s) { let c = l.currentLevel; d.b.warn(`drop FPS ratio greater than max allowed value for currentLevel: ${c}`), c > 0 && (l.autoLevelCapping === -1 || l.autoLevelCapping >= c) && (c -= 1, l.trigger(u.a.FPS_DROP_LEVEL_CAPPING, { level: c, droppedLevel: l.currentLevel }), l.autoLevelCapping = c, l.streamController.nextLevelSwitch()); } } this.lastTime = i, this.lastDroppedFrames = r, this.lastDecodedFrames = t; } }, a.checkFPSInterval = function() { const e = this.video; if (e) if (this.isVideoPlaybackQualityAvailable) { const t = e.getVideoPlaybackQuality(); this.checkFPS(e, t.totalVideoFrames, t.droppedVideoFrames); } else this.checkFPS(e, e.webkitDecodedFrameCount, e.webkitDroppedFrameCount); }, i; }(h)); const Je = window; const Ze = Je.performance; const et = Je.XMLHttpRequest; const tt = (function() { function e(e) { e && e.xhrSetup && (this.xhrSetup = e.xhrSetup); } const t = e.prototype; return t.destroy = function() { this.abort(), this.loader = null; }, t.abort = function() { const e = this.loader; e && e.readyState !== 4 && (this.stats.aborted = !0, e.abort()), window.clearTimeout(this.requestTimeout), this.requestTimeout = null, window.clearTimeout(this.retryTimeout), this.retryTimeout = null; }, t.load = function(e, t, r) { this.context = e, this.config = t, this.callbacks = r, this.stats = { trequest: Ze.now(), retry: 0 }, this.retryDelay = t.retryDelay, this.loadInternal(); }, t.loadInternal = function() { let e; const t = this.context; e = this.loader = new et(); const r = this.stats; r.tfirst = 0, r.loaded = 0; const i = this.xhrSetup; try { if (i) try { i(e, t.url); } catch (r) { e.open('GET', t.url, !0), i(e, t.url); }e.readyState || e.open('GET', t.url, !0); } catch (r) { return void this.callbacks.onError({ code: e.status, text: r.message }, t, e); }t.rangeEnd && e.setRequestHeader('Range', `bytes=${t.rangeStart}-${t.rangeEnd - 1}`), e.onreadystatechange = this.readystatechange.bind(this), e.onprogress = this.loadprogress.bind(this), e.responseType = t.responseType, this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), this.config.timeout), e.send(); }, t.readystatechange = function(e) { const t = e.currentTarget; const r = t.readyState; const i = this.stats; const a = this.context; const n = this.config; if (!i.aborted && r >= 2) if (window.clearTimeout(this.requestTimeout), i.tfirst === 0 && (i.tfirst = Math.max(Ze.now(), i.trequest)), r === 4) { const s = t.status; if (s >= 200 && s < 300) { let o; let l; i.tload = Math.max(i.tfirst, Ze.now()), l = a.responseType === 'arraybuffer' ? (o = t.response).byteLength : (o = t.responseText).length, i.loaded = i.total = l; const u = { url: t.responseURL, data: o }; this.callbacks.onSuccess(u, i, a, t); } else i.retry >= n.maxRetry || s >= 400 && s < 499 ? (d.b.error(`${s} while loading ${a.url}`), this.callbacks.onError({ code: s, text: t.statusText }, a, t)) : (d.b.warn(`${s} while loading ${a.url}, retrying in ${this.retryDelay}...`), this.destroy(), this.retryTimeout = window.setTimeout(this.loadInternal.bind(this), this.retryDelay), this.retryDelay = Math.min(2 * this.retryDelay, n.maxRetryDelay), i.retry++); } else this.requestTimeout = window.setTimeout(this.loadtimeout.bind(this), n.timeout); }, t.loadtimeout = function() { d.b.warn(`timeout while loading ${this.context.url}`), this.callbacks.onTimeout(this.stats, this.context, null); }, t.loadprogress = function(e) { const t = e.currentTarget; const r = this.stats; r.loaded = e.loaded, e.lengthComputable && (r.total = e.total); const i = this.callbacks.onProgress; i && i(r, this.context, null, t); }, e; }()); function rt(e, t) { for (let r = 0; r < t.length; r++) { const i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } } const it = (function(e) { let t; let r; function i(t) { let r; return (r = e.call(this, t, u.a.MANIFEST_LOADING, u.a.MANIFEST_PARSED, u.a.AUDIO_TRACK_LOADED, u.a.AUDIO_TRACK_SWITCHED, u.a.LEVEL_LOADED, u.a.ERROR) || this)._trackId = -1, r._selectDefaultTrack = !0, r.tracks = [], r.trackIdBlacklist = Object.create(null), r.audioGroupId = null, r; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r; let a; let n; let s; const l = i.prototype; return l.onManifestLoading = function() { this.tracks = [], this._trackId = -1, this._selectDefaultTrack = !0; }, l.onManifestParsed = function(e) { const t = this.tracks = e.audioTracks || []; this.hls.trigger(u.a.AUDIO_TRACKS_UPDATED, { audioTracks: t }), this._selectAudioGroup(this.hls.nextLoadLevel); }, l.onAudioTrackLoaded = function(e) { if (e.id >= this.tracks.length)d.b.warn('Invalid audio track id:', e.id); else { if (d.b.log(`audioTrack ${e.id} loaded`), this.tracks[e.id].details = e.details, e.details.live && !this.hasInterval()) { const t = 1e3 * e.details.targetduration; this.setInterval(t); }!e.details.live && this.hasInterval() && this.clearInterval(); } }, l.onAudioTrackSwitched = function(e) { const t = this.tracks[e.id].groupId; t && this.audioGroupId !== t && (this.audioGroupId = t); }, l.onLevelLoaded = function(e) { this._selectAudioGroup(e.level); }, l.onError = function(e) { e.type === o.b.NETWORK_ERROR && (e.fatal && this.clearInterval(), e.details === o.a.AUDIO_TRACK_LOAD_ERROR && (d.b.warn('Network failure on audio-track id:', e.context.id), this._handleLoadError())); }, l._setAudioTrack = function(e) { if (this._trackId === e && this.tracks[this._trackId].details)d.b.debug('Same id as current audio-track passed, and track details available -> no-op'); else if (e < 0 || e >= this.tracks.length)d.b.warn('Invalid id passed to audio-track controller'); else { const t = this.tracks[e]; d.b.log(`Now switching to audio-track index ${e}`), this.clearInterval(), this._trackId = e; const r = t.url; const i = t.type; const a = t.id; this.hls.trigger(u.a.AUDIO_TRACK_SWITCHING, { id: a, type: i, url: r }), this._loadTrackDetailsIfNeeded(t); } }, l.doTick = function() { this._updateTrack(this._trackId); }, l._selectAudioGroup = function(e) { const t = this.hls.levels[e]; if (t && t.audioGroupIds) { const r = t.audioGroupIds[t.urlId]; this.audioGroupId !== r && (this.audioGroupId = r, this._selectInitialAudioTrack()); } }, l._selectInitialAudioTrack = function() { const e = this; let t = this.tracks; if (t.length) { const r = this.tracks[this._trackId]; let i = null; if (r && (i = r.name), this._selectDefaultTrack) { const a = t.filter(((e) => e.default)); a.length ? t = a : d.b.warn('No default audio tracks defined'); } let n = !1; const s = function() { t.forEach(((t) => { n || e.audioGroupId && t.groupId !== e.audioGroupId || i && i !== t.name || (e._setAudioTrack(t.id), n = !0); })); }; s(), n || (i = null, s()), n || (d.b.error(`No track found for running audio group-ID: ${this.audioGroupId}`), this.hls.trigger(u.a.ERROR, { type: o.b.MEDIA_ERROR, details: o.a.AUDIO_TRACK_LOAD_ERROR, fatal: !0 })); } }, l._needsTrackLoading = function(e) { const t = e.details; const r = e.url; return !(t && !t.live) && !!r; }, l._loadTrackDetailsIfNeeded = function(e) { if (this._needsTrackLoading(e)) { const t = e.url; const r = e.id; d.b.log(`loading audio-track playlist for id: ${r}`), this.hls.trigger(u.a.AUDIO_TRACK_LOADING, { url: t, id: r }); } }, l._updateTrack = function(e) { if (!(e < 0 || e >= this.tracks.length)) { this.clearInterval(), this._trackId = e, d.b.log(`trying to update audio-track ${e}`); const t = this.tracks[e]; this._loadTrackDetailsIfNeeded(t); } }, l._handleLoadError = function() { this.trackIdBlacklist[this._trackId] = !0; const e = this._trackId; const t = this.tracks[e]; const r = t.name; const i = t.language; const a = t.groupId; d.b.warn(`Loading failed on audio track id: ${e}, group-id: ${a}, name/language: "${r}" / "${i}"`); for (var n = e, s = 0; s < this.tracks.length; s++) { if (!this.trackIdBlacklist[s]) if (this.tracks[s].name === r) { n = s; break; } }n !== e ? (d.b.log('Attempting audio-track fallback id:', n, 'group-id:', this.tracks[n].groupId), this._setAudioTrack(n)) : d.b.warn(`No fallback audio-track found for name/language: "${r}" / "${i}"`); }, a = i, (n = [{ key: 'audioTracks', get() { return this.tracks; } }, { key: 'audioTrack', get() { return this._trackId; }, set(e) { this._setAudioTrack(e), this._selectDefaultTrack = !1; } }]) && rt(a.prototype, n), s && rt(a, s), i; }(pe)); function at(e, t) { for (let r = 0; r < t.length; r++) { const i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } } const nt = window.performance; const st = (function(e) { let t; let r; function i(t, r) { let i; return (i = e.call(this, t, u.a.MEDIA_ATTACHED, u.a.MEDIA_DETACHING, u.a.AUDIO_TRACKS_UPDATED, u.a.AUDIO_TRACK_SWITCHING, u.a.AUDIO_TRACK_LOADED, u.a.KEY_LOADED, u.a.FRAG_LOADED, u.a.FRAG_PARSING_INIT_SEGMENT, u.a.FRAG_PARSING_DATA, u.a.FRAG_PARSED, u.a.ERROR, u.a.BUFFER_RESET, u.a.BUFFER_CREATED, u.a.BUFFER_APPENDED, u.a.BUFFER_FLUSHED, u.a.INIT_PTS_FOUND) || this).fragmentTracker = r, i.config = t.config, i.audioCodecSwap = !1, i._state = ve, i.initPTS = [], i.waitingFragment = null, i.videoTrackCC = null, i; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r; let a; let n; let s; const c = i.prototype; return c.onInitPtsFound = function(e) { const t = e.id; const r = e.frag.cc; const i = e.initPTS; t === 'main' && (this.initPTS[r] = i, this.videoTrackCC = r, d.b.log(`InitPTS for cc: ${r} found from video track: ${i}`), this.state === De && this.tick()); }, c.startLoad = function(e) { if (this.tracks) { const t = this.lastCurrentTime; this.stopLoad(), this.setInterval(100), this.fragLoadError = 0, t > 0 && e === -1 ? (d.b.log(`audio:override startPosition with lastCurrentTime @${t.toFixed(3)}`), this.state = ye) : (this.lastCurrentTime = this.startPosition ? this.startPosition : e, this.state = me), this.nextLoadPosition = this.startPosition = this.lastCurrentTime, this.tick(); } else this.startPosition = e, this.state = ve; }, c.doTick = function() { let e; let t; let r; const i = this.hls; const a = i.config; switch (this.state) { case Le: case be: case we: break; case me: this.state = _e, this.loadedmetadata = !1; break; case ye: var n = this.tracks; if (!n) break; if (!this.media && (this.startFragRequested || !a.startFragPrefetch)) break; if (this.loadedmetadata)e = this.media.currentTime; else if (void 0 === (e = this.nextLoadPosition)) break; var s = this.mediaBuffer ? this.mediaBuffer : this.media; var o = this.videoBuffer ? this.videoBuffer : this.media; var c = V.bufferInfo(s, e, a.maxBufferHole); var h = V.bufferInfo(o, e, a.maxBufferHole); var f = c.len; var g = c.end; var p = this.fragPrevious; var v = Math.min(a.maxBufferLength, a.maxMaxBufferLength); var m = Math.max(v, h.len); var y = this.audioSwitch; var b = this.trackId; if ((f < m || y) && b < n.length) { if (void 0 === (r = n[b].details)) { this.state = _e; break; } if (!y && this._streamEnded(c, r)) return this.hls.trigger(u.a.BUFFER_EOS, { type: 'audio' }), void (this.state = ke); let T; const E = r.fragments; const S = E.length; let _ = E[0].start; const A = E[S - 1].start + E[S - 1].duration; if (y) if (r.live && !r.PTSKnown)d.b.log('switching audiotrack, live stream, unknown PTS,load first fragment'), g = 0; else if (g = e, r.PTSKnown && e < _) { if (!(c.end > _ || c.nextStart)) return; d.b.log('alt audio track ahead of main track, seek to start of alt audio track'), this.media.currentTime = _ + 0.05; } if (r.initSegment && !r.initSegment.data)T = r.initSegment; else if (g <= _) { if (T = E[0], this.videoTrackCC !== null && T.cc !== this.videoTrackCC && (T = (function(e, t) { return H.search(e, ((e) => (e.cc < t ? 1 : e.cc > t ? -1 : 0))); }(E, this.videoTrackCC))), r.live && T.loadIdx && T.loadIdx === this.fragLoadIdx) { const R = c.nextStart ? c.nextStart : _; return d.b.log(`no alt audio available @currentTime:${this.media.currentTime}, seeking @${R + 0.05}`), void (this.media.currentTime = R + 0.05); } } else { let w; let k = a.maxFragLookUpTolerance; const L = p ? E[p.sn - E[0].sn + 1] : void 0; const D = function(e) { const t = Math.min(k, e.duration); return e.start + e.duration - t <= g ? 1 : e.start - t > g && e.start ? -1 : 0; }; g < A ? (g > A - k && (k = 0), w = L && !D(L) ? L : H.search(E, D)) : w = E[S - 1], w && (T = w, _ = w.start, p && T.level === p.level && T.sn === p.sn && (T.sn < r.endSN ? (T = E[T.sn + 1 - r.startSN], d.b.log(`SN just loaded, load next one: ${T.sn}`)) : T = null)); }T && (T.encrypted ? (d.b.log(`Loading key for ${T.sn} of [${r.startSN} ,${r.endSN}],track ${b}`), this.state = Te, i.trigger(u.a.KEY_LOADING, { frag: T })) : (d.b.log(`Loading ${T.sn}, cc: ${T.cc} of [${r.startSN} ,${r.endSN}],track ${b}, currentTime:${e},bufferEnd:${g.toFixed(3)}`), this.fragCurrent = T, (y || this.fragmentTracker.getState(T) === N) && (T.sn !== 'initSegment' && (this.startFragRequested = !0), Object(l.a)(T.sn) && (this.nextLoadPosition = T.start + T.duration), i.trigger(u.a.FRAG_LOADING, { frag: T }), this.state = Ee))); } break; case _e: (t = this.tracks[this.trackId]) && t.details && (this.state = ye); break; case Se: var C = nt.now(); var I = this.retryDate; var O = (s = this.media) && s.seeking; (!I || C >= I || O) && (d.b.log('audioStreamController: retryDate reached, switch back to IDLE state'), this.state = ye); break; case De: var x = this.videoTrackCC; if (void 0 === this.initPTS[x]) break; var P = this.waitingFragment; if (P) { const M = P.frag.cc; x !== M ? (t = this.tracks[this.trackId]).details && t.details.live && (d.b.warn(`Waiting fragment CC (${M}) does not match video track CC (${x})`), this.waitingFragment = null, this.state = ye) : (this.state = Ee, this.onFragLoaded(this.waitingFragment), this.waitingFragment = null); } else this.state = ye; } }, c.onMediaAttached = function(e) { const t = this.media = this.mediaBuffer = e.media; this.onvseeking = this.onMediaSeeking.bind(this), this.onvended = this.onMediaEnded.bind(this), t.addEventListener('seeking', this.onvseeking), t.addEventListener('ended', this.onvended); const r = this.config; this.tracks && r.autoStartLoad && this.startLoad(r.startPosition); }, c.onMediaDetaching = function() { const e = this.media; e && e.ended && (d.b.log('MSE detaching and video ended, reset startPosition'), this.startPosition = this.lastCurrentTime = 0), e && (e.removeEventListener('seeking', this.onvseeking), e.removeEventListener('ended', this.onvended), this.onvseeking = this.onvseeked = this.onvended = null), this.media = this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1, this.fragmentTracker.removeAllFragments(), this.stopLoad(); }, c.onAudioTracksUpdated = function(e) { d.b.log('audio tracks updated'), this.tracks = e.audioTracks; }, c.onAudioTrackSwitching = function(e) { const t = !!e.url; this.trackId = e.id, this.fragCurrent = null, this.state = be, this.waitingFragment = null, t ? this.setInterval(100) : this.demuxer && (this.demuxer.destroy(), this.demuxer = null), t && (this.audioSwitch = !0, this.state = ye), this.tick(); }, c.onAudioTrackLoaded = function(e) { const t = e.details; const r = e.id; const i = this.tracks[r]; const a = t.totalduration; let n = 0; if (d.b.log(`track ${r} loaded [${t.startSN},${t.endSN}],duration:${a}`), t.live) { const s = i.details; s && t.fragments.length > 0 ? (ie(s, t), n = t.fragments[0].start, t.PTSKnown ? d.b.log(`live audio playlist sliding:${n.toFixed(3)}`) : d.b.log('live audio playlist - outdated PTS, unknown sliding')) : (t.PTSKnown = !1, d.b.log('live audio playlist - first load, unknown sliding')); } else t.PTSKnown = !1; if (i.details = t, !this.startFragRequested) { if (this.startPosition === -1) { const o = t.startTimeOffset; Object(l.a)(o) ? (d.b.log(`start time offset found in playlist, adjust startPosition to ${o}`), this.startPosition = o) : t.live ? (this.startPosition = this.computeLivePosition(n, t), d.b.log(`compute startPosition for audio-track to ${this.startPosition}`)) : this.startPosition = 0; } this.nextLoadPosition = this.startPosition; } this.state === _e && (this.state = ye), this.tick(); }, c.onKeyLoaded = function() { this.state === Te && (this.state = ye, this.tick()); }, c.onFragLoaded = function(e) { const t = this.fragCurrent; const r = e.frag; if (this.state === Ee && t && r.type === 'audio' && r.level === t.level && r.sn === t.sn) { const i = this.tracks[this.trackId]; const a = i.details; const n = a.totalduration; const s = t.level; const o = t.sn; const l = t.cc; const c = this.config.defaultAudioCodec || i.audioCodec || 'mp4a.40.2'; const h = this.stats = e.stats; if (o === 'initSegment') this.state = ye, h.tparsed = h.tbuffered = nt.now(), a.initSegment.data = e.payload, this.hls.trigger(u.a.FRAG_BUFFERED, { stats: h, frag: t, id: 'audio' }), this.tick(); else { this.state = Ae, this.appended = !1, this.demuxer || (this.demuxer = new Z(this.hls, 'audio')); const f = this.initPTS[l]; const g = a.initSegment ? a.initSegment.data : []; if (a.initSegment || void 0 !== f) { this.pendingBuffering = !0, d.b.log(`Demuxing ${o} of [${a.startSN} ,${a.endSN}],track ${s}`); this.demuxer.push(e.payload, g, c, null, t, n, !1, f); } else d.b.log(`unknown video PTS for continuity counter ${l}, waiting for video PTS before demuxing audio frag ${o} of [${a.startSN} ,${a.endSN}],track ${s}`), this.waitingFragment = e, this.state = De; } } this.fragLoadError = 0; }, c.onFragParsingInitSegment = function(e) { const t = this.fragCurrent; const r = e.frag; if (t && e.id === 'audio' && r.sn === t.sn && r.level === t.level && this.state === Ae) { let i; const a = e.tracks; if (a.video && delete a.video, i = a.audio) { i.levelCodec = i.codec, i.id = e.id, this.hls.trigger(u.a.BUFFER_CODECS, a), d.b.log(`audio track:audio,container:${i.container},codecs[level/parsed]=[${i.levelCodec}/${i.codec}]`); const n = i.initSegment; if (n) { const s = { type: 'audio', data: n, parent: 'audio', content: 'initSegment' }; this.audioSwitch ? this.pendingData = [s] : (this.appended = !0, this.pendingBuffering = !0, this.hls.trigger(u.a.BUFFER_APPENDING, s)); } this.tick(); } } }, c.onFragParsingData = function(e) { const t = this; const r = this.fragCurrent; const i = e.frag; if (r && e.id === 'audio' && e.type === 'audio' && i.sn === r.sn && i.level === r.level && this.state === Ae) { const a = this.trackId; const n = this.tracks[a]; const s = this.hls; Object(l.a)(e.endPTS) || (e.endPTS = e.startPTS + r.duration, e.endDTS = e.startDTS + r.duration), r.addElementaryStream(p.AUDIO), d.b.log(`parsed ${e.type},PTS:[${e.startPTS.toFixed(3)},${e.endPTS.toFixed(3)}],DTS:[${e.startDTS.toFixed(3)}/${e.endDTS.toFixed(3)}],nb:${e.nb}`), re(n.details, r, e.startPTS, e.endPTS); const c = this.audioSwitch; const h = this.media; let f = !1; if (c) if (h && h.readyState) { const g = h.currentTime; d.b.log(`switching audio track : currentTime:${g}`), g >= e.startPTS && (d.b.log('switching audio track : flushing all audio'), this.state = we, s.trigger(u.a.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' }), f = !0, this.audioSwitch = !1, s.trigger(u.a.AUDIO_TRACK_SWITCHED, { id: a })); } else this.audioSwitch = !1, s.trigger(u.a.AUDIO_TRACK_SWITCHED, { id: a }); const v = this.pendingData; if (!v) return d.b.warn('Apparently attempt to enqueue media payload without codec initialization data upfront'), void s.trigger(u.a.ERROR, { type: o.b.MEDIA_ERROR, details: null, fatal: !0 }); this.audioSwitch || ([e.data1, e.data2].forEach(((t) => { t && t.length && v.push({ type: e.type, data: t, parent: 'audio', content: 'data' }); })), !f && v.length && (v.forEach(((e) => { t.state === Ae && (t.pendingBuffering = !0, t.hls.trigger(u.a.BUFFER_APPENDING, e)); })), this.pendingData = [], this.appended = !0)), this.tick(); } }, c.onFragParsed = function(e) { const t = this.fragCurrent; const r = e.frag; t && e.id === 'audio' && r.sn === t.sn && r.level === t.level && this.state === Ae && (this.stats.tparsed = nt.now(), this.state = Re, this._checkAppendedParsed()); }, c.onBufferReset = function() { this.mediaBuffer = this.videoBuffer = null, this.loadedmetadata = !1; }, c.onBufferCreated = function(e) { const t = e.tracks.audio; t && (this.mediaBuffer = t.buffer, this.loadedmetadata = !0), e.tracks.video && (this.videoBuffer = e.tracks.video.buffer); }, c.onBufferAppended = function(e) { if (e.parent === 'audio') { const t = this.state; t !== Ae && t !== Re || (this.pendingBuffering = e.pending > 0, this._checkAppendedParsed()); } }, c._checkAppendedParsed = function() { if (!(this.state !== Re || this.appended && this.pendingBuffering)) { const e = this.fragCurrent; const t = this.stats; const r = this.hls; if (e) { this.fragPrevious = e, t.tbuffered = nt.now(), r.trigger(u.a.FRAG_BUFFERED, { stats: t, frag: e, id: 'audio' }); const i = this.mediaBuffer ? this.mediaBuffer : this.media; i && d.b.log(`audio buffered : ${se.toString(i.buffered)}`), this.audioSwitch && this.appended && (this.audioSwitch = !1, r.trigger(u.a.AUDIO_TRACK_SWITCHED, { id: this.trackId })), this.state = ye; } this.tick(); } }, c.onError = function(e) { const t = e.frag; if (!t || t.type === 'audio') switch (e.details) { case o.a.FRAG_LOAD_ERROR: case o.a.FRAG_LOAD_TIMEOUT: var r = e.frag; if (r && r.type !== 'audio') break; if (!e.fatal) { let i = this.fragLoadError; i ? i++ : i = 1; const a = this.config; if (i <= a.fragLoadingMaxRetry) { this.fragLoadError = i; const n = Math.min(Math.pow(2, i - 1) * a.fragLoadingRetryDelay, a.fragLoadingMaxRetryTimeout); d.b.warn(`AudioStreamController: frag loading failed, retry in ${n} ms`), this.retryDate = nt.now() + n, this.state = Se; } else d.b.error(`AudioStreamController: ${e.details} reaches max retry, redispatch as fatal ...`), e.fatal = !0, this.state = Le; } break; case o.a.AUDIO_TRACK_LOAD_ERROR: case o.a.AUDIO_TRACK_LOAD_TIMEOUT: case o.a.KEY_LOAD_ERROR: case o.a.KEY_LOAD_TIMEOUT: this.state !== Le && (this.state = e.fatal ? Le : ye, d.b.warn(`AudioStreamController: ${e.details} while loading frag, now switching to ${this.state} state ...`)); break; case o.a.BUFFER_FULL_ERROR: if (e.parent === 'audio' && (this.state === Ae || this.state === Re)) { const s = this.mediaBuffer; const l = this.media.currentTime; if (s && V.isBuffered(s, l) && V.isBuffered(s, l + 0.5)) { const c = this.config; c.maxMaxBufferLength >= c.maxBufferLength && (c.maxMaxBufferLength /= 2, d.b.warn(`AudioStreamController: reduce max buffer length to ${c.maxMaxBufferLength}s`)), this.state = ye; } else d.b.warn('AudioStreamController: buffer full error also media.currentTime is not buffered, flush audio buffer'), this.fragCurrent = null, this.state = we, this.hls.trigger(u.a.BUFFER_FLUSHING, { startOffset: 0, endOffset: Number.POSITIVE_INFINITY, type: 'audio' }); } } }, c.onBufferFlushed = function() { const e = this; const t = this.pendingData; t && t.length ? (d.b.log('AudioStreamController: appending pending audio data after buffer flushed'), t.forEach(((t) => { e.hls.trigger(u.a.BUFFER_APPENDING, t); })), this.appended = !0, this.pendingData = [], this.state = Re) : (this.state = ye, this.fragPrevious = null, this.tick()); }, a = i, (n = [{ key: 'state', set(e) { if (this.state !== e) { const t = this.state; this._state = e, d.b.log(`audio stream:${t}->${e}`); } }, get() { return this._state; } }]) && at(a.prototype, n), s && at(a, s), i; }(Ie)); const ot = (function() { if (typeof window !== 'undefined' && window.VTTCue) return window.VTTCue; const e = { '': !0, lr: !0, rl: !0 }; const t = { start: !0, middle: !0, end: !0, left: !0, right: !0 }; function r(e) { return typeof e === 'string' && (!!t[e.toLowerCase()] && e.toLowerCase()); } function i(e) { for (let t = 1; t < arguments.length; t++) { const r = arguments[t]; for (const i in r)e[i] = r[i]; } return e; } function a(t, a, n) { const s = this; const o = { enumerable: !0 }; s.hasBeenReset = !1; let l = ''; let u = !1; let d = t; let c = a; let h = n; let f = null; let g = ''; let p = !0; let v = 'auto'; let m = 'start'; let y = 50; let b = 'middle'; let T = 50; let E = 'middle'; Object.defineProperty(s, 'id', i({}, o, { get() { return l; }, set(e) { l = `${e}`; } })), Object.defineProperty(s, 'pauseOnExit', i({}, o, { get() { return u; }, set(e) { u = !!e; } })), Object.defineProperty(s, 'startTime', i({}, o, { get() { return d; }, set(e) { if (typeof e !== 'number') throw new TypeError('Start time must be set to a number.'); d = e, this.hasBeenReset = !0; } })), Object.defineProperty(s, 'endTime', i({}, o, { get() { return c; }, set(e) { if (typeof e !== 'number') throw new TypeError('End time must be set to a number.'); c = e, this.hasBeenReset = !0; } })), Object.defineProperty(s, 'text', i({}, o, { get() { return h; }, set(e) { h = `${e}`, this.hasBeenReset = !0; } })), Object.defineProperty(s, 'region', i({}, o, { get() { return f; }, set(e) { f = e, this.hasBeenReset = !0; } })), Object.defineProperty(s, 'vertical', i({}, o, { get() { return g; }, set(t) { const r = (function(t) { return typeof t === 'string' && (!!e[t.toLowerCase()] && t.toLowerCase()); }(t)); if (!1 === r) throw new SyntaxError('An invalid or illegal string was specified.'); g = r, this.hasBeenReset = !0; } })), Object.defineProperty(s, 'snapToLines', i({}, o, { get() { return p; }, set(e) { p = !!e, this.hasBeenReset = !0; } })), Object.defineProperty(s, 'line', i({}, o, { get() { return v; }, set(e) { if (typeof e !== 'number' && e !== 'auto') throw new SyntaxError('An invalid number or illegal string was specified.'); v = e, this.hasBeenReset = !0; } })), Object.defineProperty(s, 'lineAlign', i({}, o, { get() { return m; }, set(e) { const t = r(e); if (!t) throw new SyntaxError('An invalid or illegal string was specified.'); m = t, this.hasBeenReset = !0; } })), Object.defineProperty(s, 'position', i({}, o, { get() { return y; }, set(e) { if (e < 0 || e > 100) throw new Error('Position must be between 0 and 100.'); y = e, this.hasBeenReset = !0; } })), Object.defineProperty(s, 'positionAlign', i({}, o, { get() { return b; }, set(e) { const t = r(e); if (!t) throw new SyntaxError('An invalid or illegal string was specified.'); b = t, this.hasBeenReset = !0; } })), Object.defineProperty(s, 'size', i({}, o, { get() { return T; }, set(e) { if (e < 0 || e > 100) throw new Error('Size must be between 0 and 100.'); T = e, this.hasBeenReset = !0; } })), Object.defineProperty(s, 'align', i({}, o, { get() { return E; }, set(e) { const t = r(e); if (!t) throw new SyntaxError('An invalid or illegal string was specified.'); E = t, this.hasBeenReset = !0; } })), s.displayState = void 0; } return a.prototype.getCueAsHTML = function() { return window.WebVTT.convertCueToDOMTree(window, this.text); }, a; }()); const lt = function() { return { decode(e) { if (!e) return ''; if (typeof e !== 'string') throw new Error('Error - expected string data.'); return decodeURIComponent(encodeURIComponent(e)); } }; }; function ut() { this.window = window, this.state = 'INITIAL', this.buffer = '', this.decoder = new lt(), this.regionList = []; } function dt() { this.values = Object.create(null); } function ct(e, t, r, i) { const a = i ? e.split(i) : [e]; for (const n in a) if (typeof a[n] === 'string') { const s = a[n].split(r); if (s.length === 2)t(s[0], s[1]); } }dt.prototype = { set(e, t) { this.get(e) || t === '' || (this.values[e] = t); }, get(e, t, r) { return r ? this.has(e) ? this.values[e] : t[r] : this.has(e) ? this.values[e] : t; }, has(e) { return e in this.values; }, alt(e, t, r) { for (let i = 0; i < r.length; ++i) if (t === r[i]) { this.set(e, t); break; } }, integer(e, t) { /^-?\d+$/.test(t) && this.set(e, parseInt(t, 10)); }, percent(e, t) { return !!(t.match(/^([\d]{1,3})(\.[\d]*)?%$/) && (t = parseFloat(t)) >= 0 && t <= 100) && (this.set(e, t), !0); } }; const ht = new ot(0, 0, 0); const ft = ht.align === 'middle' ? 'middle' : 'center'; function gt(e, t, r) { const i = e; function a() { const t = (function(e) { function t(e, t, r, i) { return 3600 * (0 | e) + 60 * (0 | t) + (0 | r) + (0 | i) / 1e3; } const r = e.match(/^(\d+):(\d{2})(:\d{2})?\.(\d{3})/); return r ? r[3] ? t(r[1], r[2], r[3].replace(':', ''), r[4]) : r[1] > 59 ? t(r[1], r[2], 0, r[4]) : t(0, r[1], r[2], r[4]) : null; }(e)); if (t === null) throw new Error(`Malformed timestamp: ${i}`); return e = e.replace(/^[^\sa-zA-Z-]+/, ''), t; } function n() { e = e.replace(/^\s+/, ''); } if (n(), t.startTime = a(), n(), e.substr(0, 3) !== '--\x3e') throw new Error(`Malformed time stamp (time stamps must be separated by '--\x3e'): ${i}`); e = e.substr(3), n(), t.endTime = a(), n(), (function(e, t) { const i = new dt(); ct(e, ((e, t) => { switch (e) { case 'region': for (let a = r.length - 1; a >= 0; a--) if (r[a].id === t) { i.set(e, r[a].region); break; } break; case 'vertical': i.alt(e, t, ['rl', 'lr']); break; case 'line': var n = t.split(','); var s = n[0]; i.integer(e, s), i.percent(e, s) && i.set('snapToLines', !1), i.alt(e, s, ['auto']), n.length === 2 && i.alt('lineAlign', n[1], ['start', ft, 'end']); break; case 'position': n = t.split(','), i.percent(e, n[0]), n.length === 2 && i.alt('positionAlign', n[1], ['start', ft, 'end', 'line-left', 'line-right', 'auto']); break; case 'size': i.percent(e, t); break; case 'align': i.alt(e, t, ['start', ft, 'end', 'left', 'right']); } }), /:/, /\s/), t.region = i.get('region', null), t.vertical = i.get('vertical', ''); let a = i.get('line', 'auto'); a === 'auto' && ht.line === -1 && (a = -1), t.line = a, t.lineAlign = i.get('lineAlign', 'start'), t.snapToLines = i.get('snapToLines', !0), t.size = i.get('size', 100), t.align = i.get('align', ft); let n = i.get('position', 'auto'); n === 'auto' && ht.position === 50 && (n = t.align === 'start' || t.align === 'left' ? 0 : t.align === 'end' || t.align === 'right' ? 100 : 50), t.position = n; }(e, t)); } function pt(e) { return e.replace(/<br(?: \/)?>/gi, '\n'); }ut.prototype = { parse(e) { const t = this; function r() { let e = t.buffer; let r = 0; for (e = pt(e); r < e.length && e[r] !== '\r' && e[r] !== '\n';)++r; const i = e.substr(0, r); return e[r] === '\r' && ++r, e[r] === '\n' && ++r, t.buffer = e.substr(r), i; }e && (t.buffer += t.decoder.decode(e, { stream: !0 })); try { let i; if (t.state === 'INITIAL') { if (!/\r\n|\n/.test(t.buffer)) return this; const a = (i = r()).match(/^()?WEBVTT([ \t].*)?$/); if (!a || !a[0]) throw new Error('Malformed WebVTT signature.'); t.state = 'HEADER'; } for (let n = !1; t.buffer;) { if (!/\r\n|\n/.test(t.buffer)) return this; switch (n ? n = !1 : i = r(), t.state) { case 'HEADER': /:/.test(i) ? ct(i, ((e, t) => {}), /:/) : i || (t.state = 'ID'); continue; case 'NOTE': i || (t.state = 'ID'); continue; case 'ID': if (/^NOTE($|[ \t])/.test(i)) { t.state = 'NOTE'; break; } if (!i) continue; if (t.cue = new ot(0, 0, ''), t.state = 'CUE', i.indexOf('--\x3e') === -1) { t.cue.id = i; continue; } case 'CUE': try { gt(i, t.cue, t.regionList); } catch (e) { t.cue = null, t.state = 'BADCUE'; continue; }t.state = 'CUETEXT'; continue; case 'CUETEXT': var s = i.indexOf('--\x3e') !== -1; if (!i || s && (n = !0)) { t.oncue && t.oncue(t.cue), t.cue = null, t.state = 'ID'; continue; }t.cue.text && (t.cue.text += '\n'), t.cue.text += i; continue; case 'BADCUE': i || (t.state = 'ID'); continue; } } } catch (e) { t.state === 'CUETEXT' && t.cue && t.oncue && t.oncue(t.cue), t.cue = null, t.state = t.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE'; } return this; }, flush() { try { if (this.buffer += this.decoder.decode(), (this.cue || this.state === 'HEADER') && (this.buffer += '\n\n', this.parse()), this.state === 'INITIAL') throw new Error('Malformed WebVTT signature.'); } catch (e) { throw e; } return this.onflush && this.onflush(), this; } }; const vt = ut; function mt(e, t, r, i) { for (var a, n, s, o, l, u = window.VTTCue || TextTrackCue, d = 0; d < i.rows.length; d++) if (s = !0, o = 0, l = '', !(a = i.rows[d]).isEmpty()) { for (let c = 0; c < a.chars.length; c++)a.chars[c].uchar.match(/\s/) && s ? o++ : (l += a.chars[c].uchar, s = !1); a.cueStartTime = t, t === r && (r += 1e-4), n = new u(t, r, pt(l.trim())), o >= 16 ? o-- : o++, navigator.userAgent.match(/Firefox\//) ? n.line = d + 1 : n.line = d > 7 ? d - 2 : d + 1, n.align = 'left', n.position = Math.max(0, Math.min(100, o / 32 * 100)), e.addCue(n); } } let yt; const bt = { 42: 225, 92: 233, 94: 237, 95: 243, 96: 250, 123: 231, 124: 247, 125: 209, 126: 241, 127: 9608, 128: 174, 129: 176, 130: 189, 131: 191, 132: 8482, 133: 162, 134: 163, 135: 9834, 136: 224, 137: 32, 138: 232, 139: 226, 140: 234, 141: 238, 142: 244, 143: 251, 144: 193, 145: 201, 146: 211, 147: 218, 148: 220, 149: 252, 150: 8216, 151: 161, 152: 42, 153: 8217, 154: 9473, 155: 169, 156: 8480, 157: 8226, 158: 8220, 159: 8221, 160: 192, 161: 194, 162: 199, 163: 200, 164: 202, 165: 203, 166: 235, 167: 206, 168: 207, 169: 239, 170: 212, 171: 217, 172: 249, 173: 219, 174: 171, 175: 187, 176: 195, 177: 227, 178: 205, 179: 204, 180: 236, 181: 210, 182: 242, 183: 213, 184: 245, 185: 123, 186: 125, 187: 92, 188: 94, 189: 95, 190: 124, 191: 8764, 192: 196, 193: 228, 194: 214, 195: 246, 196: 223, 197: 165, 198: 164, 199: 9475, 200: 197, 201: 229, 202: 216, 203: 248, 204: 9487, 205: 9491, 206: 9495, 207: 9499 }; const Tt = function(e) { let t = e; return bt.hasOwnProperty(e) && (t = bt[e]), String.fromCharCode(t); }; const Et = { 17: 1, 18: 3, 21: 5, 22: 7, 23: 9, 16: 11, 19: 12, 20: 14 }; const St = { 17: 2, 18: 4, 21: 6, 22: 8, 23: 10, 19: 13, 20: 15 }; const _t = { 25: 1, 26: 3, 29: 5, 30: 7, 31: 9, 24: 11, 27: 12, 28: 14 }; const At = { 25: 2, 26: 4, 29: 6, 30: 8, 31: 10, 27: 13, 28: 15 }; const Rt = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent']; !(function(e) { e[e.ERROR = 0] = 'ERROR', e[e.TEXT = 1] = 'TEXT', e[e.WARNING = 2] = 'WARNING', e[e.INFO = 2] = 'INFO', e[e.DEBUG = 3] = 'DEBUG', e[e.DATA = 3] = 'DATA'; }(yt || (yt = {}))); const wt = { verboseFilter: { DATA: 3, DEBUG: 3, INFO: 2, WARNING: 2, TEXT: 1, ERROR: 0 }, time: null, verboseLevel: 0, setTime(e) { this.time = e; }, log(e, t) { this.verboseFilter[e]; this.verboseLevel; } }; const kt = function(e) { for (var t = [], r = 0; r < e.length; r++)t.push(e[r].toString(16)); return t; }; const Lt = (function() { function e(e, t, r, i, a) { this.foreground = void 0, this.underline = void 0, this.italics = void 0, this.background = void 0, this.flash = void 0, this.foreground = e || 'white', this.underline = t || !1, this.italics = r || !1, this.background = i || 'black', this.flash = a || !1; } const t = e.prototype; return t.reset = function() { this.foreground = 'white', this.underline = !1, this.italics = !1, this.background = 'black', this.flash = !1; }, t.setStyles = function(e) { for (let t = ['foreground', 'underline', 'italics', 'background', 'flash'], r = 0; r < t.length; r++) { const i = t[r]; e.hasOwnProperty(i) && (this[i] = e[i]); } }, t.isDefault = function() { return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash; }, t.equals = function(e) { return this.foreground === e.foreground && this.underline === e.underline && this.italics === e.italics && this.background === e.background && this.flash === e.flash; }, t.copy = function(e) { this.foreground = e.foreground, this.underline = e.underline, this.italics = e.italics, this.background = e.background, this.flash = e.flash; }, t.toString = function() { return `color=${this.foreground}, underline=${this.underline}, italics=${this.italics}, background=${this.background}, flash=${this.flash}`; }, e; }()); const Dt = (function() { function e(e, t, r, i, a, n) { this.uchar = void 0, this.penState = void 0, this.uchar = e || ' ', this.penState = new Lt(t, r, i, a, n); } const t = e.prototype; return t.reset = function() { this.uchar = ' ', this.penState.reset(); }, t.setChar = function(e, t) { this.uchar = e, this.penState.copy(t); }, t.setPenState = function(e) { this.penState.copy(e); }, t.equals = function(e) { return this.uchar === e.uchar && this.penState.equals(e.penState); }, t.copy = function(e) { this.uchar = e.uchar, this.penState.copy(e.penState); }, t.isEmpty = function() { return this.uchar === ' ' && this.penState.isDefault(); }, e; }()); const Ct = (function() { function e() { this.chars = void 0, this.pos = void 0, this.currPenState = void 0, this.cueStartTime = void 0, this.chars = []; for (let e = 0; e < 100; e++) this.chars.push(new Dt()); this.pos = 0, this.currPenState = new Lt(); } const t = e.prototype; return t.equals = function(e) { for (var t = !0, r = 0; r < 100; r++) if (!this.chars[r].equals(e.chars[r])) { t = !1; break; } return t; }, t.copy = function(e) { for (let t = 0; t < 100; t++) this.chars[t].copy(e.chars[t]); }, t.isEmpty = function() { for (var e = !0, t = 0; t < 100; t++) if (!this.chars[t].isEmpty()) { e = !1; break; } return e; }, t.setCursor = function(e) { this.pos !== e && (this.pos = e), this.pos < 0 ? (wt.log('ERROR', `Negative cursor position ${this.pos}`), this.pos = 0) : this.pos > 100 && (wt.log('ERROR', `Too large cursor position ${this.pos}`), this.pos = 100); }, t.moveCursor = function(e) { const t = this.pos + e; if (e > 1) for (let r = this.pos + 1; r < t + 1; r++) this.chars[r].setPenState(this.currPenState); this.setCursor(t); }, t.backSpace = function() { this.moveCursor(-1), this.chars[this.pos].setChar(' ', this.currPenState); }, t.insertChar = function(e) { e >= 144 && this.backSpace(); const t = Tt(e); this.pos >= 100 ? wt.log('ERROR', `Cannot insert ${e.toString(16)} (${t}) at position ${this.pos}. Skipping it!`) : (this.chars[this.pos].setChar(t, this.currPenState), this.moveCursor(1)); }, t.clearFromPos = function(e) { let t; for (t = e; t < 100; t++) this.chars[t].reset(); }, t.clear = function() { this.clearFromPos(0), this.pos = 0, this.currPenState.reset(); }, t.clearToEndOfRow = function() { this.clearFromPos(this.pos); }, t.getTextString = function() { for (var e = [], t = !0, r = 0; r < 100; r++) { const i = this.chars[r].uchar; i !== ' ' && (t = !1), e.push(i); } return t ? '' : e.join(''); }, t.setPenStyles = function(e) { this.currPenState.setStyles(e), this.chars[this.pos].setPenState(this.currPenState); }, e; }()); const It = (function() { function e() { this.rows = void 0, this.currRow = void 0, this.nrRollUpRows = void 0, this.lastOutputScreen = void 0, this.rows = []; for (let e = 0; e < 15; e++) this.rows.push(new Ct()); this.currRow = 14, this.nrRollUpRows = null, this.reset(); } const t = e.prototype; return t.reset = function() { for (let e = 0; e < 15; e++) this.rows[e].clear(); this.currRow = 14; }, t.equals = function(e) { for (var t = !0, r = 0; r < 15; r++) if (!this.rows[r].equals(e.rows[r])) { t = !1; break; } return t; }, t.copy = function(e) { for (let t = 0; t < 15; t++) this.rows[t].copy(e.rows[t]); }, t.isEmpty = function() { for (var e = !0, t = 0; t < 15; t++) if (!this.rows[t].isEmpty()) { e = !1; break; } return e; }, t.backSpace = function() { this.rows[this.currRow].backSpace(); }, t.clearToEndOfRow = function() { this.rows[this.currRow].clearToEndOfRow(); }, t.insertChar = function(e) { this.rows[this.currRow].insertChar(e); }, t.setPen = function(e) { this.rows[this.currRow].setPenStyles(e); }, t.moveCursor = function(e) { this.rows[this.currRow].moveCursor(e); }, t.setCursor = function(e) { wt.log('INFO', `setCursor: ${e}`), this.rows[this.currRow].setCursor(e); }, t.setPAC = function(e) { wt.log('INFO', `pacData = ${JSON.stringify(e)}`); let t = e.row - 1; if (this.nrRollUpRows && t < this.nrRollUpRows - 1 && (t = this.nrRollUpRows - 1), this.nrRollUpRows && this.currRow !== t) { for (let r = 0; r < 15; r++) this.rows[r].clear(); const i = this.currRow + 1 - this.nrRollUpRows; const a = this.lastOutputScreen; if (a) { const n = a.rows[i].cueStartTime; if (n && wt.time && n < wt.time) for (let s = 0; s < this.nrRollUpRows; s++) this.rows[t - this.nrRollUpRows + s + 1].copy(a.rows[i + s]); } } this.currRow = t; const o = this.rows[this.currRow]; if (e.indent !== null) { const l = e.indent; const u = Math.max(l - 1, 0); o.setCursor(e.indent), e.color = o.chars[u].penState.foreground; } const d = { foreground: e.color, underline: e.underline, italics: e.italics, background: 'black', flash: !1 }; this.setPen(d); }, t.setBkgData = function(e) { wt.log('INFO', `bkgData = ${JSON.stringify(e)}`), this.backSpace(), this.setPen(e), this.insertChar(32); }, t.setRollUpRows = function(e) { this.nrRollUpRows = e; }, t.rollUp = function() { if (this.nrRollUpRows !== null) { wt.log('TEXT', this.getDisplayText()); const e = this.currRow + 1 - this.nrRollUpRows; const t = this.rows.splice(e, 1)[0]; t.clear(), this.rows.splice(this.currRow, 0, t), wt.log('INFO', 'Rolling up'); } else wt.log('DEBUG', 'roll_up but nrRollUpRows not set yet'); }, t.getDisplayText = function(e) { e = e || !1; for (var t = [], r = '', i = -1, a = 0; a < 15; a++) { const n = this.rows[a].getTextString(); n && (i = a + 1, e ? t.push(`Row ${i}: '${n}'`) : t.push(n.trim())); } return t.length > 0 && (r = e ? `[${t.join(' | ')}]` : t.join('\n')), r; }, t.getTextAndFormat = function() { return this.rows; }, e; }()); const Ot = (function() { function e(e, t) { this.chNr = void 0, this.outputFilter = void 0, this.mode = void 0, this.verbose = void 0, this.displayedMemory = void 0, this.nonDisplayedMemory = void 0, this.lastOutputScreen = void 0, this.currRollUpRow = void 0, this.writeScreen = void 0, this.cueStartTime = void 0, this.lastCueEndTime = void 0, this.chNr = e, this.outputFilter = t, this.mode = null, this.verbose = 0, this.displayedMemory = new It(), this.nonDisplayedMemory = new It(), this.lastOutputScreen = new It(), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null; } const t = e.prototype; return t.reset = function() { this.mode = null, this.displayedMemory.reset(), this.nonDisplayedMemory.reset(), this.lastOutputScreen.reset(), this.currRollUpRow = this.displayedMemory.rows[14], this.writeScreen = this.displayedMemory, this.mode = null, this.cueStartTime = null; }, t.getHandler = function() { return this.outputFilter; }, t.setHandler = function(e) { this.outputFilter = e; }, t.setPAC = function(e) { this.writeScreen.setPAC(e); }, t.setBkgData = function(e) { this.writeScreen.setBkgData(e); }, t.setMode = function(e) { e !== this.mode && (this.mode = e, wt.log('INFO', `MODE=${e}`), this.mode === 'MODE_POP-ON' ? this.writeScreen = this.nonDisplayedMemory : (this.writeScreen = this.displayedMemory, this.writeScreen.reset()), this.mode !== 'MODE_ROLL-UP' && (this.displayedMemory.nrRollUpRows = null, this.nonDisplayedMemory.nrRollUpRows = null), this.mode = e); }, t.insertChars = function(e) { for (let t = 0; t < e.length; t++) this.writeScreen.insertChar(e[t]); const r = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP'; wt.log('INFO', `${r}: ${this.writeScreen.getDisplayText(!0)}`), this.mode !== 'MODE_PAINT-ON' && this.mode !== 'MODE_ROLL-UP' || (wt.log('TEXT', `DISPLAYED: ${this.displayedMemory.getDisplayText(!0)}`), this.outputDataUpdate()); }, t.ccRCL = function() { wt.log('INFO', 'RCL - Resume Caption Loading'), this.setMode('MODE_POP-ON'); }, t.ccBS = function() { wt.log('INFO', 'BS - BackSpace'), this.mode !== 'MODE_TEXT' && (this.writeScreen.backSpace(), this.writeScreen === this.displayedMemory && this.outputDataUpdate()); }, t.ccAOF = function() {}, t.ccAON = function() {}, t.ccDER = function() { wt.log('INFO', 'DER- Delete to End of Row'), this.writeScreen.clearToEndOfRow(), this.outputDataUpdate(); }, t.ccRU = function(e) { wt.log('INFO', `RU(${e}) - Roll Up`), this.writeScreen = this.displayedMemory, this.setMode('MODE_ROLL-UP'), this.writeScreen.setRollUpRows(e); }, t.ccFON = function() { wt.log('INFO', 'FON - Flash On'), this.writeScreen.setPen({ flash: !0 }); }, t.ccRDC = function() { wt.log('INFO', 'RDC - Resume Direct Captioning'), this.setMode('MODE_PAINT-ON'); }, t.ccTR = function() { wt.log('INFO', 'TR'), this.setMode('MODE_TEXT'); }, t.ccRTD = function() { wt.log('INFO', 'RTD'), this.setMode('MODE_TEXT'); }, t.ccEDM = function() { wt.log('INFO', 'EDM - Erase Displayed Memory'), this.displayedMemory.reset(), this.outputDataUpdate(!0); }, t.ccCR = function() { wt.log('INFO', 'CR - Carriage Return'), this.writeScreen.rollUp(), this.outputDataUpdate(!0); }, t.ccENM = function() { wt.log('INFO', 'ENM - Erase Non-displayed Memory'), this.nonDisplayedMemory.reset(); }, t.ccEOC = function() { if (wt.log('INFO', 'EOC - End Of Caption'), this.mode === 'MODE_POP-ON') { const e = this.displayedMemory; this.displayedMemory = this.nonDisplayedMemory, this.nonDisplayedMemory = e, this.writeScreen = this.nonDisplayedMemory, wt.log('TEXT', `DISP: ${this.displayedMemory.getDisplayText()}`); } this.outputDataUpdate(!0); }, t.ccTO = function(e) { wt.log('INFO', `TO(${e}) - Tab Offset`), this.writeScreen.moveCursor(e); }, t.ccMIDROW = function(e) { const t = { flash: !1 }; if (t.underline = e % 2 == 1, t.italics = e >= 46, t.italics)t.foreground = 'white'; else { const r = Math.floor(e / 2) - 16; t.foreground = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'][r]; }wt.log('INFO', `MIDROW: ${JSON.stringify(t)}`), this.writeScreen.setPen(t); }, t.outputDataUpdate = function(e) { void 0 === e && (e = !1); const t = wt.time; t !== null && this.outputFilter && (this.cueStartTime !== null || this.displayedMemory.isEmpty() ? this.displayedMemory.equals(this.lastOutputScreen) || (this.outputFilter.newCue(this.cueStartTime, t, this.lastOutputScreen), e && this.outputFilter.dispatchCue && this.outputFilter.dispatchCue(), this.cueStartTime = this.displayedMemory.isEmpty() ? null : t) : this.cueStartTime = t, this.lastOutputScreen.copy(this.displayedMemory)); }, t.cueSplitAtTime = function(e) { this.outputFilter && (this.displayedMemory.isEmpty() || (this.outputFilter.newCue && this.outputFilter.newCue(this.cueStartTime, e, this.displayedMemory), this.cueStartTime = e)); }, e; }()); const xt = (function() { function e(e, t, r) { this.field = void 0, this.outputs = void 0, this.channels = void 0, this.currChNr = void 0, this.lastCmdA = void 0, this.lastCmdB = void 0, this.lastTime = void 0, this.dataCounters = void 0, this.field = e || 1, this.outputs = [t, r], this.channels = [new Ot(1, t), new Ot(2, r)], this.currChNr = -1, this.lastCmdA = null, this.lastCmdB = null, this.lastTime = null, this.dataCounters = { padding: 0, char: 0, cmd: 0, other: 0 }; } const t = e.prototype; return t.getHandler = function(e) { return this.channels[e].getHandler(); }, t.setHandler = function(e, t) { this.channels[e].setHandler(t); }, t.addData = function(e, t) { let r; let i; let a; let n = !1; this.lastTime = e, wt.setTime(e); for (let s = 0; s < t.length; s += 2) if (i = 127 & t[s], a = 127 & t[s + 1], i !== 0 || a !== 0) { if (wt.log('DATA', `[${kt([t[s], t[s + 1]])}] -> (${kt([i, a])})`), (r = this.parseCmd(i, a)) || (r = this.parseMidrow(i, a)), r || (r = this.parsePAC(i, a)), r || (r = this.parseBackgroundAttributes(i, a)), !r) if (n = this.parseChars(i, a)) if (this.currChNr && this.currChNr >= 0) this.channels[this.currChNr - 1].insertChars(n); else wt.log('WARNING', 'No channel found yet. TEXT-MODE?'); r ? this.dataCounters.cmd += 2 : n ? this.dataCounters.char += 2 : (this.dataCounters.other += 2, wt.log('WARNING', `Couldn't parse cleaned data ${kt([i, a])} orig: ${kt([t[s], t[s + 1]])}`)); } else this.dataCounters.padding += 2; }, t.parseCmd = function(e, t) { let r = null; if (!((e === 20 || e === 28) && t >= 32 && t <= 47) && !((e === 23 || e === 31) && t >= 33 && t <= 35)) return !1; if (e === this.lastCmdA && t === this.lastCmdB) return this.lastCmdA = null, this.lastCmdB = null, wt.log('DEBUG', `Repeated command (${kt([e, t])}) is dropped`), !0; r = e === 20 || e === 23 ? 1 : 2; const i = this.channels[r - 1]; return e === 20 || e === 28 ? t === 32 ? i.ccRCL() : t === 33 ? i.ccBS() : t === 34 ? i.ccAOF() : t === 35 ? i.ccAON() : t === 36 ? i.ccDER() : t === 37 ? i.ccRU(2) : t === 38 ? i.ccRU(3) : t === 39 ? i.ccRU(4) : t === 40 ? i.ccFON() : t === 41 ? i.ccRDC() : t === 42 ? i.ccTR() : t === 43 ? i.ccRTD() : t === 44 ? i.ccEDM() : t === 45 ? i.ccCR() : t === 46 ? i.ccENM() : t === 47 && i.ccEOC() : i.ccTO(t - 32), this.lastCmdA = e, this.lastCmdB = t, this.currChNr = r, !0; }, t.parseMidrow = function(e, t) { let r = null; return (e === 17 || e === 25) && t >= 32 && t <= 47 && ((r = e === 17 ? 1 : 2) !== this.currChNr ? (wt.log('ERROR', 'Mismatch channel in midrow parsing'), !1) : (this.channels[r - 1].ccMIDROW(t), wt.log('DEBUG', `MIDROW (${kt([e, t])})`), !0)); }, t.parsePAC = function(e, t) { let r; let i = null; if (!((e >= 17 && e <= 23 || e >= 25 && e <= 31) && t >= 64 && t <= 127) && !((e === 16 || e === 24) && t >= 64 && t <= 95)) return !1; if (e === this.lastCmdA && t === this.lastCmdB) return this.lastCmdA = null, this.lastCmdB = null, !0; r = e <= 23 ? 1 : 2, i = t >= 64 && t <= 95 ? r === 1 ? Et[e] : _t[e] : r === 1 ? St[e] : At[e]; const a = this.interpretPAC(i, t); return this.channels[r - 1].setPAC(a), this.lastCmdA = e, this.lastCmdB = t, this.currChNr = r, !0; }, t.interpretPAC = function(e, t) { let r = t; const i = { color: null, italics: !1, indent: null, underline: !1, row: e }; return r = t > 95 ? t - 96 : t - 64, i.underline = (1 & r) == 1, r <= 13 ? i.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(r / 2)] : r <= 15 ? (i.italics = !0, i.color = 'white') : i.indent = 4 * Math.floor((r - 16) / 2), i; }, t.parseChars = function(e, t) { let r = null; let i = null; let a = null; if (e >= 25 ? (r = 2, a = e - 8) : (r = 1, a = e), a >= 17 && a <= 19) { let n = t; n = a === 17 ? t + 80 : a === 18 ? t + 112 : t + 144, wt.log('INFO', `Special char '${Tt(n)}' in channel ${r}`), i = [n]; } else e >= 32 && e <= 127 && (i = t === 0 ? [e] : [e, t]); if (i) { const s = kt(i); wt.log('DEBUG', `Char codes =  ${s.join(',')}`), this.lastCmdA = null, this.lastCmdB = null; } return i; }, t.parseBackgroundAttributes = function(e, t) { let r; let i; let a; return ((e === 16 || e === 24) && t >= 32 && t <= 47 || (e === 23 || e === 31) && t >= 45 && t <= 47) && (r = {}, e === 16 || e === 24 ? (i = Math.floor((t - 32) / 2), r.background = Rt[i], t % 2 == 1 && (r.background += '_semi')) : t === 45 ? r.background = 'transparent' : (r.foreground = 'black', t === 47 && (r.underline = !0)), a = e < 24 ? 1 : 2, this.channels[a - 1].setBkgData(r), this.lastCmdA = null, this.lastCmdB = null, !0); }, t.reset = function() { for (let e = 0; e < this.channels.length; e++) this.channels[e] && this.channels[e].reset(); this.lastCmdA = null, this.lastCmdB = null; }, t.cueSplitAtTime = function(e) { for (let t = 0; t < this.channels.length; t++) this.channels[t] && this.channels[t].cueSplitAtTime(e); }, e; }()); const Pt = (function() { function e(e, t) { this.timelineController = void 0, this.trackName = void 0, this.startTime = void 0, this.endTime = void 0, this.screen = void 0, this.timelineController = e, this.trackName = t, this.startTime = null, this.endTime = null, this.screen = null; } const t = e.prototype; return t.dispatchCue = function() { this.startTime !== null && (this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen), this.startTime = null); }, t.newCue = function(e, t, r) { (this.startTime === null || this.startTime > e) && (this.startTime = e), this.endTime = t, this.screen = r, this.timelineController.createCaptionsTrack(this.trackName); }, e; }()); const Mt = function(e, t, r) { return e.substr(r || 0, t.length) === t; }; const Ft = function(e) { for (var t = 5381, r = e.length; r;)t = 33 * t ^ e.charCodeAt(--r); return (t >>> 0).toString(); }; const Ut = { parse(e, t, r, i, a, n) { let s; const o = Object(Ue.b)(new Uint8Array(e)).trim().replace(/\r\n|\n\r|\n|\r/g, '\n').split('\n'); let u = '00:00.000'; let d = 0; let c = 0; let h = 0; const f = []; let g = !0; let p = !1; const v = new vt(); v.oncue = function(e) { const t = r[i]; let a = r.ccOffset; t && t.new && (void 0 !== c ? a = r.ccOffset = t.start : (function(e, t, r) { let i = e[t]; let a = e[i.prevCC]; if (!a || !a.new && i.new) return e.ccOffset = e.presentationOffset = i.start, void (i.new = !1); for (;a && a.new;)e.ccOffset += i.start - a.start, i.new = !1, a = e[(i = a).prevCC]; e.presentationOffset = r; }(r, i, h))), h && (a = h - r.presentationOffset), p && (e.startTime += a - c, e.endTime += a - c), e.id = Ft(e.startTime.toString()) + Ft(e.endTime.toString()) + Ft(e.text), e.text = decodeURIComponent(encodeURIComponent(e.text)), e.endTime > 0 && f.push(e); }, v.onparsingerror = function(e) { s = e; }, v.onflush = function() { s && n ? n(s) : a(f); }, o.forEach(((e) => { if (g) { if (Mt(e, 'X-TIMESTAMP-MAP=')) { g = !1, p = !0, e.substr(16).split(',').forEach(((e) => { Mt(e, 'LOCAL:') ? u = e.substr(6) : Mt(e, 'MPEGTS:') && (d = parseInt(e.substr(7))); })); try { t + (9e4 * r[i].start || 0) < 0 && (t += 8589934592), d -= t, c = (function(e) { let t = parseInt(e.substr(-3)); const r = parseInt(e.substr(-6, 2)); const i = parseInt(e.substr(-9, 2)); const a = e.length > 9 ? parseInt(e.substr(0, e.indexOf(':'))) : 0; if (!(Object(l.a)(t) && Object(l.a)(r) && Object(l.a)(i) && Object(l.a)(a))) throw Error(`Malformed X-TIMESTAMP-MAP: Local:${e}`); return t += 1e3 * r, t += 6e4 * i, t += 36e5 * a; }(u)) / 1e3, h = d / 9e4; } catch (e) { p = !1, s = e; } return; }e === '' && (g = !1); }v.parse(`${e}\n`); })), v.flush(); } }; function Nt(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; } function Bt(e, t) { return e && e.label === t.name && !(e.textTrack1 || e.textTrack2); } const Gt = (function(e) { let t; let r; function i(t) { let r; if ((r = e.call(this, t, u.a.MEDIA_ATTACHING, u.a.MEDIA_DETACHING, u.a.FRAG_PARSING_USERDATA, u.a.FRAG_DECRYPTED, u.a.MANIFEST_LOADING, u.a.MANIFEST_LOADED, u.a.FRAG_LOADED, u.a.INIT_PTS_FOUND) || this).media = null, r.config = void 0, r.enabled = !0, r.Cues = void 0, r.textTracks = [], r.tracks = [], r.initPTS = [], r.unparsedVttFrags = [], r.cueRanges = [], r.captionsTracks = {}, r.captionsProperties = void 0, r.cea608Parser = void 0, r.lastSn = -1, r.prevCC = -1, r.vttCCs = null, r.hls = t, r.config = t.config, r.Cues = t.config.cueHandler, r.captionsProperties = { textTrack1: { label: r.config.captionsTextTrack1Label, languageCode: r.config.captionsTextTrack1LanguageCode }, textTrack2: { label: r.config.captionsTextTrack2Label, languageCode: r.config.captionsTextTrack2LanguageCode } }, r.config.enableCEA708Captions) { const i = new Pt(Nt(r), 'textTrack1'); const a = new Pt(Nt(r), 'textTrack2'); r.cea608Parser = new xt(0, i, a); } return r; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r; const a = i.prototype; return a.addCues = function(e, t, r, i) { for (var a, n, s, o, l = this.cueRanges, u = !1, d = l.length; d--;) { const c = l[d]; const h = (a = c[0], n = c[1], s = t, o = r, Math.min(n, o) - Math.max(a, s)); if (h >= 0 && (c[0] = Math.min(c[0], t), c[1] = Math.max(c[1], r), u = !0, h / (r - t) > 0.5)) return; }u || l.push([t, r]), this.Cues.newCue(this.captionsTracks[e], t, r, i); }, a.onInitPtsFound = function(e) { const t = this; const r = e.frag; const i = e.id; const a = e.initPTS; const n = this.unparsedVttFrags; i === 'main' && (this.initPTS[r.cc] = a), n.length && (this.unparsedVttFrags = [], n.forEach(((e) => { t.onFragLoaded(e); }))); }, a.getExistingTrack = function(e) { const t = this.media; if (t) for (let r = 0; r < t.textTracks.length; r++) { const i = t.textTracks[r]; if (i[e]) return i; } return null; }, a.createCaptionsTrack = function(e) { const t = this.captionsProperties; const r = this.captionsTracks; const i = this.media; const a = t[e]; const n = a.label; const s = a.languageCode; if (!r[e]) { const o = this.getExistingTrack(e); if (o)r[e] = o, Be(r[e]), Ne(r[e], i); else { const l = this.createTextTrack('captions', n, s); l && (l[e] = !0, r[e] = l); } } }, a.createTextTrack = function(e, t, r) { const i = this.media; if (i) return i.addTextTrack(e, t, r); }, a.destroy = function() { e.prototype.destroy.call(this); }, a.onMediaAttaching = function(e) { this.media = e.media, this._cleanTracks(); }, a.onMediaDetaching = function() { const e = this.captionsTracks; Object.keys(e).forEach(((t) => { Be(e[t]), delete e[t]; })); }, a.onManifestLoading = function() { this.lastSn = -1, this.prevCC = -1, this.vttCCs = { ccOffset: 0, presentationOffset: 0, 0: { start: 0, prevCC: -1, new: !1 } }, this._cleanTracks(); }, a._cleanTracks = function() { const e = this.media; if (e) { const t = e.textTracks; if (t) for (let r = 0; r < t.length; r++)Be(t[r]); } }, a.onManifestLoaded = function(e) { const t = this; if (this.textTracks = [], this.unparsedVttFrags = this.unparsedVttFrags || [], this.initPTS = [], this.cueRanges = [], this.config.enableWebVTT) { this.tracks = e.subtitles || []; const r = this.media ? this.media.textTracks : []; this.tracks.forEach(((e, i) => { let a; if (i < r.length) { for (var n = null, s = 0; s < r.length; s++) if (Bt(r[s], e)) { n = r[s]; break; }n && (a = n); }a || (a = t.createTextTrack('subtitles', e.name, e.lang)), e.default ? a.mode = t.hls.subtitleDisplay ? 'showing' : 'hidden' : a.mode = 'disabled', t.textTracks.push(a); })); } }, a.onFragLoaded = function(e) { const t = e.frag; const r = e.payload; const i = this.cea608Parser; const a = this.initPTS; const n = this.lastSn; const s = this.unparsedVttFrags; if (t.type === 'main') { const o = t.sn; t.sn !== n + 1 && i && i.reset(), this.lastSn = o; } else if (t.type === 'subtitle') if (r.byteLength) { if (!Object(l.a)(a[t.cc])) return s.push(e), void (a.length && this.hls.trigger(u.a.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: t })); const d = t.decryptdata; d != null && d.key != null && d.method === 'AES-128' || this._parseVTTs(t, r); } else this.hls.trigger(u.a.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: t }); }, a._parseVTTs = function(e, t) { const r = this.hls; const i = this.prevCC; const a = this.textTracks; const n = this.vttCCs; n[e.cc] || (n[e.cc] = { start: e.start, prevCC: i, new: !0 }, this.prevCC = e.cc), Ut.parse(t, this.initPTS[e.cc], n, e.cc, ((t) => { const i = a[e.level]; i.mode !== 'disabled' ? (t.forEach(((e) => { if (!i.cues.getCueById(e.id)) try { if (i.addCue(e), !i.cues.getCueById(e.id)) throw new Error(`addCue is failed for: ${e}`); } catch (r) { d.b.debug(`Failed occurred on adding cues: ${r}`); const t = new window.TextTrackCue(e.startTime, e.endTime, e.text); t.id = e.id, i.addCue(t); } })), r.trigger(u.a.SUBTITLE_FRAG_PROCESSED, { success: !0, frag: e })) : r.trigger(u.a.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: e }); }), ((t) => { d.b.log(`Failed to parse VTT cue: ${t}`), r.trigger(u.a.SUBTITLE_FRAG_PROCESSED, { success: !1, frag: e }); })); }, a.onFragDecrypted = function(e) { const t = e.frag; const r = e.payload; if (t.type === 'subtitle') { if (!Object(l.a)(this.initPTS[t.cc])) return void this.unparsedVttFrags.push(e); this._parseVTTs(t, r); } }, a.onFragParsingUserdata = function(e) { if (this.enabled && this.cea608Parser) for (let t = 0; t < e.samples.length; t++) { const r = e.samples[t].bytes; if (r) { const i = this.extractCea608Data(r); this.cea608Parser.addData(e.samples[t].pts, i); } } }, a.extractCea608Data = function(e) { for (var t, r, i, a = 31 & e[0], n = 2, s = [], o = 0; o < a; o++)t = e[n++], r = 127 & e[n++], i = 127 & e[n++], r === 0 && i === 0 || (4 & t) != 0 && (3 & t) === 0 && (s.push(r), s.push(i)); return s; }, i; }(h)); function Kt(e, t) { for (let r = 0; r < t.length; r++) { const i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } } function jt(e) { for (var t = [], r = 0; r < e.length; r++) { const i = e[r]; i.kind === 'subtitles' && i.label && t.push(e[r]); } return t; } const Ht = (function(e) { let t; let r; function i(t) { let r; return (r = e.call(this, t, u.a.MEDIA_ATTACHED, u.a.MEDIA_DETACHING, u.a.MANIFEST_LOADED, u.a.SUBTITLE_TRACK_LOADED) || this).tracks = [], r.trackId = -1, r.media = null, r.stopped = !0, r.subtitleDisplay = !0, r.queuedDefaultTrack = null, r; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r; let a; let n; let s; const o = i.prototype; return o.destroy = function() { h.prototype.destroy.call(this); }, o.onMediaAttached = function(e) { const t = this; this.media = e.media, this.media && (Object(l.a)(this.queuedDefaultTrack) && (this.subtitleTrack = this.queuedDefaultTrack, this.queuedDefaultTrack = null), this.trackChangeListener = this._onTextTracksChanged.bind(this), this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks), this.useTextTrackPolling ? this.subtitlePollingInterval = setInterval((() => { t.trackChangeListener(); }), 500) : this.media.textTracks.addEventListener('change', this.trackChangeListener)); }, o.onMediaDetaching = function() { this.media && (this.useTextTrackPolling ? clearInterval(this.subtitlePollingInterval) : this.media.textTracks.removeEventListener('change', this.trackChangeListener), Object(l.a)(this.subtitleTrack) && (this.queuedDefaultTrack = this.subtitleTrack), jt(this.media.textTracks).forEach(((e) => { Be(e); })), this.subtitleTrack = -1, this.media = null); }, o.onManifestLoaded = function(e) { const t = this; const r = e.subtitles || []; this.tracks = r, this.hls.trigger(u.a.SUBTITLE_TRACKS_UPDATED, { subtitleTracks: r }), r.forEach(((e) => { e.default && (t.media ? t.subtitleTrack = e.id : t.queuedDefaultTrack = e.id); })); }, o.onSubtitleTrackLoaded = function(e) { const t = this; const r = e.id; const i = e.details; const a = this.trackId; const n = this.tracks; const s = n[a]; if (r >= n.length || r !== a || !s || this.stopped) this._clearReloadTimer(); else if (d.b.log(`subtitle track ${r} loaded`), i.live) { const o = ne(s.details, i, e.stats.trequest); d.b.log(`Reloading live subtitle playlist in ${o}ms`), this.timer = setTimeout((() => { t._loadCurrentTrack(); }), o); } else this._clearReloadTimer(); }, o.startLoad = function() { this.stopped = !1, this._loadCurrentTrack(); }, o.stopLoad = function() { this.stopped = !0, this._clearReloadTimer(); }, o._clearReloadTimer = function() { this.timer && (clearTimeout(this.timer), this.timer = null); }, o._loadCurrentTrack = function() { const e = this.trackId; const t = this.tracks; const r = this.hls; const i = t[e]; e < 0 || !i || i.details && !i.details.live || (d.b.log(`Loading subtitle track ${e}`), r.trigger(u.a.SUBTITLE_TRACK_LOADING, { url: i.url, id: e })); }, o._toggleTrackModes = function(e) { const t = this.media; const r = this.subtitleDisplay; const i = this.trackId; if (t) { const a = jt(t.textTracks); if (e === -1)[].slice.call(a).forEach(((e) => { e.mode = 'disabled'; })); else { const n = a[i]; n && (n.mode = 'disabled'); } const s = a[e]; s && (s.mode = r ? 'showing' : 'hidden'); } }, o._setSubtitleTrackInternal = function(e) { const t = this.hls; const r = this.tracks; !Object(l.a)(e) || e < -1 || e >= r.length || (this.trackId = e, d.b.log(`Switching to subtitle track ${e}`), t.trigger(u.a.SUBTITLE_TRACK_SWITCH, { id: e }), this._loadCurrentTrack()); }, o._onTextTracksChanged = function() { if (this.media) { for (var e = -1, t = jt(this.media.textTracks), r = 0; r < t.length; r++) if (t[r].mode === 'hidden')e = r; else if (t[r].mode === 'showing') { e = r; break; } this.subtitleTrack = e; } }, a = i, (n = [{ key: 'subtitleTracks', get() { return this.tracks; } }, { key: 'subtitleTrack', get() { return this.trackId; }, set(e) { this.trackId !== e && (this._toggleTrackModes(e), this._setSubtitleTrackInternal(e)); } }]) && Kt(a.prototype, n), s && Kt(a, s), i; }(h)); const Vt = r(7); let Yt; const Wt = window.performance; const qt = (function(e) { let t; let r; function i(t, r) { let i; return (i = e.call(this, t, u.a.MEDIA_ATTACHED, u.a.MEDIA_DETACHING, u.a.ERROR, u.a.KEY_LOADED, u.a.FRAG_LOADED, u.a.SUBTITLE_TRACKS_UPDATED, u.a.SUBTITLE_TRACK_SWITCH, u.a.SUBTITLE_TRACK_LOADED, u.a.SUBTITLE_FRAG_PROCESSED, u.a.LEVEL_UPDATED) || this).fragmentTracker = r, i.config = t.config, i.state = ve, i.tracks = [], i.tracksBuffered = [], i.currentTrackId = -1, i.decrypter = new Vt.a(t, t.config), i.lastAVStart = 0, i._onMediaSeeking = i.onMediaSeeking.bind(function(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; }(i)), i; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r; const a = i.prototype; return a.onSubtitleFragProcessed = function(e) { const t = e.frag; const r = e.success; if (this.fragPrevious = t, this.state = ye, r) { const i = this.tracksBuffered[this.currentTrackId]; if (i) { for (var a, n = t.start, s = 0; s < i.length; s++) if (n >= i[s].start && n <= i[s].end) { a = i[s]; break; } const o = t.start + t.duration; a ? a.end = o : (a = { start: n, end: o }, i.push(a)); } } }, a.onMediaAttached = function(e) { const t = e.media; this.media = t, t.addEventListener('seeking', this._onMediaSeeking), this.state = ye; }, a.onMediaDetaching = function() { const e = this; this.media && (this.media.removeEventListener('seeking', this._onMediaSeeking), this.fragmentTracker.removeAllFragments(), this.currentTrackId = -1, this.tracks.forEach(((t) => { e.tracksBuffered[t.id] = []; })), this.media = null, this.state = ve); }, a.onError = function(e) { const t = e.frag; t && t.type === 'subtitle' && (this.state = ye); }, a.onSubtitleTracksUpdated = function(e) { const t = this; d.b.log('subtitle tracks updated'), this.tracksBuffered = [], this.tracks = e.subtitleTracks, this.tracks.forEach(((e) => { t.tracksBuffered[e.id] = []; })); }, a.onSubtitleTrackSwitch = function(e) { if (this.currentTrackId = e.id, this.tracks && this.tracks.length && this.currentTrackId !== -1) { const t = this.tracks[this.currentTrackId]; t && t.details && this.setInterval(500); } else this.clearInterval(); }, a.onSubtitleTrackLoaded = function(e) { const t = e.id; const r = e.details; const i = this.currentTrackId; const a = this.tracks; const n = a[i]; t >= a.length || t !== i || !n || (r.live && (function(e, t, r) { void 0 === r && (r = 0); let i = -1; ae(e, t, ((e, t, r) => { t.start = e.start, i = r; })); const a = t.fragments; if (i < 0)a.forEach(((e) => { e.start += r; })); else for (let n = i + 1; n < a.length; n++)a[n].start = a[n - 1].start + a[n - 1].duration; }(n.details, r, this.lastAVStart)), n.details = r, this.setInterval(500)); }, a.onKeyLoaded = function() { this.state === Te && (this.state = ye); }, a.onFragLoaded = function(e) { const t = this.fragCurrent; const r = e.frag.decryptdata; const i = e.frag; const a = this.hls; if (this.state === Ee && t && e.frag.type === 'subtitle' && t.sn === e.frag.sn && e.payload.byteLength > 0 && r && r.key && r.method === 'AES-128') { const n = Wt.now(); this.decrypter.decrypt(e.payload, r.key.buffer, r.iv.buffer, ((e) => { const t = Wt.now(); a.trigger(u.a.FRAG_DECRYPTED, { frag: i, payload: e, stats: { tstart: n, tdecrypt: t } }); })); } }, a.onLevelUpdated = function(e) { const t = e.details.fragments; this.lastAVStart = t.length ? t[0].start : 0; }, a.doTick = function() { if (this.media) switch (this.state) { case ye: var e = this.config; var t = this.currentTrackId; var r = this.fragmentTracker; var i = this.media; var a = this.tracks; if (!a || !a[t] || !a[t].details) break; var n; var s = e.maxBufferHole; var o = e.maxFragLookUpTolerance; var l = Math.min(e.maxBufferLength, e.maxMaxBufferLength); var c = V.bufferedInfo(this._getBuffered(), i.currentTime, s); var h = c.end; var f = c.len; var g = a[t].details; var p = g.fragments; var v = p.length; var m = p[v - 1].start + p[v - 1].duration; if (f > l) return; var y = this.fragPrevious; h < m ? (y && g.hasProgramDateTime && (n = ue(p, y.endProgramDateTime, o)), n || (n = de(y, p, h, o))) : n = p[v - 1], n && n.encrypted ? (d.b.log(`Loading key for ${n.sn}`), this.state = Te, this.hls.trigger(u.a.KEY_LOADING, { frag: n })) : n && r.getState(n) === N && (this.fragCurrent = n, this.state = Ee, this.hls.trigger(u.a.FRAG_LOADING, { frag: n })); } else this.state = ye; }, a.stopLoad = function() { this.lastAVStart = 0, e.prototype.stopLoad.call(this); }, a._getBuffered = function() { return this.tracksBuffered[this.currentTrackId] || []; }, a.onMediaSeeking = function() { this.fragPrevious = null; }, i; }(Ie)); !(function(e) { e.WIDEVINE = 'com.widevine.alpha', e.PLAYREADY = 'com.microsoft.playready'; }(Yt || (Yt = {}))); const zt = typeof window !== 'undefined' && window.navigator && window.navigator.requestMediaKeySystemAccess ? window.navigator.requestMediaKeySystemAccess.bind(window.navigator) : null; function Xt(e, t) { for (let r = 0; r < t.length; r++) { const i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } } const Qt = (function(e) {
 let t; let r; function i(t) { let r; return (r = e.call(this, t, u.a.MEDIA_ATTACHED, u.a.MEDIA_DETACHED, u.a.MANIFEST_PARSED) || this)._widevineLicenseUrl = void 0, r._licenseXhrSetup = void 0, r._emeEnabled = void 0, r._requestMediaKeySystemAccess = void 0, r._config = void 0, r._mediaKeysList = [], r._media = null, r._hasSetMediaKeys = !1, r._requestLicenseFailureCount = 0, r._onMediaEncrypted = function(e) { d.b.log(`Media is encrypted using "${e.initDataType}" init data type`), r._attemptSetMediaKeys(), r._generateRequestWithPreferredKeySession(e.initDataType, e.initData); }, r._config = t.config, r._widevineLicenseUrl = r._config.widevineLicenseUrl, r._licenseXhrSetup = r._config.licenseXhrSetup, r._emeEnabled = r._config.emeEnabled, r._requestMediaKeySystemAccess = r._config.requestMediaKeySystemAccessFunc, r; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r; let a; let n; let s; const l = i.prototype; return l.getLicenseServerUrl = function(e) { switch (e) { case Yt.WIDEVINE: if (!this._widevineLicenseUrl) break; return this._widevineLicenseUrl; } throw new Error(`no license server URL configured for key-system "${e}"`); }, l._attemptKeySystemAccess = function(e, t, r) { const i = this; const a = (function(e, t, r) { switch (e) { case Yt.WIDEVINE: return (function(e, t) { const r = { videoCapabilities: [] }; return t.forEach(((e) => { r.videoCapabilities.push({ contentType: `video/mp4; codecs="${e}"` }); })), [r]; }(0, r)); default: throw new Error(`Unknown key-system: ${e}`); } }(e, 0, r)); d.b.log('Requesting encrypted media key-system access'), this.requestMediaKeySystemAccess(e, a).then(((t) => { i._onMediaKeySystemAccessObtained(e, t); })).catch(((t) => { d.b.error(`Failed to obtain key-system "${e}" access:`, t); })); }, l._onMediaKeySystemAccessObtained = function(e, t) { const r = this; d.b.log(`Access for key-system "${e}" obtained`); const i = { mediaKeysSessionInitialized: !1, mediaKeySystemAccess: t, mediaKeySystemDomain: e }; this._mediaKeysList.push(i), t.createMediaKeys().then(((t) => { i.mediaKeys = t, d.b.log(`Media-keys created for key-system "${e}"`), r._onMediaKeysCreated(); })).catch(((e) => { d.b.error('Failed to create media-keys:', e); })); }, l._onMediaKeysCreated = function() { const e = this; this._mediaKeysList.forEach(((t) => { t.mediaKeysSession || (t.mediaKeysSession = t.mediaKeys.createSession(), e._onNewMediaKeySession(t.mediaKeysSession)); })); }, l._onNewMediaKeySession = function(e) { const t = this; d.b.log(`New key-system session ${e.sessionId}`), e.addEventListener('message', ((r) => { t._onKeySessionMessage(e, r.message); }), !1); }, l._onKeySessionMessage = function(e, t) { d.b.log('Got EME message event, creating license request'), this._requestLicense(t, ((t) => { d.b.log(`Received license data (length: ${t ? t.byteLength : t}), updating key-session`), e.update(t); })); }, l._attemptSetMediaKeys = function() { if (!this._media) throw new Error('Attempted to set mediaKeys without first attaching a media element'); if (!this._hasSetMediaKeys) { const e = this._mediaKeysList[0]; if (!e || !e.mediaKeys) return d.b.error('Fatal: Media is encrypted but no CDM access or no keys have been obtained yet'), void this.hls.trigger(u.a.ERROR, { type: o.b.KEY_SYSTEM_ERROR, details: o.a.KEY_SYSTEM_NO_KEYS, fatal: !0 }); d.b.log('Setting keys for encrypted media'), this._media.setMediaKeys(e.mediaKeys), this._hasSetMediaKeys = !0; } }, l._generateRequestWithPreferredKeySession = function(e, t) { const r = this; const i = this._mediaKeysList[0]; if (!i) return d.b.error('Fatal: Media is encrypted but not any key-system access has been obtained yet'), void this.hls.trigger(u.a.ERROR, { type: o.b.KEY_SYSTEM_ERROR, details: o.a.KEY_SYSTEM_NO_ACCESS, fatal: !0 }); if (i.mediaKeysSessionInitialized)d.b.warn('Key-Session already initialized but requested again'); else { const a = i.mediaKeysSession; if (!a) return d.b.error('Fatal: Media is encrypted but no key-session existing'), void this.hls.trigger(u.a.ERROR, { type: o.b.KEY_SYSTEM_ERROR, details: o.a.KEY_SYSTEM_NO_SESSION, fatal: !0 }); if (!t) return d.b.warn('Fatal: initData required for generating a key session is null'), void this.hls.trigger(u.a.ERROR, { type: o.b.KEY_SYSTEM_ERROR, details: o.a.KEY_SYSTEM_NO_INIT_DATA, fatal: !0 }); d.b.log(`Generating key-session request for "${e}" init data type`), i.mediaKeysSessionInitialized = !0, a.generateRequest(e, t).then((() => { d.b.debug('Key-session generation succeeded'); })).catch(((e) => { d.b.error('Error generating key-session request:', e), r.hls.trigger(u.a.ERROR, { type: o.b.KEY_SYSTEM_ERROR, details: o.a.KEY_SYSTEM_NO_SESSION, fatal: !1 }); })); } }, l._createLicenseXhr = function(e, t, r) {
 const i = new XMLHttpRequest(); const
a = this._licenseXhrSetup; try { if (a) try { a(i, e); } catch (t) { i.open('POST', e, !0), a(i, e); }i.readyState || i.open('POST', e, !0); } catch (e) { throw new Error(`issue setting up KeySystem license XHR ${e}`); } return i.responseType = 'arraybuffer', i.onreadystatechange = this._onLicenseRequestReadyStageChange.bind(this, i, e, t, r), i;
}, l._onLicenseRequestReadyStageChange = function(e, t, r, i) { switch (e.readyState) { case 4: if (e.status === 200) this._requestLicenseFailureCount = 0, d.b.log('License request succeeded'), e.responseType !== 'arraybuffer' && d.b.warn('xhr response type was not set to the expected arraybuffer for license request'), i(e.response); else { if (d.b.error(`License Request XHR failed (${t}). Status: ${e.status} (${e.statusText})`), this._requestLicenseFailureCount++, this._requestLicenseFailureCount > 3) return void this.hls.trigger(u.a.ERROR, { type: o.b.KEY_SYSTEM_ERROR, details: o.a.KEY_SYSTEM_LICENSE_REQUEST_FAILED, fatal: !0 }); const a = 3 - this._requestLicenseFailureCount + 1; d.b.warn(`Retrying license request, ${a} attempts left`), this._requestLicense(r, i); } } }, l._generateLicenseRequestChallenge = function(e, t) { switch (e.mediaKeySystemDomain) { case Yt.WIDEVINE: return t; } throw new Error(`unsupported key-system: ${e.mediaKeySystemDomain}`); }, l._requestLicense = function(e, t) { d.b.log('Requesting content license for key-system'); const r = this._mediaKeysList[0]; if (!r) return d.b.error('Fatal error: Media is encrypted but no key-system access has been obtained yet'), void this.hls.trigger(u.a.ERROR, { type: o.b.KEY_SYSTEM_ERROR, details: o.a.KEY_SYSTEM_NO_ACCESS, fatal: !0 }); try { const i = this.getLicenseServerUrl(r.mediaKeySystemDomain); const a = this._createLicenseXhr(i, e, t); d.b.log(`Sending license request to URL: ${i}`); const n = this._generateLicenseRequestChallenge(r, e); a.send(n); } catch (e) { d.b.error(`Failure requesting DRM license: ${e}`), this.hls.trigger(u.a.ERROR, { type: o.b.KEY_SYSTEM_ERROR, details: o.a.KEY_SYSTEM_LICENSE_REQUEST_FAILED, fatal: !0 }); } }, l.onMediaAttached = function(e) { if (this._emeEnabled) { const t = e.media; this._media = t, t.addEventListener('encrypted', this._onMediaEncrypted); } }, l.onMediaDetached = function() { this._media && (this._media.removeEventListener('encrypted', this._onMediaEncrypted), this._media = null); }, l.onManifestParsed = function(e) { if (this._emeEnabled) { const t = e.levels.map(((e) => e.audioCodec)); const r = e.levels.map(((e) => e.videoCodec)); this._attemptKeySystemAccess(Yt.WIDEVINE, t, r); } }, a = i, (n = [{ key: 'requestMediaKeySystemAccess', get() { if (!this._requestMediaKeySystemAccess) throw new Error('No requestMediaKeySystemAccess function configured'); return this._requestMediaKeySystemAccess; } }]) && Xt(a.prototype, n), s && Xt(a, s), i;
}(h)); function $t(e, t, r) { return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e; } const Jt = (function(e) { for (let t = 1; t < arguments.length; t++) { var r = arguments[t] != null ? arguments[t] : {}; let i = Object.keys(r); typeof Object.getOwnPropertySymbols === 'function' && (i = i.concat(Object.getOwnPropertySymbols(r).filter(((e) => Object.getOwnPropertyDescriptor(r, e).enumerable)))), i.forEach(((t) => { $t(e, t, r[t]); })); } return e; }({ autoStartLoad: !0, startPosition: -1, defaultAudioCodec: void 0, debug: !1, capLevelOnFPSDrop: !1, capLevelToPlayerSize: !1, initialLiveManifestSize: 1, maxBufferLength: 30, maxBufferSize: 6e7, maxBufferHole: 0.5, overlayKey: void 0, overlayIv: void 0, dKeyDebug: !1, lowBufferWatchdogPeriod: 0.5, highBufferWatchdogPeriod: 3, nudgeOffset: 0.1, nudgeMaxRetry: 3, maxFragLookUpTolerance: 0.25, liveSyncDurationCount: 3, liveMaxLatencyDurationCount: 1 / 0, liveSyncDuration: void 0, liveMaxLatencyDuration: void 0, liveDurationInfinity: !1, liveBackBufferLength: 1 / 0, maxMaxBufferLength: 600, enableWorker: !0, enableSoftwareAES: !0, manifestLoadingTimeOut: 1e4, manifestLoadingMaxRetry: 1, manifestLoadingRetryDelay: 1e3, manifestLoadingMaxRetryTimeout: 64e3, startLevel: void 0, levelLoadingTimeOut: 1e4, levelLoadingMaxRetry: 4, levelLoadingRetryDelay: 1e3, levelLoadingMaxRetryTimeout: 64e3, fragLoadingTimeOut: 2e4, fragLoadingMaxRetry: 6, fragLoadingRetryDelay: 1e3, fragLoadingMaxRetryTimeout: 64e3, startFragPrefetch: !1, fpsDroppedMonitoringPeriod: 5e3, fpsDroppedMonitoringThreshold: 0.2, appendErrorMaxRetry: 3, loader: tt, fLoader: void 0, pLoader: void 0, xhrSetup: void 0, licenseXhrSetup: void 0, abrController: Ye, bufferController: qe, capLevelController: Xe, fpsController: $e, stretchShortVideoTrack: !1, maxAudioFramesDrift: 1, forceKeyFrameOnDiscontinuity: !0, abrEwmaFastLive: 3, abrEwmaSlowLive: 9, abrEwmaFastVoD: 3, abrEwmaSlowVoD: 9, abrEwmaDefaultEstimate: 5e5, abrBandWidthFactor: 0.95, abrBandWidthUpFactor: 0.7, abrMaxWithRealBitrate: !1, maxStarvationDelay: 4, maxLoadingDelay: 4, minAutoBitrate: 0, emeEnabled: !1, widevineLicenseUrl: void 0, requestMediaKeySystemAccessFunc: zt }, (function() {
 0;

return { cueHandler: i, enableCEA708Captions: !0, enableWebVTT: !0, captionsTextTrack1Label: 'English', captionsTextTrack1LanguageCode: 'en', captionsTextTrack2Label: 'Spanish', captionsTextTrack2LanguageCode: 'es' };
}()), { subtitleStreamController: qt, subtitleTrackController: Ht, timelineController: Gt, audioStreamController: st, audioTrackController: it, emeController: Qt })); function Zt(e, t, r) { return t in e ? Object.defineProperty(e, t, { value: r, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = r, e; } function er(e) { if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return e; } function tr(e, t) { for (let r = 0; r < t.length; r++) { const i = t[r]; i.enumerable = i.enumerable || !1, i.configurable = !0, 'value' in i && (i.writable = !0), Object.defineProperty(e, i.key, i); } } function rr(e, t, r) { return t && tr(e.prototype, t), r && tr(e, r), e; }r.d(t, 'default', (() => ir)); var ir = (function(e) { let t; let r; function i(t) { let r; void 0 === t && (t = {}), (r = e.call(this) || this).config = void 0, r._autoLevelCapping = void 0, r.abrController = void 0, r.capLevelController = void 0, r.levelController = void 0, r.streamController = void 0, r.networkControllers = void 0, r.audioTrackController = void 0, r.subtitleTrackController = void 0, r.emeController = void 0, r.coreComponents = void 0, r.media = null, r.url = null; const a = i.DefaultConfig; if ((t.liveSyncDurationCount || t.liveMaxLatencyDurationCount) && (t.liveSyncDuration || t.liveMaxLatencyDuration)) throw new Error("Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration"); r.config = (function(e) { for (let t = 1; t < arguments.length; t++) { var r = arguments[t] != null ? arguments[t] : {}; let i = Object.keys(r); typeof Object.getOwnPropertySymbols === 'function' && (i = i.concat(Object.getOwnPropertySymbols(r).filter(((e) => Object.getOwnPropertyDescriptor(r, e).enumerable)))), i.forEach(((t) => { Zt(e, t, r[t]); })); } return e; }({}, a, t)); const n = er(r).config; if (void 0 !== n.liveMaxLatencyDurationCount && n.liveMaxLatencyDurationCount <= n.liveSyncDurationCount) throw new Error('Illegal hls.js config: "liveMaxLatencyDurationCount" must be gt "liveSyncDurationCount"'); if (void 0 !== n.liveMaxLatencyDuration && (void 0 === n.liveSyncDuration || n.liveMaxLatencyDuration <= n.liveSyncDuration)) throw new Error('Illegal hls.js config: "liveMaxLatencyDuration" must be gt "liveSyncDuration"'); Object(d.a)(n.debug), r._autoLevelCapping = -1; const s = r.abrController = new n.abrController(er(r)); const o = new n.bufferController(er(r)); const l = r.capLevelController = new n.capLevelController(er(r)); const u = new n.fpsController(er(r)); const c = new P(er(r)); const h = new M(er(r)); const f = new U(er(r)); const g = new Ge(er(r)); const p = r.levelController = new Fe(er(r)); const v = new j(er(r)); const m = [p, r.streamController = new xe(er(r), v)]; let y = n.audioStreamController; y && m.push(new y(er(r), v)), r.networkControllers = m; const b = [c, h, f, s, o, l, u, g, v]; if (y = n.audioTrackController) { const T = new y(er(r)); r.audioTrackController = T, b.push(T); } if (y = n.subtitleTrackController) { const E = new y(er(r)); r.subtitleTrackController = E, m.push(E); } if (y = n.emeController) { const S = new y(er(r)); r.emeController = S, b.push(S); } return (y = n.subtitleStreamController) && m.push(new y(er(r), v)), (y = n.timelineController) && b.push(new y(er(r))), r.coreComponents = b, r; }r = e, (t = i).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r, i.isSupported = function() { return (function() { const e = z(); if (!e) return !1; const t = self.SourceBuffer || self.WebKitSourceBuffer; const r = e && typeof e.isTypeSupported === 'function' && e.isTypeSupported('video/mp4; codecs="avc1.42E01E,mp4a.40.2"'); const i = !t || t.prototype && typeof t.prototype.appendBuffer === 'function' && typeof t.prototype.remove === 'function'; return !!r && !!i; }()); }, rr(i, null, [{ key: 'version', get() {} }, { key: 'Events', get() { return u.a; } }, { key: 'ErrorTypes', get() { return o.b; } }, { key: 'ErrorDetails', get() { return o.a; } }, { key: 'DefaultConfig', get() { return i.defaultConfig ? i.defaultConfig : Jt; }, set(e) { i.defaultConfig = e; } }]); const a = i.prototype; return a.destroy = function() { d.b.log('destroy'), this.trigger(u.a.DESTROYING), this.detachMedia(), this.coreComponents.concat(this.networkControllers).forEach(((e) => { e.destroy(); })), this.url = null, this.removeAllListeners(), this._autoLevelCapping = -1; }, a.attachMedia = function(e) { d.b.log('attachMedia'), this.media = e, this.trigger(u.a.MEDIA_ATTACHING, { media: e }); }, a.detachMedia = function() { d.b.log('detachMedia'), this.trigger(u.a.MEDIA_DETACHING), this.media = null; }, a.loadSource = function(e) { e = s.buildAbsoluteURL(window.location.href, e, { alwaysNormalize: !0 }), d.b.log(`loadSource:${e}`), this.url = e, this.trigger(u.a.MANIFEST_LOADING, { url: e }); }, a.startLoad = function(e) { void 0 === e && (e = -1), d.b.log(`startLoad(${e})`), this.networkControllers.forEach(((t) => { t.startLoad(e); })); }, a.stopLoad = function() { d.b.log('stopLoad'), this.networkControllers.forEach(((e) => { e.stopLoad(); })); }, a.swapAudioCodec = function() { d.b.log('swapAudioCodec'), this.streamController.swapAudioCodec(); }, a.recoverMediaError = function() { d.b.log('recoverMediaError'); const e = this.media; this.detachMedia(), e && this.attachMedia(e); }, rr(i, [{ key: 'levels', get() { return this.levelController.levels; } }, { key: 'currentLevel', get() { return this.streamController.currentLevel; }, set(e) { d.b.log(`set currentLevel:${e}`), this.loadLevel = e, this.streamController.immediateLevelSwitch(); } }, { key: 'nextLevel', get() { return this.streamController.nextLevel; }, set(e) { d.b.log(`set nextLevel:${e}`), this.levelController.manualLevel = e, this.streamController.nextLevelSwitch(); } }, { key: 'loadLevel', get() { return this.levelController.level; }, set(e) { d.b.log(`set loadLevel:${e}`), this.levelController.manualLevel = e; } }, { key: 'nextLoadLevel', get() { return this.levelController.nextLoadLevel; }, set(e) { this.levelController.nextLoadLevel = e; } }, { key: 'firstLevel', get() { return Math.max(this.levelController.firstLevel, this.minAutoLevel); }, set(e) { d.b.log(`set firstLevel:${e}`), this.levelController.firstLevel = e; } }, { key: 'startLevel', get() { return this.levelController.startLevel; }, set(e) { d.b.log(`set startLevel:${e}`), e !== -1 && (e = Math.max(e, this.minAutoLevel)), this.levelController.startLevel = e; } }, { key: 'capLevelToPlayerSize', set(e) { const t = !!e; t !== this.config.capLevelToPlayerSize && (t ? this.capLevelController.startCapping() : (this.capLevelController.stopCapping(), this.autoLevelCapping = -1, this.streamController.nextLevelSwitch()), this.config.capLevelToPlayerSize = t); } }, { key: 'autoLevelCapping', get() { return this._autoLevelCapping; }, set(e) { d.b.log(`set autoLevelCapping:${e}`), this._autoLevelCapping = e; } }, { key: 'bandwidthEstimate', get() { const e = this.abrController._bwEstimator; return e ? e.getEstimate() : NaN; } }, { key: 'autoLevelEnabled', get() { return this.levelController.manualLevel === -1; } }, { key: 'manualLevel', get() { return this.levelController.manualLevel; } }, { key: 'minAutoLevel', get() { for (let e = this.levels, t = this.config.minAutoBitrate, r = e ? e.length : 0, i = 0; i < r; i++) { if ((e[i].realBitrate ? Math.max(e[i].realBitrate, e[i].bitrate) : e[i].bitrate) > t) return i; } return 0; } }, { key: 'maxAutoLevel', get() { const e = this.levels; const t = this.autoLevelCapping; return t === -1 && e && e.length ? e.length - 1 : t; } }, { key: 'nextAutoLevel', get() { return Math.min(Math.max(this.abrController.nextAutoLevel, this.minAutoLevel), this.maxAutoLevel); }, set(e) { this.abrController.nextAutoLevel = Math.max(this.minAutoLevel, e); } }, { key: 'audioTracks', get() { const e = this.audioTrackController; return e ? e.audioTracks : []; } }, { key: 'audioTrack', get() { const e = this.audioTrackController; return e ? e.audioTrack : -1; }, set(e) { const t = this.audioTrackController; t && (t.audioTrack = e); } }, { key: 'liveSyncPosition', get() { return this.streamController.liveSyncPosition; } }, { key: 'subtitleTracks', get() { const e = this.subtitleTrackController; return e ? e.subtitleTracks : []; } }, { key: 'subtitleTrack', get() { const e = this.subtitleTrackController; return e ? e.subtitleTrack : -1; }, set(e) { const t = this.subtitleTrackController; t && (t.subtitleTrack = e); } }, { key: 'subtitleDisplay', get() { const e = this.subtitleTrackController; return !!e && e.subtitleDisplay; }, set(e) { const t = this.subtitleTrackController; t && (t.subtitleDisplay = e); } }]), i; }(Q)); ir.defaultConfig = void 0;
}])).default)));
// # sourceMappingURL=hls.min.js.map
